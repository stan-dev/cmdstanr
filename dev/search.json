[{"path":"https://mc-stan.org/cmdstanr/dev/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to cmdstanr","title":"Contributing to cmdstanr","text":"outlines propose change cmdstanr based similar instructions tidyverse packages, including contributing guidelines generated usethis::use_tidy_contributing().","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/CONTRIBUTING.html","id":"fixing-typos","dir":"","previous_headings":"","what":"Fixing typos","title":"Contributing to cmdstanr","text":"can fix typos, spelling mistakes, grammatical errors documentation directly using GitHub web interface, long changes made source file. generally means ’ll need edit roxygen2 comments .R, .Rd file. can find .R file generates .Rd reading comment first line.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/CONTRIBUTING.html","id":"bigger-changes","dir":"","previous_headings":"","what":"Bigger changes","title":"Contributing to cmdstanr","text":"want make bigger change, ’s good idea first file issue make sure someone team agrees ’s needed. ’ve found bug, please file issue illustrates bug minimal reproducible example (see e.g. tidyverse reprex instructions). tidyverse guide create great issue advice.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/CONTRIBUTING.html","id":"pull-request-process","dir":"","previous_headings":"Bigger changes","what":"Pull request process","title":"Contributing to cmdstanr","text":"new creating pull requests tips. Using functions usethis package required can helpful process new . Fork package clone onto computer. haven’t done , recommend using usethis::create_from_github(\"stan-dev/cmdstanr\", fork = TRUE). Install development dependencies devtools::install_dev_deps(), make sure package passes R CMD check running devtools::check(). R CMD check doesn’t pass cleanly, ’s good idea ask help continuing. Create Git branch pull request (PR). recommend using usethis::pr_init(\"brief-description--change\"). Make changes, commit git, create PR running usethis::pr_push(), following prompts browser. title PR briefly describe change. body PR contain Fixes #issue-number. user-facing changes, add bullet top NEWS.md (.e. just first header). Follow style already used NEWS.md.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/CONTRIBUTING.html","id":"code-style","dir":"","previous_headings":"Bigger changes","what":"Code style","title":"Contributing to cmdstanr","text":"New code attempt follow style used package. doubt follow tidyverse style guide. use roxygen2, Markdown syntax, documentation. use testthat unit tests. Contributions test cases included easier accept.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contributing to cmdstanr","text":"Please note cmdstanr project follows Stan project’s Code Conduct. contributing project agree abide terms.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"BSD 3-Clause License","title":"BSD 3-Clause License","text":"Copyright (c) 2019, Stan Developers Assignees rights reserved. Redistribution use source binary forms, without modification, permitted provided following conditions met: Redistributions source code must retain copyright notice, list conditions following disclaimer. Redistributions binary form must reproduce copyright notice, list conditions following disclaimer documentation /materials provided distribution. Neither name copyright holder names contributors may used endorse promote products derived software without specific prior written permission. SOFTWARE PROVIDED COPYRIGHT HOLDERS CONTRIBUTORS “” EXPRESS IMPLIED WARRANTIES, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE DISCLAIMED. EVENT SHALL COPYRIGHT HOLDER CONTRIBUTORS LIABLE DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, CONSEQUENTIAL DAMAGES (INCLUDING, LIMITED , PROCUREMENT SUBSTITUTE GOODS SERVICES; LOSS USE, DATA, PROFITS; BUSINESS INTERRUPTION) HOWEVER CAUSED THEORY LIABILITY, WHETHER CONTRACT, STRICT LIABILITY, TORT (INCLUDING NEGLIGENCE OTHERWISE) ARISING WAY USE SOFTWARE, EVEN ADVISED POSSIBILITY DAMAGE.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/articles/articles-online-only/opencl.html","id":"introduction","dir":"Articles > Articles-online-only","previous_headings":"","what":"Introduction","title":"Running Stan on the GPU with OpenCL","text":"vignette demonstrates use OpenCL capabilities CmdStan CmdStanR. functionality described vignette requires CmdStan 2.26.1 newer. version 2.26.1, users can expect speedups OpenCL using vectorized probability distribution functions (functions _lpdf _lpmf suffix) input variables contain least 20,000 elements. actual speedup model depend particular lpdf/lpmf functions used whether lpdf/lpmf functions bottlenecks model. computationally complex function , larger expected speedup. biggest speedups expected using specialized GLM functions. order establish bottlenecks model recommend using profiling, introduced Stan version 2.26.0.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/articles/articles-online-only/opencl.html","id":"opencl-runtime","dir":"Articles > Articles-online-only","previous_headings":"","what":"OpenCL runtime","title":"Running Stan on the GPU with OpenCL","text":"OpenCL supported modern CPUs GPUs. order use OpenCL CmdStanR, OpenCL runtime target device must installed. guide common devices available CmdStan manual’s chapter parallelization. case using Windows, CmdStan requires OpenCL.lib compile model. experience issue compiling model OpenCL, run script set path_to_opencl_lib path OpenCL.lib file system. using CUDA, path similar one listed .","code":"path_to_opencl_lib <- \"C:/Program Files/NVIDIA GPU Computing Toolkit/CUDA/v11.5/lib/x64\" cpp_options = list(   paste0(\"LDFLAGS+= -L\\\"\",path_to_opencl_lib,\"\\\" -lOpenCL\") )  cmdstanr::cmdstan_make_local(cpp_options = cpp_options) cmdstanr::rebuild_cmdstan()"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/articles-online-only/opencl.html","id":"compiling-a-model-with-opencl","dir":"Articles > Articles-online-only","previous_headings":"","what":"Compiling a model with OpenCL","title":"Running Stan on the GPU with OpenCL","text":"default, models CmdStanR compiled without OpenCL support. OpenCL support enabled, CmdStan model make use OpenCL functions model support . Technically changes model required support OpenCL since choice using OpenCL handled compiler, can still useful rewrite model OpenCL-friendly using vectorization much possible using probability distributions. Consider simple logistic regression parameters alpha beta, covariates X, outcome y. fake data useful run model: model, computation handled bernoulli_logit_glm_lpmf function. supported GPU function, possible accelerate OpenCL. Check list functions OpenCL support. build model OpenCL support, add cpp_options = list(stan_opencl = TRUE) compilation step.","code":"data {   int<lower=1> k;   int<lower=0> n;   matrix[n, k] X;   array[n] int y; } parameters {   vector[k] beta;   real alpha; } model {   target += std_normal_lpdf(beta);   target += std_normal_lpdf(alpha);   target += bernoulli_logit_glm_lpmf(y | X, alpha, beta); } library(cmdstanr)  # Generate some fake data n <- 250000 k <- 20 X <- matrix(rnorm(n * k), ncol = k) y <- rbinom(n, size = 1, prob = plogis(3 * X[,1] - 2 * X[,2] + 1)) mdata <- list(k = k, n = n, y = y, X = X) # Compile the model with STAN_OPENCL=TRUE mod_cl <- cmdstan_model(\"opencl-files/bernoulli_logit_glm.stan\",                         cpp_options = list(stan_opencl = TRUE))"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/articles-online-only/opencl.html","id":"running-models-with-opencl","dir":"Articles > Articles-online-only","previous_headings":"","what":"Running models with OpenCL","title":"Running Stan on the GPU with OpenCL","text":"Running models OpenCL requires specifying OpenCL platform device run model (can multiple). system one GPU OpenCL CPU runtime, platform device IDs GPU typically 0, clinfo tool can used figure sure devices available. Ubuntu system CPU GPU OpenCL support, clinfo -l outputs: system GPU platform ID 0 device ID 0, CPU platform ID 1, device ID 0. can specified opencl_ids argument running model. opencl_ids supplied vector length 2, first element platform ID second argument device ID. ’ll also run version without OpenCL compare run times. speedup OpenCL model : speedup determined particular GPU/CPU used, input problem sizes (data well parameters) model uses functions can run GPU OpenCL devices.","code":"Platform #0: AMD Accelerated Parallel Processing  `-- Device #0: gfx906+sram-ecc Platform #1: Intel(R) CPU Runtime for OpenCL(TM) Applications  `-- Device #0: Intel(R) Core(TM) i7-4790 CPU @ 3.60GHz fit_cl <- mod_cl$sample(data = mdata, chains = 4, parallel_chains = 4,                         opencl_ids = c(0, 0), refresh = 0) # no OpenCL version mod <- cmdstan_model(\"opencl-files/bernoulli_logit_glm.stan\", force_recompile = TRUE) fit_cpu <- mod$sample(data = mdata, chains = 4, parallel_chains = 4, refresh = 0) fit_cpu$time()$total / fit_cl$time()$total"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr-internals.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"How does CmdStanR work?","text":"vignette intended read Getting started CmdStanR vignette. Please read first important background. document provide additional details compiling models, passing data, CmdStan output saved read back R. use $sample() method examples, model fitting methods work similar way hood.","code":"library(cmdstanr) check_cmdstan_toolchain(fix = TRUE, quiet = TRUE)"},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr-internals.html","id":"immediate-compilation","dir":"Articles","previous_headings":"Compilation","what":"Immediate compilation","title":"How does CmdStanR work?","text":"cmdstan_model() function creates new CmdStanModel object. CmdStanModel object stores path Stan program well path compiled executable. Subsequently, create CmdStanModel object Stan file compilation skipped (assuming file hasn’t changed). Internally, cmdstan_model() first creates CmdStanModel object just Stan file calls $compile() method. Optional arguments $compile() method can passed via ....","code":"stan_file <- file.path(cmdstan_path(), \"examples\", \"bernoulli\", \"bernoulli.stan\") mod <- cmdstan_model(stan_file) mod$print() data {   int<lower=0> N;   array[N] int<lower=0, upper=1> y; } parameters {   real<lower=0, upper=1> theta; } model {   theta ~ beta(1, 1); // uniform prior on interval 0,1   y ~ bernoulli(theta); } mod$stan_file() [1] \"/home/runner/.cmdstan/cmdstan-2.37.0/examples/bernoulli/bernoulli.stan\" mod$exe_file() [1] \"/home/runner/.cmdstan/cmdstan-2.37.0/examples/bernoulli/bernoulli\" mod <- cmdstan_model(stan_file) mod <- cmdstan_model(   stan_file,   force_recompile = TRUE,   include_paths = \"paths/to/directories/with/included/files\",   cpp_options = list(stan_threads = TRUE, STANC2 = TRUE) )"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr-internals.html","id":"delayed-compilation","dir":"Articles","previous_headings":"Compilation","what":"Delayed compilation","title":"How does CmdStanR work?","text":"also possible delay compilation creating CmdStanModel object specifying compile=FALSE later calling $compile() method directly.","code":"unlink(mod$exe_file()) mod <- cmdstan_model(stan_file, compile = FALSE) mod$exe_file() # not yet created character(0) mod$compile() mod$exe_file() [1] \"/home/runner/.cmdstan/cmdstan-2.37.0/examples/bernoulli/bernoulli\""},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr-internals.html","id":"pedantic-check","dir":"Articles","previous_headings":"Compilation","what":"Pedantic check","title":"How does CmdStanR work?","text":"using CmdStan version 2.24 later CmdStanR version 0.2.1 later, can run pedantic check model. CmdStanR always check Stan program contain invalid syntax pedantic mode enabled check also warn potential issues model, example: Distribution usages issues: distribution arguments match distribution specification, specific distribution used inadvisable way. Unused parameter: parameter defined contribute target. Large small constant distribution: large small constants used distribution arguments. Control flow depends parameter: branching control flow (like /else) depends parameter value. Parameter multiple twiddles: parameter left-hand side multiple twiddles (.e., multiple ~ symbols). Parameter zero multiple priors: parameter zero one prior distribution. Variable used assignment: variable used assigned value. Strict nonsensical parameter bounds: parameter given questionable bounds. latest information checks performed pedantic mode see Pedantic mode chapter Stan Reference Manual. Pedantic mode available compiling model using separate $check_syntax() method CmdStanModel object. Internally corresponds setting stanc (Stan transpiler) option warn-pedantic. demonstrate pedantic mode Stan program syntactically correct missing lower bound prior parameter. turn pedantic mode compile time can set pedantic=TRUE call cmdstan_model() (calling $compile() method directly using delayed compilation approach described ). turn pedantic mode separately compilation use pedantic argument $check_syntax() method. Using pedantic=TRUE via $check_syntax() method also advantage can used even model hasn’t compiled yet. can helpful pedantic syntax checks much faster compilation.","code":"stan_file_pedantic <- write_stan_file(\" data {   int N;   array[N] int y; } parameters {   // should have <lower=0> but omitting to demonstrate pedantic mode   real lambda; } model {   y ~ poisson(lambda); } \") mod_pedantic <- cmdstan_model(stan_file_pedantic, pedantic = TRUE) Warning in '/tmp/Rtmp4MsRgV/model-390b361dcbe1.stan', line 11, column 14: A     poisson distribution is given parameter lambda as a rate parameter     (argument 1), but lambda was not constrained to be strictly positive. Warning: The parameter lambda has no priors. This means either no prior is     provided, or the prior(s) depend on data variables. In the later case,     this may be a false positive. mod_pedantic$check_syntax(pedantic = TRUE) Warning in '/tmp/Rtmp4MsRgV/model_febb1e69c7387a0e64cf13583e078104.stan', line 11, column 14: A     poisson distribution is given parameter lambda as a rate parameter     (argument 1), but lambda was not constrained to be strictly positive. Warning: The parameter lambda has no priors. This means either no prior is     provided, or the prior(s) depend on data variables. In the later case,     this may be a false positive. Stan program is syntactically correct file.remove(mod_pedantic$exe_file()) # delete compiled executable [1] TRUE rm(mod_pedantic)  mod_pedantic <- cmdstan_model(stan_file_pedantic, compile = FALSE) mod_pedantic$check_syntax(pedantic = TRUE) Warning in '/tmp/Rtmp4MsRgV/model_febb1e69c7387a0e64cf13583e078104.stan', line 11, column 14: A     poisson distribution is given parameter lambda as a rate parameter     (argument 1), but lambda was not constrained to be strictly positive. Warning: The parameter lambda has no priors. This means either no prior is     provided, or the prior(s) depend on data variables. In the later case,     this may be a false positive. Stan program is syntactically correct"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr-internals.html","id":"stan-model-variables","dir":"Articles","previous_headings":"Compilation","what":"Stan model variables","title":"How does CmdStanR work?","text":"using CmdStan 2.27 newer, can obtain names, types dimensions data, parameters, transformed parameters generated quantities variables Stan model using $variables() method CmdStanModel object. $variables() method returns list data, parameters, transformed_parameters generated_quantities elements, corresponding variables respective block program. Transformed data variables listed used model’s input output. variable represented list containing type information (currently limited real int) number dimensions.","code":"stan_file_variables <- write_stan_file(\" data {   int<lower=1> J;   vector<lower=0>[J] sigma;   vector[J] y; } parameters {   real mu;   real<lower=0> tau;   vector[J] theta_raw; } transformed parameters {   vector[J] theta = mu + tau * theta_raw; } model {   target += normal_lpdf(tau | 0, 10);   target += normal_lpdf(mu | 0, 10);   target += normal_lpdf(theta_raw | 0, 1);   target += normal_lpdf(y | theta, sigma); } \") mod_v <- cmdstan_model(stan_file_variables) variables <- mod_v$variables() names(variables) [1] \"parameters\"             \"included_files\"         \"data\"                   [4] \"transformed_parameters\" \"generated_quantities\" names(variables$data) [1] \"J\"     \"sigma\" \"y\" names(variables$parameters) [1] \"mu\"        \"tau\"       \"theta_raw\" names(variables$transformed_parameters) [1] \"theta\" names(variables$generated_quantities) character(0) variables$data$J $type [1] \"int\"  $dimensions [1] 0 variables$data$sigma $type [1] \"real\"  $dimensions [1] 1 variables$parameters$tau $type [1] \"real\"  $dimensions [1] 0 variables$transformed_parameters$theta $type [1] \"real\"  $dimensions [1] 1"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr-internals.html","id":"executable-location","dir":"Articles","previous_headings":"Compilation","what":"Executable location","title":"How does CmdStanR work?","text":"default, executable created directory file containing Stan program. can also specify different location dir argument.","code":"mod <- cmdstan_model(stan_file, dir = \"path/to/directory/for/executable\")"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr-internals.html","id":"processing-data","dir":"Articles","previous_headings":"","what":"Processing data","title":"How does CmdStanR work?","text":"three data formats CmdStanR allows fitting model: named list R objects JSON file R dump file","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr-internals.html","id":"named-list-of-r-objects","dir":"Articles","previous_headings":"Processing data","what":"Named list of R objects","title":"How does CmdStanR work?","text":"Like RStan interface, CmdStanR accepts named list R objects names correspond variables declared data block Stan program. Bernoulli model data N, number data points, y integer array observations. CmdStan doesn’t accept lists R objects, CmdStanR first write data temporary JSON file using write_stan_json(). happens internally, also possible call write_stan_json() directly.","code":"mod$print() data {   int<lower=0> N;   array[N] int<lower=0, upper=1> y; } parameters {   real<lower=0, upper=1> theta; } model {   theta ~ beta(1, 1); // uniform prior on interval 0,1   y ~ bernoulli(theta); } # data block has 'N' and 'y' data_list <- list(N = 10, y = c(0,1,0,0,0,0,0,0,0,1)) fit <- mod$sample(data = data_list) data_list <- list(N = 10, y = c(0,1,0,0,0,0,0,0,0,1)) json_file <- tempfile(fileext = \".json\") write_stan_json(data_list, json_file) cat(readLines(json_file), sep = \"\\n\") {   \"N\": 10,   \"y\": [0, 1, 0, 0, 0, 0, 0, 0, 0, 1] }"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr-internals.html","id":"json-file","dir":"Articles","previous_headings":"Processing data","what":"JSON file","title":"How does CmdStanR work?","text":"already data JSON file can just pass file directly CmdStanR instead using list R objects. example, pass JSON file created using write_stan_json():","code":"fit <- mod$sample(data = json_file)"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr-internals.html","id":"r-dump-file","dir":"Articles","previous_headings":"Processing data","what":"R dump file","title":"How does CmdStanR work?","text":"Finally, also possible use R dump file format. recommended CmdStan can process JSON faster R dump, CmdStanR allows CmdStan accept files created rstan::stan_rdump():","code":"rdump_file <- tempfile(fileext = \".data.R\") rstan::stan_rdump(names(data_list), file = rdump_file, envir = list2env(data_list)) cat(readLines(rdump_file), sep = \"\\n\") fit <- mod$sample(data = rdump_file)"},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr-internals.html","id":"default-temporary-files","dir":"Articles","previous_headings":"Writing CmdStan output to CSV","what":"Default temporary files","title":"How does CmdStanR work?","text":"fitting model, default behavior write output CmdStan CSV files temporary directory. files lost end R session remove fit object force (wait ) garbage collection.","code":"data_list <- list(N = 10, y = c(0,1,0,0,0,0,0,0,0,1)) fit <- mod$sample(data = data_list) fit$output_files() [1] \"/tmp/Rtmp4MsRgV/bernoulli-202512311805-1-5be443.csv\" [2] \"/tmp/Rtmp4MsRgV/bernoulli-202512311805-2-5be443.csv\" [3] \"/tmp/Rtmp4MsRgV/bernoulli-202512311805-3-5be443.csv\" [4] \"/tmp/Rtmp4MsRgV/bernoulli-202512311805-4-5be443.csv\" files <- fit$output_files() file.exists(files) [1] TRUE TRUE TRUE TRUE rm(fit) gc() used (Mb) gc trigger  (Mb) max used (Mb) Ncells 1219849 65.2    2509321 134.1  1590917 85.0 Vcells 2121996 16.2    8388608  64.0  4904273 37.5 file.exists(files) [1] FALSE FALSE FALSE FALSE"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr-internals.html","id":"non-temporary-files","dir":"Articles","previous_headings":"Writing CmdStan output to CSV","what":"Non-temporary files","title":"How does CmdStanR work?","text":"save files non-temporary location two options. can either specify output_dir argument mod$sample() use fit$save_output_files() fitting model.","code":"# see ?save_output_files for info on optional arguments fit$save_output_files(dir = \"path/to/directory\") fit <- mod$sample(   data = data_list,   output_dir = \"path/to/directory\" )"},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr-internals.html","id":"lazy-csv-reading","dir":"Articles","previous_headings":"Reading CmdStan output into R","what":"Lazy CSV reading","title":"How does CmdStanR work?","text":"exception diagnostic information, CSV files read R contents requested calling method requires (e.g., fit$draws(), fit$summary(), etc.). examine structure fit object, notice Private slot draws_ NULL, indicating CSV files haven’t yet read R. call method requires draws reexamine structure object see draws_ slot Private longer empty. models many parameters, transformed parameters, generated quantities, requested (e.g., specifying variables argument fit$draws()) CmdStanR read requested variables (unless already read ).","code":"str(fit) Classes 'CmdStanMCMC', 'CmdStanFit', 'R6' <CmdStanMCMC>   Inherits from: <CmdStanFit>   Public:     clone: function (deep = FALSE)      cmdstan_diagnose: function ()      cmdstan_summary: function (flags = NULL)      code: function ()      config_files: function (include_failed = FALSE)      constrain_variables: function (unconstrained_variables, transformed_parameters = TRUE,      data_file: function ()      diagnostic_summary: function (diagnostics = c(\"divergences\", \"treedepth\", \"ebfmi\"),      draws: function (variables = NULL, inc_warmup = FALSE, format = getOption(\"cmdstanr_draws_format\",      expose_functions: function (global = FALSE, verbose = FALSE)      functions: environment     grad_log_prob: function (unconstrained_variables, jacobian = TRUE, jacobian_adjustment = NULL)      hessian: function (unconstrained_variables, jacobian = TRUE, jacobian_adjustment = NULL)      init: function ()      init_model_methods: function (seed = 1, verbose = FALSE, hessian = FALSE)      initialize: function (runset)      inv_metric: function (matrix = TRUE)      latent_dynamics_files: function (include_failed = FALSE)      log_prob: function (unconstrained_variables, jacobian = TRUE, jacobian_adjustment = NULL)      loo: function (variables = \"log_lik\", r_eff = FALSE, moment_match = FALSE,      lp: function ()      metadata: function ()      metric_files: function (include_failed = FALSE)      num_chains: function ()      num_procs: function ()      output: function (id = NULL)      output_files: function (include_failed = FALSE)      print: function (variables = NULL, ..., digits = 2, max_rows = getOption(\"cmdstanr_max_rows\",      profile_files: function (include_failed = FALSE)      profiles: function ()      return_codes: function ()      runset: CmdStanRun, R6     sampler_diagnostics: function (inc_warmup = FALSE, format = getOption(\"cmdstanr_draws_format\",      save_config_files: function (dir = \".\", basename = NULL, timestamp = TRUE, random = TRUE)      save_data_file: function (dir = \".\", basename = NULL, timestamp = TRUE, random = TRUE)      save_latent_dynamics_files: function (dir = \".\", basename = NULL, timestamp = TRUE, random = TRUE)      save_metric_files: function (dir = \".\", basename = NULL, timestamp = TRUE, random = TRUE)      save_object: function (file, ...)      save_output_files: function (dir = \".\", basename = NULL, timestamp = TRUE, random = TRUE)      save_profile_files: function (dir = \".\", basename = NULL, timestamp = TRUE, random = TRUE)      summary: function (variables = NULL, ...)      time: function ()      unconstrain_draws: function (files = NULL, draws = NULL, format = getOption(\"cmdstanr_draws_format\",      unconstrain_variables: function (variables)      variable_skeleton: function (transformed_parameters = TRUE, generated_quantities = TRUE)    Private:     draws_: NULL     init_: NULL     inv_metric_: list     metadata_: list     model_methods_env_: environment     profiles_: NULL     read_csv_: function (variables = NULL, sampler_diagnostics = NULL, format = getOption(\"cmdstanr_draws_format\",      return_codes_: 0 0 0 0     sampler_diagnostics_: 2 1 1 1 1 2 2 1 2 1 1 1 1 2 2 2 1 2 1 1 1 1 1 2 2 1 1 1  ...     warmup_draws_: NULL     warmup_sampler_diagnostics_: NULL draws <- fit$draws() # force CSVs to be read into R str(fit) Classes 'CmdStanMCMC', 'CmdStanFit', 'R6' <CmdStanMCMC>   Inherits from: <CmdStanFit>   Public:     clone: function (deep = FALSE)      cmdstan_diagnose: function ()      cmdstan_summary: function (flags = NULL)      code: function ()      config_files: function (include_failed = FALSE)      constrain_variables: function (unconstrained_variables, transformed_parameters = TRUE,      data_file: function ()      diagnostic_summary: function (diagnostics = c(\"divergences\", \"treedepth\", \"ebfmi\"),      draws: function (variables = NULL, inc_warmup = FALSE, format = getOption(\"cmdstanr_draws_format\",      expose_functions: function (global = FALSE, verbose = FALSE)      functions: environment     grad_log_prob: function (unconstrained_variables, jacobian = TRUE, jacobian_adjustment = NULL)      hessian: function (unconstrained_variables, jacobian = TRUE, jacobian_adjustment = NULL)      init: function ()      init_model_methods: function (seed = 1, verbose = FALSE, hessian = FALSE)      initialize: function (runset)      inv_metric: function (matrix = TRUE)      latent_dynamics_files: function (include_failed = FALSE)      log_prob: function (unconstrained_variables, jacobian = TRUE, jacobian_adjustment = NULL)      loo: function (variables = \"log_lik\", r_eff = FALSE, moment_match = FALSE,      lp: function ()      metadata: function ()      metric_files: function (include_failed = FALSE)      num_chains: function ()      num_procs: function ()      output: function (id = NULL)      output_files: function (include_failed = FALSE)      print: function (variables = NULL, ..., digits = 2, max_rows = getOption(\"cmdstanr_max_rows\",      profile_files: function (include_failed = FALSE)      profiles: function ()      return_codes: function ()      runset: CmdStanRun, R6     sampler_diagnostics: function (inc_warmup = FALSE, format = getOption(\"cmdstanr_draws_format\",      save_config_files: function (dir = \".\", basename = NULL, timestamp = TRUE, random = TRUE)      save_data_file: function (dir = \".\", basename = NULL, timestamp = TRUE, random = TRUE)      save_latent_dynamics_files: function (dir = \".\", basename = NULL, timestamp = TRUE, random = TRUE)      save_metric_files: function (dir = \".\", basename = NULL, timestamp = TRUE, random = TRUE)      save_object: function (file, ...)      save_output_files: function (dir = \".\", basename = NULL, timestamp = TRUE, random = TRUE)      save_profile_files: function (dir = \".\", basename = NULL, timestamp = TRUE, random = TRUE)      summary: function (variables = NULL, ...)      time: function ()      unconstrain_draws: function (files = NULL, draws = NULL, format = getOption(\"cmdstanr_draws_format\",      unconstrain_variables: function (variables)      variable_skeleton: function (transformed_parameters = TRUE, generated_quantities = TRUE)    Private:     draws_: -6.7488137 -7.3283887 -7.0892006 -6.8032797 -7.1263639 - ...     init_: NULL     inv_metric_: list     metadata_: list     model_methods_env_: environment     profiles_: NULL     read_csv_: function (variables = NULL, sampler_diagnostics = NULL, format = getOption(\"cmdstanr_draws_format\",      return_codes_: 0 0 0 0     sampler_diagnostics_: 2 1 1 1 1 2 2 1 2 1 1 1 1 2 2 2 1 2 1 1 1 1 1 2 2 1 1 1  ...     warmup_draws_: NULL     warmup_sampler_diagnostics_: NULL"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr-internals.html","id":"read_cmdstan_csv","dir":"Articles","previous_headings":"Reading CmdStan output into R","what":"read_cmdstan_csv()","title":"How does CmdStanR work?","text":"Internally, read_cmdstan_csv() function used read CmdStan CSV files R. function exposed users, can also call directly.","code":"# see ?read_cmdstan_csv for info on optional arguments controlling # what information is read in csv_contents <- read_cmdstan_csv(fit$output_files()) str(csv_contents) List of 8  $ metadata                       :List of 42   ..$ stan_version_major  : num 2   ..$ stan_version_minor  : num 37   ..$ stan_version_patch  : num 0   ..$ start_datetime      : chr \"2025-12-31 18:05:55 UTC\"   ..$ method              : chr \"sample\"   ..$ save_warmup         : int 0   ..$ thin                : num 1   ..$ gamma               : num 0.05   ..$ kappa               : num 0.75   ..$ t0                  : num 10   ..$ init_buffer         : num 75   ..$ term_buffer         : num 50   ..$ window              : num 25   ..$ save_metric         : int 0   ..$ algorithm           : chr \"hmc\"   ..$ engine              : chr \"nuts\"   ..$ metric              : chr \"diag_e\"   ..$ stepsize_jitter     : num 0   ..$ num_chains          : num 1   ..$ id                  : num [1:4] 1 2 3 4   ..$ init                : num [1:4] 2 2 2 2   ..$ seed                : num 31749990   ..$ refresh             : num 100   ..$ sig_figs            : num 8   ..$ profile_file        : chr \"/tmp/Rtmp4MsRgV/bernoulli-profile-202512311805-1-2c7013.csv\"   ..$ save_cmdstan_config : int 0   ..$ stanc_version       : chr \"stanc3 v2.37.0\"   ..$ sampler_diagnostics : chr [1:6] \"accept_stat__\" \"stepsize__\" \"treedepth__\" \"n_leapfrog__\" ...   ..$ variables           : chr [1:2] \"lp__\" \"theta\"   ..$ step_size_adaptation: num [1:4] 0.895 0.892 0.942 0.929   ..$ model_name          : chr \"bernoulli_model\"   ..$ adapt_engaged       : int 1   ..$ adapt_delta         : num 0.8   ..$ max_treedepth       : num 10   ..$ step_size           : num [1:4] 1 1 1 1   ..$ iter_warmup         : num 1000   ..$ iter_sampling       : num 1000   ..$ threads_per_chain   : num 1   ..$ time                :'data.frame':    4 obs. of  4 variables:   .. ..$ chain_id: num [1:4] 1 2 3 4   .. ..$ warmup  : num [1:4] 0.002 0.002 0.002 0.002   .. ..$ sampling: num [1:4] 0.005 0.005 0.005 0.005   .. ..$ total   : num [1:4] 0.007 0.007 0.007 0.007   ..$ stan_variable_sizes :List of 2   .. ..$ lp__ : num 1   .. ..$ theta: num 1   ..$ stan_variables      : chr [1:2] \"lp__\" \"theta\"   ..$ model_params        : chr [1:2] \"lp__\" \"theta\"  $ time                           :List of 2   ..$ total : int NA   ..$ chains:'data.frame':  4 obs. of  4 variables:   .. ..$ chain_id: num [1:4] 1 2 3 4   .. ..$ warmup  : num [1:4] 0.002 0.002 0.002 0.002   .. ..$ sampling: num [1:4] 0.005 0.005 0.005 0.005   .. ..$ total   : num [1:4] 0.007 0.007 0.007 0.007  $ inv_metric                     :List of 4   ..$ 1: num 0.588   ..$ 2: num 0.545   ..$ 3: num 0.577   ..$ 4: num 0.527  $ step_size                      :List of 4   ..$ 1: num 0.895   ..$ 2: num 0.892   ..$ 3: num 0.942   ..$ 4: num 0.929  $ warmup_draws                   : NULL  $ post_warmup_draws              : 'draws_array' num [1:1000, 1:4, 1:2] -6.75 -7.33 -7.09 -6.8 -7.13 ...   ..- attr(*, \"dimnames\")=List of 3   .. ..$ iteration: chr [1:1000] \"1\" \"2\" \"3\" \"4\" ...   .. ..$ chain    : chr [1:4] \"1\" \"2\" \"3\" \"4\"   .. ..$ variable : chr [1:2] \"lp__\" \"theta\"  $ warmup_sampler_diagnostics     : NULL  $ post_warmup_sampler_diagnostics: 'draws_array' num [1:1000, 1:4, 1:6] 0.999 0.863 1 0.965 0.932 ...   ..- attr(*, \"dimnames\")=List of 3   .. ..$ iteration: chr [1:1000] \"1\" \"2\" \"3\" \"4\" ...   .. ..$ chain    : chr [1:4] \"1\" \"2\" \"3\" \"4\"   .. ..$ variable : chr [1:6] \"accept_stat__\" \"stepsize__\" \"treedepth__\" \"n_leapfrog__\" ..."},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr-internals.html","id":"as_cmdstan_fit","dir":"Articles","previous_headings":"Reading CmdStan output into R","what":"as_cmdstan_fit()","title":"How does CmdStanR work?","text":"need manually create fitted model objects CmdStan CSV files use as_cmdstan_fit(). pointless case since original fit object, function can used create fitted model objects (CmdStanMCMC, CmdStanMLE, etc.) CmdStan CSV files.","code":"fit2 <- as_cmdstan_fit(fit$output_files())"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr-internals.html","id":"saving-and-accessing-advanced-algorithm-info-latent-dynamics","dir":"Articles","previous_headings":"Reading CmdStan output into R","what":"Saving and accessing advanced algorithm info (latent dynamics)","title":"How does CmdStanR work?","text":"save_latent_dynamics set TRUE running $sample() method additional CSV files created (one per chain) provide access quantities used hood Stan’s implementation dynamic Hamiltonian Monte Carlo. CmdStanR yet provide special method processing files can read R using R’s standard CSV reading functions. column lp__ also provided via fit$draws(), columns accept_stat__, stepsize__, treedepth__, n_leapfrog__, divergent__, energy__ also provided fit$sampler_diagnostics(), several columns unique latent dynamics file. model single parameter theta three columns correspond theta unconstrained space (theta constrained space accessed via fit$draws()), auxiliary momentum p_theta, gradient g_theta. general, three columns exist every parameter model.","code":"fit <- mod$sample(data = data_list, save_latent_dynamics = TRUE) fit$latent_dynamics_files() [1] \"/tmp/Rtmp4MsRgV/bernoulli-diagnostic-202512311805-1-057298.csv\" [2] \"/tmp/Rtmp4MsRgV/bernoulli-diagnostic-202512311805-2-057298.csv\" [3] \"/tmp/Rtmp4MsRgV/bernoulli-diagnostic-202512311805-3-057298.csv\" [4] \"/tmp/Rtmp4MsRgV/bernoulli-diagnostic-202512311805-4-057298.csv\" # read one of the files in x <- utils::read.csv(fit$latent_dynamics_files()[1], comment.char = \"#\") head(x) lp__ accept_stat__ stepsize__ treedepth__ n_leapfrog__ divergent__ 1 -7.008996     0.9351107   1.069334           1            3           0 2 -7.299006     0.8867785   1.069334           1            1           0 3 -6.828942     1.0000000   1.069334           1            1           0 4 -6.820257     1.0000000   1.069334           1            1           0 5 -6.753109     0.9935051   1.069334           2            3           0 6 -6.897199     0.9607730   1.069334           1            3           0   energy__      theta    p_theta    g_theta 1 7.059322 -0.6338870  0.4400119  1.1595562 2 7.380108 -0.4323169 -0.5585757  1.7228786 3 7.122224 -0.8359846 -1.0622074  0.6285738 4 6.850743 -0.8502093  0.3424676  0.5926674 5 6.854350 -1.1662395  0.6240870 -0.1495753 6 6.920060 -0.7444621  0.2965665  0.8643500 head(x[, c(\"theta\", \"p_theta\", \"g_theta\")]) theta    p_theta    g_theta 1 -0.6338870  0.4400119  1.1595562 2 -0.4323169 -0.5585757  1.7228786 3 -0.8359846 -1.0622074  0.6285738 4 -0.8502093  0.3424676  0.5926674 5 -1.1662395  0.6240870 -0.1495753 6 -0.7444621  0.2965665  0.8643500"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr-internals.html","id":"developing-using-cmdstanr","dir":"Articles","previous_headings":"","what":"Developing using CmdStanR","title":"How does CmdStanR work?","text":"CmdStanR can course used developing packages require compiling running Stan models well using new custom Stan features available CmdStan.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr-internals.html","id":"pre-compiled-stan-models-in-r-packages","dir":"Articles","previous_headings":"Developing using CmdStanR","what":"Pre-compiled Stan models in R packages","title":"How does CmdStanR work?","text":"may compile Stan model runtime (e.g. just sampling), may compile models inside package file system advance installation time. latter avoids compilations runtime, matters centrally managed R installations users compile software. pre-compile models package, may create top-level scripts configure configure.win run cmdstan_model() compile = TRUE save compiled executables somewhere inside inst/ folder package source. instantiate package helps developers configure packages way, documents topics submitting CRAN administering CmdStan. Kevin Ushey’s configure package helps create manage package configuration files general.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr-internals.html","id":"troubleshooting-and-debugging","dir":"Articles","previous_headings":"Developing using CmdStanR","what":"Troubleshooting and debugging","title":"How does CmdStanR work?","text":"developing testing new features might useful information CmdStan called internally see information printed compiling running models. can enabled entire R session setting option \"cmdstanr_verbose\" TRUE.","code":"options(\"cmdstanr_verbose\"=TRUE)  mod <- cmdstan_model(stan_file, force_recompile = TRUE) Running make /tmp/Rtmp4MsRgV/model-390b2d6268c \\   \"STANCFLAGS +=  --name='bernoulli_model'\"  --- Translating Stan model to C++ code --- bin/stanc --name='bernoulli_model' --o=/tmp/Rtmp4MsRgV/model-390b2d6268c.hpp /tmp/Rtmp4MsRgV/model-390b2d6268c.stan  --- Compiling C++ code --- g++ -Wno-deprecated-declarations -std=c++17 -pthread -D_REENTRANT -Wno-sign-compare -Wno-ignored-attributes -Wno-class-memaccess      -I stan/lib/stan_math/lib/tbb_2020.3/include    -O3 -I src -I stan/src -I stan/lib/rapidjson_1.1.0/ -I lib/CLI11-1.9.1/ -I stan/lib/stan_math/ -I stan/lib/stan_math/lib/eigen_3.4.0 -I stan/lib/stan_math/lib/boost_1.87.0 -I stan/lib/stan_math/lib/sundials_6.1.1/include -I stan/lib/stan_math/lib/sundials_6.1.1/src/sundials    -DBOOST_DISABLE_ASSERTS          -c -Wno-ignored-attributes   -x c++ -o /tmp/Rtmp4MsRgV/model-390b2d6268c.o /tmp/Rtmp4MsRgV/model-390b2d6268c.hpp  --- Linking model --- g++ -Wno-deprecated-declarations -std=c++17 -pthread -D_REENTRANT -Wno-sign-compare -Wno-ignored-attributes -Wno-class-memaccess      -I stan/lib/stan_math/lib/tbb_2020.3/include    -O3 -I src -I stan/src -I stan/lib/rapidjson_1.1.0/ -I lib/CLI11-1.9.1/ -I stan/lib/stan_math/ -I stan/lib/stan_math/lib/eigen_3.4.0 -I stan/lib/stan_math/lib/boost_1.87.0 -I stan/lib/stan_math/lib/sundials_6.1.1/include -I stan/lib/stan_math/lib/sundials_6.1.1/src/sundials    -DBOOST_DISABLE_ASSERTS               -Wl,-L,\"/home/runner/.cmdstan/cmdstan-2.37.0/stan/lib/stan_math/lib/tbb\"   -Wl,-rpath,\"/home/runner/.cmdstan/cmdstan-2.37.0/stan/lib/stan_math/lib/tbb\"      /tmp/Rtmp4MsRgV/model-390b2d6268c.o src/cmdstan/main.o       -ltbb   stan/lib/stan_math/lib/sundials_6.1.1/lib/libsundials_nvecserial.a stan/lib/stan_math/lib/sundials_6.1.1/lib/libsundials_cvodes.a stan/lib/stan_math/lib/sundials_6.1.1/lib/libsundials_idas.a stan/lib/stan_math/lib/sundials_6.1.1/lib/libsundials_kinsol.a  stan/lib/stan_math/lib/tbb/libtbb.so.2 -o /tmp/Rtmp4MsRgV/model-390b2d6268c rm /tmp/Rtmp4MsRgV/model-390b2d6268c.hpp /tmp/Rtmp4MsRgV/model-390b2d6268c.o stan_version_major = 2 stan_version_minor = 37 stan_version_patch = 0 STAN_THREADS=false STAN_MPI=false STAN_OPENCL=false STAN_NO_RANGE_CHECKS=false STAN_CPP_OPTIMS=false fit <- mod$sample(   data = data_list,   chains = 1,   iter_warmup = 100,   iter_sampling = 100 ) Running MCMC with 1 chain...  Running ./bernoulli 'id=1' random 'seed=1376020223' data \\   'file=/tmp/Rtmp4MsRgV/standata-390b5dc141b4.json' output \\   'file=/tmp/Rtmp4MsRgV/bernoulli-202512311806-1-1e1465.csv' \\   'profile_file=/tmp/Rtmp4MsRgV/bernoulli-profile-202512311806-1-3dcc40.csv' \\   'method=sample' 'num_samples=100' 'num_warmup=100' 'save_warmup=0' \\   'algorithm=hmc' 'engine=nuts' adapt 'engaged=1' Chain 1 method = sample (Default)  Chain 1   sample  Chain 1     num_samples = 100  Chain 1     num_warmup = 100  Chain 1     save_warmup = false (Default)  Chain 1     thin = 1 (Default)  Chain 1     adapt  Chain 1       engaged = true (Default)  Chain 1       gamma = 0.05 (Default)  Chain 1       delta = 0.8 (Default)  Chain 1       kappa = 0.75 (Default)  Chain 1       t0 = 10 (Default)  Chain 1       init_buffer = 75 (Default)  Chain 1       term_buffer = 50 (Default)  Chain 1       window = 25 (Default)  Chain 1       save_metric = false (Default)  Chain 1     algorithm = hmc (Default)  Chain 1       hmc  Chain 1         engine = nuts (Default)  Chain 1           nuts  Chain 1             max_depth = 10 (Default)  Chain 1         metric = diag_e (Default)  Chain 1         metric_file =  (Default)  Chain 1         stepsize = 1 (Default)  Chain 1         stepsize_jitter = 0 (Default)  Chain 1     num_chains = 1 (Default)  Chain 1 id = 1 (Default)  Chain 1 data  Chain 1   file = /tmp/Rtmp4MsRgV/standata-390b5dc141b4.json  Chain 1 init = 2 (Default)  Chain 1 random  Chain 1   seed = 1376020223  Chain 1 output  Chain 1   file = /tmp/Rtmp4MsRgV/bernoulli-202512311806-1-1e1465.csv  Chain 1   diagnostic_file =  (Default)  Chain 1   refresh = 100 (Default)  Chain 1   sig_figs = 8 (Default)  Chain 1   profile_file = /tmp/Rtmp4MsRgV/bernoulli-profile-202512311806-1-3dcc40.csv  Chain 1   save_cmdstan_config = false (Default)  Chain 1 num_threads = 1 (Default)  Chain 1 Gradient evaluation took 2e-06 seconds  Chain 1 1000 transitions using 10 leapfrog steps per transition would take 0.02 seconds.  Chain 1 Adjust your expectations accordingly!  Chain 1 WARNING: There aren't enough warmup iterations to fit the  Chain 1          three stages of adaptation as currently configured.  Chain 1          Reducing each adaptation stage to 15%/75%/10% of  Chain 1          the given number of warmup iterations:  Chain 1            init_buffer = 15  Chain 1            adapt_window = 75  Chain 1            term_buffer = 10  Chain 1 Iteration:   1 / 200 [  0%]  (Warmup)  Chain 1 Iteration: 100 / 200 [ 50%]  (Warmup)  Chain 1 Iteration: 101 / 200 [ 50%]  (Sampling)  Chain 1 Iteration: 200 / 200 [100%]  (Sampling)  Chain 1  Elapsed Time: 0 seconds (Warm-up)  Chain 1                0 seconds (Sampling)  Chain 1                0 seconds (Total)  Chain 1 finished in 0.0 seconds."},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Getting started with CmdStanR","text":"CmdStanR (Command Stan R) lightweight interface Stan R users provides alternative traditional RStan interface. See Comparison RStan section later vignette details two interfaces differ. Using CmdStanR requires installing cmdstanr R package also CmdStan, command line interface Stan. First install R package running following command R. can now load package like R package. ’ll also load bayesplot posterior packages use later examples.","code":"# we recommend running this is a fresh R session or restarting your current session install.packages(\"cmdstanr\", repos = c('https://stan-dev.r-universe.dev', getOption(\"repos\"))) library(cmdstanr) library(posterior) library(bayesplot) color_scheme_set(\"brightblue\")"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr.html","id":"installing-cmdstan","dir":"Articles","previous_headings":"","what":"Installing CmdStan","title":"Getting started with CmdStanR","text":"CmdStanR requires working installation CmdStan, shell interface Stan. don’t CmdStan installed CmdStanR can install , assuming suitable C++ toolchain. requirements described CmdStan Guide: https://mc-stan.org/docs/cmdstan-guide/cmdstan-installation.html double check toolchain set properly can call check_cmdstan_toolchain() function: toolchain configured correctly CmdStan can installed calling install_cmdstan() function: CmdStanR can used needs know CmdStan installation located. package loaded tries help automate avoid manually set path every session: environment variable \"CMDSTAN\" exists load time value automatically set default path CmdStan R session. useful CmdStan installation located default directory used install_cmdstan() (see #2). environment variable found loaded directory form \".cmdstan/cmdstan-[version]\", example \".cmdstan/cmdstan-2.23.0\", exists user’s home directory (Sys.getenv(\"HOME\"), current working directory) path CmdStan largest version number set path CmdStan R session. default directory install_cmdstan() uses install latest version CmdStan, ’s installed CmdStan shouldn’t need manually set path CmdStan loading CmdStanR. neither applies (want subsequently change path) can use set_cmdstan_path() function: check path CmdStan installation CmdStan version number can use cmdstan_path() cmdstan_version():","code":"check_cmdstan_toolchain() The C++ toolchain required for CmdStan is setup properly! install_cmdstan(cores = 2) set_cmdstan_path(PATH_TO_CMDSTAN) cmdstan_path() [1] \"/home/runner/.cmdstan/cmdstan-2.37.0\" cmdstan_version() [1] \"2.37.0\""},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr.html","id":"compiling-a-model","dir":"Articles","previous_headings":"","what":"Compiling a model","title":"Getting started with CmdStanR","text":"cmdstan_model() function creates new CmdStanModel object file containing Stan program. hood, CmdStan called translate Stan program C++ create compiled executable. ’ll use example Stan program comes CmdStan installation: object mod R6 reference object class CmdStanModel behaves similarly R’s reference class objects object oriented programming languages. Methods accessed using $ operator. design choice allows CmdStanR CmdStanPy provide similar user experience share many implementation details. Stan program can printed using $print() method: path compiled executable returned $exe_file() method:","code":"file <- file.path(cmdstan_path(), \"examples\", \"bernoulli\", \"bernoulli.stan\") mod <- cmdstan_model(file) mod$print() data {   int<lower=0> N;   array[N] int<lower=0, upper=1> y; } parameters {   real<lower=0, upper=1> theta; } model {   theta ~ beta(1, 1); // uniform prior on interval 0,1   y ~ bernoulli(theta); } mod$exe_file() [1] \"/home/runner/.cmdstan/cmdstan-2.37.0/examples/bernoulli/bernoulli\""},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr.html","id":"running-mcmc","dir":"Articles","previous_headings":"","what":"Running MCMC","title":"Getting started with CmdStanR","text":"$sample() method CmdStanModel objects runs Stan’s default MCMC algorithm. data argument accepts named list R objects (like RStan) path data file compatible CmdStan (JSON R dump). many arguments can passed $sample() method. details follow link separate documentation page: $sample() $sample() method creates R6 CmdStanMCMC objects, many associated methods. demonstrate important methods. full list, follow link CmdStanMCMC documentation: CmdStanMCMC","code":"# names correspond to the data block in the Stan program data_list <- list(N = 10, y = c(0,1,0,0,0,0,0,0,0,1))  fit <- mod$sample(   data = data_list,   seed = 123,   chains = 4,   parallel_chains = 4,   refresh = 500 # print update every 500 iters ) Running MCMC with 4 parallel chains...  Chain 1 Iteration:    1 / 2000 [  0%]  (Warmup)  Chain 1 Iteration:  500 / 2000 [ 25%]  (Warmup)  Chain 1 Iteration: 1000 / 2000 [ 50%]  (Warmup)  Chain 1 Iteration: 1001 / 2000 [ 50%]  (Sampling)  Chain 1 Iteration: 1500 / 2000 [ 75%]  (Sampling)  Chain 1 Iteration: 2000 / 2000 [100%]  (Sampling)  Chain 2 Iteration:    1 / 2000 [  0%]  (Warmup)  Chain 2 Iteration:  500 / 2000 [ 25%]  (Warmup)  Chain 2 Iteration: 1000 / 2000 [ 50%]  (Warmup)  Chain 2 Iteration: 1001 / 2000 [ 50%]  (Sampling)  Chain 2 Iteration: 1500 / 2000 [ 75%]  (Sampling)  Chain 2 Iteration: 2000 / 2000 [100%]  (Sampling)  Chain 3 Iteration:    1 / 2000 [  0%]  (Warmup)  Chain 3 Iteration:  500 / 2000 [ 25%]  (Warmup)  Chain 3 Iteration: 1000 / 2000 [ 50%]  (Warmup)  Chain 3 Iteration: 1001 / 2000 [ 50%]  (Sampling)  Chain 3 Iteration: 1500 / 2000 [ 75%]  (Sampling)  Chain 3 Iteration: 2000 / 2000 [100%]  (Sampling)  Chain 4 Iteration:    1 / 2000 [  0%]  (Warmup)  Chain 4 Iteration:  500 / 2000 [ 25%]  (Warmup)  Chain 4 Iteration: 1000 / 2000 [ 50%]  (Warmup)  Chain 4 Iteration: 1001 / 2000 [ 50%]  (Sampling)  Chain 4 Iteration: 1500 / 2000 [ 75%]  (Sampling)  Chain 4 Iteration: 2000 / 2000 [100%]  (Sampling)  Chain 1 finished in 0.0 seconds. Chain 2 finished in 0.0 seconds. Chain 3 finished in 0.0 seconds. Chain 4 finished in 0.0 seconds.  All 4 chains finished successfully. Mean chain execution time: 0.0 seconds. Total execution time: 0.3 seconds."},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr.html","id":"summaries-from-the-posterior-package","dir":"Articles","previous_headings":"Running MCMC > Posterior summary statistics","what":"Summaries from the posterior package","title":"Getting started with CmdStanR","text":"$summary() method calls summarise_draws() posterior package. first argument specifies variables summarize arguments passed posterior::summarise_draws() specify summaries compute, whether use multiple cores, etc.","code":"fit$summary() fit$summary(variables = c(\"theta\", \"lp__\"), \"mean\", \"sd\")  # use a formula to summarize arbitrary functions, e.g. Pr(theta <= 0.5) fit$summary(\"theta\", pr_lt_half = ~ mean(. <= 0.5))  # summarise all variables with default and additional summary measures fit$summary(   variables = NULL,   posterior::default_summary_measures(),   extra_quantiles = ~posterior::quantile2(., probs = c(.0275, .975)) ) variable  mean median   sd  mad     q5   q95 rhat ess_bulk ess_tail 1     lp__ -7.30  -7.01 0.81 0.35 -8.821 -6.75    1     1834     2187 2    theta  0.26   0.24 0.12 0.13  0.079  0.49    1     1165     1581 variable  mean   sd 1    theta  0.26 0.12 2     lp__ -7.30 0.81 variable pr_lt_half 1    theta       0.96 variable  mean median   sd  mad     q5   q95  q2.75 q97.5 1     lp__ -7.30  -7.01 0.81 0.35 -8.821 -6.75 -9.333 -6.75 2    theta  0.26   0.24 0.12 0.13  0.079  0.49  0.065  0.53"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr.html","id":"cmdstans-stansummary-utility","dir":"Articles","previous_headings":"Running MCMC > Posterior summary statistics","what":"CmdStan’s stansummary utility","title":"Getting started with CmdStanR","text":"CmdStan provides stansummary utility can called using $cmdstan_summary() method. method print summaries won’t return anything.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr.html","id":"extracting-draws","dir":"Articles","previous_headings":"Running MCMC > Posterior draws","what":"Extracting draws","title":"Getting started with CmdStanR","text":"$draws() method can used extract posterior draws formats provided posterior package. demonstrate draws_array draws_df formats, posterior package supports useful formats well. convert existing draws object different format use posterior::as_draws_*() functions. general, converting different draws format way slower just setting appropriate format initially call $draws() method, cases speed difference minor. vignette Working Posteriors details posterior draws, including reproduce structured output RStan users accustomed getting rstan::extract().","code":"# default is a 3-D draws_array object from the posterior package # iterations x chains x variables draws_arr <- fit$draws() # or format=\"array\" str(draws_arr) 'draws_array' num [1:1000, 1:4, 1:2] -7.01 -7.89 -7.41 -6.75 -6.91 ...  - attr(*, \"dimnames\")=List of 3   ..$ iteration: chr [1:1000] \"1\" \"2\" \"3\" \"4\" ...   ..$ chain    : chr [1:4] \"1\" \"2\" \"3\" \"4\"   ..$ variable : chr [1:2] \"lp__\" \"theta\" # draws x variables data frame draws_df <- fit$draws(format = \"df\") str(draws_df) draws_df [4,000 × 5] (S3: draws_df/draws/tbl_df/tbl/data.frame)  $ lp__      : num [1:4000] -7.01 -7.89 -7.41 -6.75 -6.91 ...  $ theta     : num [1:4000] 0.168 0.461 0.409 0.249 0.185 ...  $ .chain    : int [1:4000] 1 1 1 1 1 1 1 1 1 1 ...  $ .iteration: int [1:4000] 1 2 3 4 5 6 7 8 9 10 ...  $ .draw     : int [1:4000] 1 2 3 4 5 6 7 8 9 10 ... print(draws_df) # A draws_df: 1000 iterations, 4 chains, and 2 variables    lp__ theta 1  -7.0  0.17 2  -7.9  0.46 3  -7.4  0.41 4  -6.7  0.25 5  -6.9  0.18 6  -6.9  0.33 7  -7.2  0.15 8  -6.8  0.29 9  -6.8  0.24 10 -6.8  0.24 # ... with 3990 more draws # ... hidden reserved variables {'.chain', '.iteration', '.draw'} # this should be identical to draws_df created via draws(format = \"df\") draws_df_2 <- as_draws_df(draws_arr) identical(draws_df, draws_df_2) [1] TRUE"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr.html","id":"plotting-draws","dir":"Articles","previous_headings":"Running MCMC > Posterior draws","what":"Plotting draws","title":"Getting started with CmdStanR","text":"Plotting posterior distributions easy passing object returned $draws() method directly plotting functions bayesplot package.","code":"mcmc_hist(fit$draws(\"theta\"))"},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr.html","id":"extracting-diagnostic-values-for-each-iteration-and-chain","dir":"Articles","previous_headings":"Running MCMC > Sampler diagnostics","what":"Extracting diagnostic values for each iteration and chain","title":"Getting started with CmdStanR","text":"$sampler_diagnostics() method extracts values sampler parameters (treedepth__, divergent__, etc.) formats supported posterior package. default 3-D array (iteration x chain x variable).","code":"# this is a draws_array object from the posterior package str(fit$sampler_diagnostics()) 'draws_array' num [1:1000, 1:4, 1:6] 2 1 2 2 2 1 2 1 2 1 ...  - attr(*, \"dimnames\")=List of 3   ..$ iteration: chr [1:1000] \"1\" \"2\" \"3\" \"4\" ...   ..$ chain    : chr [1:4] \"1\" \"2\" \"3\" \"4\"   ..$ variable : chr [1:6] \"treedepth__\" \"divergent__\" \"energy__\" \"accept_stat__\" ... # this is a draws_df object from the posterior package str(fit$sampler_diagnostics(format = \"df\")) draws_df [4,000 × 9] (S3: draws_df/draws/tbl_df/tbl/data.frame)  $ treedepth__  : num [1:4000] 2 1 2 2 2 1 2 1 2 1 ...  $ divergent__  : num [1:4000] 0 0 0 0 0 0 0 0 0 0 ...  $ energy__     : num [1:4000] 8.95 8.77 7.87 7.64 6.93 ...  $ accept_stat__: num [1:4000] 0.688 0.811 1 0.966 0.976 ...  $ stepsize__   : num [1:4000] 0.905 0.905 0.905 0.905 0.905 ...  $ n_leapfrog__ : num [1:4000] 3 3 3 3 3 3 3 3 3 3 ...  $ .chain       : int [1:4000] 1 1 1 1 1 1 1 1 1 1 ...  $ .iteration   : int [1:4000] 1 2 3 4 5 6 7 8 9 10 ...  $ .draw        : int [1:4000] 1 2 3 4 5 6 7 8 9 10 ..."},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr.html","id":"sampler-diagnostic-warnings-and-summaries","dir":"Articles","previous_headings":"Running MCMC > Sampler diagnostics","what":"Sampler diagnostic warnings and summaries","title":"Getting started with CmdStanR","text":"$diagnostic_summary() method display sampler diagnostic warnings return summary diagnostics chain. see number divergences four chains, number times maximum treedepth hit chain, E-BFMI chain. case warnings, order demonstrate warning messages ’ll use one CmdStanR example models suffers divergences. fitting warning divergences. can also regenerate warning message later using fit$diagnostic_summary().","code":"fit$diagnostic_summary() $num_divergent [1] 0 0 0 0  $num_max_treedepth [1] 0 0 0 0  $ebfmi [1] 1.1 1.0 1.1 1.1 fit_with_warning <- cmdstanr_example(\"schools\") Warning: 187 of 4000 (5.0%) transitions ended with a divergence. See https://mc-stan.org/misc/warnings for details. Warning: 1 of 4 chains had an E-BFMI less than 0.3. See https://mc-stan.org/misc/warnings for details. diagnostics <- fit_with_warning$diagnostic_summary() Warning: 187 of 4000 (5.0%) transitions ended with a divergence. See https://mc-stan.org/misc/warnings for details. Warning: 1 of 4 chains had an E-BFMI less than 0.3. See https://mc-stan.org/misc/warnings for details. print(diagnostics) $num_divergent [1] 60 10 48 69  $num_max_treedepth [1] 0 0 0 0  $ebfmi [1] 0.33 0.37 0.33 0.26 # number of divergences reported in warning is the sum of the per chain values sum(diagnostics$num_divergent) [1] 187"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr.html","id":"cmdstans-diagnose-utility","dir":"Articles","previous_headings":"Running MCMC > Sampler diagnostics","what":"CmdStan’s diagnose utility","title":"Getting started with CmdStanR","text":"CmdStan provides diagnose utility can called using $cmdstan_diagnose() method. method print warnings won’t return anything.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr.html","id":"running-optimization-and-variational-inference","dir":"Articles","previous_headings":"","what":"Running optimization and variational inference","title":"Getting started with CmdStanR","text":"CmdStanR also supports running Stan’s optimization algorithms algorithms variational approximation full Bayesian inference. run via $optimize(), $laplace(), $variational(), $pathfinder() methods, called similar way $sample() method demonstrated .","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr.html","id":"optimization","dir":"Articles","previous_headings":"Running optimization and variational inference","what":"Optimization","title":"Getting started with CmdStanR","text":"can find (penalized) maximum likelihood estimate (MLE) using $optimize(). ’s plot comparing penalized MLE posterior distribution theta.  optimization, default mode calculated without Jacobian adjustment constrained variables, shifts mode due change variables. include Jacobian adjustment obtain maximum posteriori (MAP) estimate set jacobian=TRUE. See Maximum Likelihood Estimation section CmdStan User’s Guide details.","code":"fit_mle <- mod$optimize(data = data_list, seed = 123) Initial log joint probability = -16.144      Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes          6      -5.00402   0.000246518   8.73164e-07           1           1        9     Optimization terminated normally:     Convergence detected: relative gradient magnitude is below tolerance  Finished in  0.1 seconds. fit_mle$print() # includes lp__ (log prob calculated by Stan program) variable estimate     lp__     -5.00     theta     0.20 fit_mle$mle(\"theta\") theta    0.2 mcmc_hist(fit$draws(\"theta\")) +   vline_at(fit_mle$mle(\"theta\"), size = 1.5) Warning:  [1m [22mUsing `size` aesthetic for lines was deprecated in ggplot2 3.4.0.  [36mℹ [39m Please use `linewidth` instead.  [36mℹ [39m The deprecated feature was likely used in the  [34mbayesplot [39m package.   Please report the issue at  [3m [34m<https://github.com/stan-dev/bayesplot/issues/> [39m [23m.  [90mThis warning is displayed once every 8 hours. [39m  [90mCall `lifecycle::last_lifecycle_warnings()` to see where this warning was [39m  [90mgenerated. [39m fit_map <- mod$optimize(   data = data_list,   jacobian = TRUE,   seed = 123 ) Initial log joint probability = -18.2733      Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes          5      -6.74802   0.000708195   1.43227e-05           1           1        8     Optimization terminated normally:     Convergence detected: relative gradient magnitude is below tolerance  Finished in  0.1 seconds."},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr.html","id":"laplace-approximation","dir":"Articles","previous_headings":"Running optimization and variational inference","what":"Laplace Approximation","title":"Getting started with CmdStanR","text":"$laplace() method produces sample normal approximation centered mode distribution unconstrained space. mode MAP estimate, samples provide estimate mean standard deviation posterior distribution. mode MLE, sample provides estimate standard error likelihood. Whether mode MAP MLE depends value jacobian argument running optimization. See Laplace Sampling chapter CmdStan User’s Guide details. pass fit_map object mode argument. mode omitted optimization run internally taking draws normal approximation.","code":"fit_laplace <- mod$laplace(     mode = fit_map,     draws = 4000,     data = data_list,     seed = 123,     refresh = 1000   ) Calculating Hessian  Calculating inverse of Cholesky factor  Generating draws  iteration: 0  iteration: 1000  iteration: 2000  iteration: 3000  Finished in  0.1 seconds. fit_laplace$print(\"theta\") variable mean median   sd  mad   q5  q95     theta 0.27   0.25 0.12 0.12 0.10 0.51 mcmc_hist(fit_laplace$draws(\"theta\"), binwidth = 0.025)"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr.html","id":"variational-advi","dir":"Articles","previous_headings":"Running optimization and variational inference","what":"Variational (ADVI)","title":"Getting started with CmdStanR","text":"can run Stan’s experimental Automatic Differentiation Variational Inference (ADVI) using $variational() method. details ADVI algorithm see CmdStan User’s Guide.","code":"fit_vb <- mod$variational(   data = data_list,   seed = 123,   draws = 4000 ) ------------------------------------------------------------  EXPERIMENTAL ALGORITHM:    This procedure has not been thoroughly tested and may be unstable    or buggy. The interface is subject to change.  ------------------------------------------------------------  Gradient evaluation took 2e-06 seconds  1000 transitions using 10 leapfrog steps per transition would take 0.02 seconds.  Adjust your expectations accordingly!  Begin eta adaptation.  Iteration:   1 / 250 [  0%]  (Adaptation)  Iteration:  50 / 250 [ 20%]  (Adaptation)  Iteration: 100 / 250 [ 40%]  (Adaptation)  Iteration: 150 / 250 [ 60%]  (Adaptation)  Iteration: 200 / 250 [ 80%]  (Adaptation)  Success! Found best value [eta = 1] earlier than expected.  Begin stochastic gradient ascent.    iter             ELBO   delta_ELBO_mean   delta_ELBO_med   notes      100           -6.164             1.000            1.000     200           -6.225             0.505            1.000     300           -6.186             0.339            0.010   MEDIAN ELBO CONVERGED  Drawing a sample of size 4000 from the approximate posterior...   COMPLETED.  Finished in  0.1 seconds. fit_vb$print(\"theta\") variable mean median   sd  mad   q5  q95     theta 0.26   0.24 0.11 0.11 0.11 0.46 mcmc_hist(fit_vb$draws(\"theta\"), binwidth = 0.025)"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr.html","id":"variational-pathfinder","dir":"Articles","previous_headings":"Running optimization and variational inference","what":"Variational (Pathfinder)","title":"Getting started with CmdStanR","text":"Stan version 2.33 introduced new variational method called Pathfinder, intended faster stable ADVI. details Pathfinder works see section CmdStan User’s Guide. Pathfinder run using $pathfinder() method. Let’s extract draws, make plot made running algorithms, compare . approximation, compare . simple example distributions quite similar, always case challenging problems.     details $optimize(), $laplace(), $variational(), pathfinder() methods, follow links documentation pages. $optimize() $laplace() $variational() $pathfinder()","code":"fit_pf <- mod$pathfinder(   data = data_list,   seed = 123,   draws = 4000 ) Path [1] :Initial log joint density = -18.273334  Path [1] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes                 5      -6.748e+00      7.082e-04   1.432e-05    1.000e+00  1.000e+00       156 -6.216e+00 -6.145e+00                    Path [1] :Best Iter: [5] ELBO (-6.145070) evaluations: (156)  Path [2] :Initial log joint density = -19.192715  Path [2] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes                 5      -6.748e+00      2.015e-04   2.228e-06    1.000e+00  1.000e+00       156 -6.170e+00 -6.223e+00                    Path [2] :Best Iter: [2] ELBO (-6.170358) evaluations: (156)  Path [3] :Initial log joint density = -6.774820  Path [3] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes                 4      -6.748e+00      1.137e-04   2.596e-07    1.000e+00  1.000e+00       123 -6.243e+00 -6.178e+00                    Path [3] :Best Iter: [4] ELBO (-6.177909) evaluations: (123)  Path [4] :Initial log joint density = -7.949193  Path [4] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes                 5      -6.748e+00      2.145e-04   1.301e-06    1.000e+00  1.000e+00       156 -6.235e+00 -6.197e+00                    Path [4] :Best Iter: [5] ELBO (-6.197118) evaluations: (156)  Finished in  0.1 seconds. fit_pf$print(\"theta\") variable mean median   sd  mad   q5  q95     theta 0.25   0.24 0.12 0.12 0.08 0.47 mcmc_hist(fit_pf$draws(\"theta\"), binwidth = 0.025) +   ggplot2::labs(subtitle = \"Approximate posterior from pathfinder\") +   ggplot2::xlim(0, 1) mcmc_hist(fit_vb$draws(\"theta\"), binwidth = 0.025) +   ggplot2::labs(subtitle = \"Approximate posterior from variational\") +   ggplot2::xlim(0, 1) mcmc_hist(fit_laplace$draws(\"theta\"), binwidth = 0.025) +   ggplot2::labs(subtitle = \"Approximate posterior from Laplace\") +   ggplot2::xlim(0, 1) mcmc_hist(fit$draws(\"theta\"), binwidth = 0.025) +   ggplot2::labs(subtitle = \"Posterior from MCMC\") +   ggplot2::xlim(0, 1)"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr.html","id":"saving-fitted-model-objects","dir":"Articles","previous_headings":"","what":"Saving fitted model objects","title":"Getting started with CmdStanR","text":"$save_object() method provided CmdStanR convenient way save fitted model object disk ensure contents available reading object back R. model object large, $save_object() take long time. $save_object() reads CmdStan results files memory, stores model object, saves object saveRDS(). speed process, can emulate $save_object() replace saveRDS much faster qsave() function qs package. Storage even faster discard results need save. following example saves posterior draws discards sampler diagnostics, user-specified initial values, profiling data. See vignette CmdStanR work? information composition CmdStanR objects.","code":"fit$save_object(file = \"fit.RDS\")  # can be read back in using readRDS fit2 <- readRDS(\"fit.RDS\") # Load CmdStan output files into the fitted model object. fit$draws() # Load posterior draws into the object. try(fit$sampler_diagnostics(), silent = TRUE) # Load sampler diagnostics. try(fit$init(), silent = TRUE) # Load user-defined initial values. try(fit$profiles(), silent = TRUE) # Load profiling samples.  # Save the object to a file. qs::qsave(x = fit, file = \"fit.qs\")  # Read the object. fit2 <- qs::qread(\"fit.qs\") # Load posterior draws into the fitted model object and omit other output. fit$draws()  # Save the object to a file. qs::qsave(x = fit, file = \"fit.qs\")  # Read the object. fit2 <- qs::qread(\"fit.qs\")"},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr.html","id":"different-ways-of-interfacing-with-stans-c","dir":"Articles","previous_headings":"Comparison with RStan","what":"Different ways of interfacing with Stan’s C++","title":"Getting started with CmdStanR","text":"RStan interface (rstan package) -memory interface Stan relies R packages like Rcpp inline call C++ code R. hand, CmdStanR interface directly call C++ code R, instead relying CmdStan interface behind scenes compilation, running algorithms, writing results output files.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr.html","id":"advantages-of-rstan","dir":"Articles","previous_headings":"Comparison with RStan","what":"Advantages of RStan","title":"Getting started with CmdStanR","text":"Allows developers distribute R packages pre-compiled Stan programs (like rstanarm) CRAN. (Note: 2023, can mostly achieved CmdStanR well. See Developing using CmdStanR.) Avoids use R6 classes, may result familiar syntax many R users. CRAN binaries available Mac Windows.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr.html","id":"advantages-of-cmdstanr","dir":"Articles","previous_headings":"Comparison with RStan","what":"Advantages of CmdStanR","title":"Getting started with CmdStanR","text":"Compatible latest versions Stan. Keeping Stan releases complicated RStan, often requiring non-trivial changes rstan package new CRAN releases rstan StanHeaders. CmdStanR latest improvements Stan available R immediately updating CmdStan using cmdstanr::install_cmdstan(). Running Stan via external processes results fewer unexpected crashes, especially RStudio. Less memory overhead. permissive license. RStan uses GPL-3 license license CmdStanR BSD-3, bit permissive license used CmdStan Stan C++ source code.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/articles/cmdstanr.html","id":"additional-resources","dir":"Articles","previous_headings":"","what":"Additional resources","title":"Getting started with CmdStanR","text":"additional vignettes available discuss aspects using CmdStanR. can found online CmdStanR website: https://mc-stan.org/cmdstanr/articles/index.html ask question please post Stan forums: https://discourse.mc-stan.org/ report bug, suggest feature (including additions vignettes), start contributing CmdStanR development (new contributors welcome!) please open issue GitHub: https://github.com/stan-dev/cmdstanr/issues","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/articles/posterior.html","id":"summary-statistics","dir":"Articles","previous_headings":"","what":"Summary statistics","title":"Working with Posteriors","text":"can easily customize summary statistics reported $summary() $print(). default variables summaries follow functions: change variables summarized, use variables argument can additionally change functions used summarize variables non-default functions, necessary set explicitly set variables argument, either NULL full vector variable names. Summary functions can specified character string, function, using formula (anything else supported rlang::as_function()). arguments named, names used tibble output. summary results named take precedence. Arguments summary functions can also specified .args. summary functions applied array sample values, dimension iter_samplingxchains. reason users may unexpected results use stats::var() directly, return covariance matrix. alternative distributional::variance() function, can also accessed via posterior::variance(). Summary functions need numeric, won’t work $print(). information, see posterior::summarise_draws(), called $summary().","code":"fit <- cmdstanr::cmdstanr_example(\"schools\", method = \"sample\") Warning: 90 of 4000 (2.0%) transitions ended with a divergence. See https://mc-stan.org/misc/warnings for details. fit$summary() variable       mean     median       sd      mad          q5       q95 1      lp__ -58.320756 -58.622925 4.918566 5.131560 -66.0873865 -49.96255 2        mu   6.765315   6.853504 4.477501 4.441462  -0.5815009  13.94432 3       tau   5.329521   4.561805 3.392980 3.206039   1.2538663  11.88650 4  theta[1]   9.614873   9.056704 7.011170 6.517894  -0.9236177  21.53582 5  theta[2]   7.011599   7.109942 5.882246 5.815888  -2.8740180  16.35239 6  theta[3]   5.762381   6.062503 6.908729 6.531089  -6.0668909  16.06493 7  theta[4]   6.658352   6.724928 5.967391 5.795691  -3.1409733  16.19117 8  theta[5]   4.856853   5.073774 6.104925 5.838099  -5.6258228  14.22750 9  theta[6]   5.766387   6.078693 6.138783 5.934561  -4.5991732  15.27158 10 theta[7]   9.343667   9.036606 6.217535 5.913166  -0.2544706  19.78362 11 theta[8]   7.177659   7.188460 6.679874 6.127754  -3.7721206  17.68597        rhat  ess_bulk  ess_tail 1  1.016399  359.7406  315.6200 2  1.004802  537.1418  889.3897 3  1.016214  358.8192  282.9631 4  1.003541 1065.6346 1806.9754 5  1.002917  833.6323 1890.8652 6  1.003206  876.9884 1844.4931 7  1.002243  888.6417 2203.8935 8  1.003200  695.3974 1277.5894 9  1.002718  825.3426 1678.0983 10 1.004303 1019.5252 2068.0670 11 1.004031  950.0452 1717.5853 posterior::default_summary_measures() [1] \"mean\"      \"median\"    \"sd\"        \"mad\"       \"quantile2\" fit$summary(variables = c(\"mu\", \"tau\")) variable     mean   median       sd      mad         q5      q95     rhat 1       mu 6.765315 6.853504 4.477501 4.441462 -0.5815009 13.94432 1.004802 2      tau 5.329521 4.561805 3.392980 3.206039  1.2538663 11.88650 1.016214   ess_bulk ess_tail 1 537.1418 889.3897 2 358.8192 282.9631 fit$summary(variables = c(\"mu\", \"tau\"), mean, sd) variable     mean       sd 1       mu 6.765315 4.477501 2      tau 5.329521 3.392980 fit$metadata()$model_params [1] \"lp__\"     \"mu\"       \"tau\"      \"theta[1]\" \"theta[2]\" \"theta[3]\"  [7] \"theta[4]\" \"theta[5]\" \"theta[6]\" \"theta[7]\" \"theta[8]\" fit$summary(variables = NULL, \"mean\", \"median\") variable       mean     median 1      lp__ -58.320756 -58.622925 2        mu   6.765315   6.853504 3       tau   5.329521   4.561805 4  theta[1]   9.614873   9.056704 5  theta[2]   7.011599   7.109942 6  theta[3]   5.762381   6.062503 7  theta[4]   6.658352   6.724928 8  theta[5]   4.856853   5.073774 9  theta[6]   5.766387   6.078693 10 theta[7]   9.343667   9.036606 11 theta[8]   7.177659   7.188460 my_sd <- function(x) c(My_SD = sd(x)) fit$summary(   c(\"mu\", \"tau\"),    MEAN = mean,    \"median\",   my_sd,   ~quantile(.x, probs = c(0.1, 0.9)),   Minimum = function(x) min(x) ) variable     MEAN   median    My_SD      10%       90%     Minimum 1       mu 6.765315 6.853504 4.477501 0.887486 12.502440 -10.8368510 2      tau 5.329521 4.561805 3.392980 1.608897  9.942976   0.7203539 fit$summary(c(\"mu\", \"tau\"), quantile, .args = list(probs = c(0.025, .05, .95, .975))) variable      2.5%         5%      95%    97.5% 1       mu -2.039372 -0.5815009 13.94432 15.33313 2      tau  1.093560  1.2538663 11.88650 13.82409 fit$summary(variables = NULL, dim, colMeans) variable dim.1 dim.2          1          2          3          4 1      lp__  1000     4 -57.940185 -57.459900 -58.267713 -59.615226 2        mu  1000     4   7.116265   6.765985   7.052251   6.126758 3       tau  1000     4   5.159391   4.798012   5.249758   6.110924 4  theta[1]  1000     4   9.965227   9.050620   9.975194   9.468451 5  theta[2]  1000     4   7.498667   6.885330   7.271205   6.391194 6  theta[3]  1000     4   6.219639   6.012905   6.002472   4.814506 7  theta[4]  1000     4   7.177726   6.617560   6.775441   6.062680 8  theta[5]  1000     4   5.009475   5.175509   5.170864   4.071566 9  theta[6]  1000     4   6.211830   5.758704   6.051311   5.043702 10 theta[7]  1000     4   9.483258   8.951447   9.533311   9.406654 11 theta[8]  1000     4   7.650810   7.091832   7.564064   6.403932 fit$summary(c(\"mu\", \"tau\"), posterior::variance, ~var(as.vector(.x))) variable posterior::variance ~var(as.vector(.x)) 1       mu            20.04802            20.04802 2      tau            11.51232            11.51232 strict_pos <- function(x) if (all(x > 0)) \"yes\" else \"no\" fit$summary(variables = NULL, \"Strictly Positive\" = strict_pos) variable Strictly Positive 1      lp__                no 2        mu                no 3       tau               yes 4  theta[1]                no 5  theta[2]                no 6  theta[3]                no 7  theta[4]                no 8  theta[5]                no 9  theta[6]                no 10 theta[7]                no 11 theta[8]                no # fit$print(variables = NULL, \"Strictly Positive\" = strict_pos)"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/posterior.html","id":"extracting-posterior-drawssamples","dir":"Articles","previous_headings":"","what":"Extracting posterior draws/samples","title":"Working with Posteriors","text":"$draws() method can used extract posterior draws formats provided posterior package. demonstrate draws_array draws_df formats, posterior package supports useful formats well. convert existing draws object different format use posterior::as_draws_*() functions. manipulate draws objects use various methods described posterior package vignettes documentation.","code":"# default is a 3-D draws_array object from the posterior package # iterations x chains x variables draws_arr <- fit$draws() # or format=\"array\" str(draws_arr) 'draws_array' num [1:1000, 1:4, 1:11] -62.1 -61.3 -65.7 -62.3 -61.9 ...  - attr(*, \"dimnames\")=List of 3   ..$ iteration: chr [1:1000] \"1\" \"2\" \"3\" \"4\" ...   ..$ chain    : chr [1:4] \"1\" \"2\" \"3\" \"4\"   ..$ variable : chr [1:11] \"lp__\" \"mu\" \"tau\" \"theta[1]\" ... # draws x variables data frame draws_df <- fit$draws(format = \"df\") str(draws_df) draws_df [4,000 × 14] (S3: draws_df/draws/tbl_df/tbl/data.frame)  $ lp__      : num [1:4000] -62.1 -61.3 -65.7 -62.3 -61.9 ...  $ mu        : num [1:4000] 9.45 8.3 7.18 14.58 8.05 ...  $ tau       : num [1:4000] 2.89 7.73 7.83 9.74 4.56 ...  $ theta[1]  : num [1:4000] 4.47 4.66 28.35 18.82 4.38 ...  $ theta[2]  : num [1:4000] 8.24 10.1 10.44 14.88 3.87 ...  $ theta[3]  : num [1:4000] 1.6 3.47 16.71 16.04 2 ...  $ theta[4]  : num [1:4000] 16.56 13.11 4.21 2.07 16.29 ...  $ theta[5]  : num [1:4000] 8.61 9.57 4.53 2.41 13.09 ...  $ theta[6]  : num [1:4000] 14.08 18.04 -4.96 7.73 9.37 ...  $ theta[7]  : num [1:4000] 8.79 11.78 18.94 18.14 4.92 ...  $ theta[8]  : num [1:4000] 10.713 4.423 20.456 18.698 0.802 ...  $ .chain    : int [1:4000] 1 1 1 1 1 1 1 1 1 1 ...  $ .iteration: int [1:4000] 1 2 3 4 5 6 7 8 9 10 ...  $ .draw     : int [1:4000] 1 2 3 4 5 6 7 8 9 10 ... print(draws_df) # A draws_df: 1000 iterations, 4 chains, and 11 variables    lp__   mu  tau theta[1] theta[2] theta[3] theta[4] theta[5] 1   -62  9.4  2.9      4.5     8.24      1.6    16.56      8.6 2   -61  8.3  7.7      4.7    10.10      3.5    13.11      9.6 3   -66  7.2  7.8     28.4    10.44     16.7     4.21      4.5 4   -62 14.6  9.7     18.8    14.88     16.0     2.07      2.4 5   -62  8.0  4.6      4.4     3.87      2.0    16.29     13.1 6   -59  5.8  5.3     12.5     0.31     10.4    12.50      8.3 7   -63 10.9  4.7      4.2     3.85     15.1     1.61      5.2 8   -65  8.6  7.0     17.0    15.23     10.6    -4.47     -3.2 9   -64 11.7 11.6     17.7    15.32      5.4    21.99     -4.1 10  -66 16.9  9.5     27.9    15.86     15.0     0.05     18.3 # ... with 3990 more draws, and 3 more variables # ... hidden reserved variables {'.chain', '.iteration', '.draw'}"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/posterior.html","id":"structured-draws-similar-to-rstanextract","dir":"Articles","previous_headings":"Extracting posterior draws/samples","what":"Structured draws similar to rstan::extract()","title":"Working with Posteriors","text":"posterior package’s rvar format provides multidimensional, sample-based representation random variables. See https://mc-stan.org/posterior/articles/rvar.html details. addition useful right, format also allows CmdStanR users obtain draws similar format rstan::extract(). Suppose parameter matrix[2,3] x. rvar format lets interact x ’s 2 x 3 matrix automatically applies operations many posterior draws x. instead directly access draws x maintaining structure matrix use posterior::draws_of(). example: object x_rvar rvar can used like 2 x 3 matrix, draws handled behind scenes. object x_array 4000 x 2 x 3 array (assuming 4000 posterior draws), extracted list returned rstan::extract().","code":"draws <- posterior::as_draws_rvars(fit$draws()) x_rvar <- draws$x x_array <- posterior::draws_of(draws$x)"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/profiling.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Profiling Stan programs with CmdStanR","text":"vignette demonstrates use new profiling functionality introduced CmdStan 2.26.0. Profiling identifies parts Stan program taking longest time run therefore useful guide working optimizing performance model. However, aware statistical assumptions go model important factors overall model performance. often possible make model problems just brute force computation. ideas address performance model statistical perspective, see Gelman (2020).","code":"library(cmdstanr) check_cmdstan_toolchain(fix = TRUE, quiet = TRUE)"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/profiling.html","id":"adding-profiling-statements-to-a-stan-program","dir":"Articles","previous_headings":"","what":"Adding profiling statements to a Stan program","title":"Profiling Stan programs with CmdStanR","text":"Consider simple logistic regression parameters alpha beta, covariates X, outcome y. simple question much time prior calculations take compared likelihood? answer surround prior likelihood calculations profile statements. general recommend using separate .stan file, convenience vignette ’ll write Stan program string use write_stan_file() write temporary file. can run model usual Stan collect profiling information sections profile statements.","code":"data {   int<lower=1> k;   int<lower=0> n;   matrix[n, k] X;   array[n] int y; } parameters {   vector[k] beta;   real alpha; } model {   beta ~ std_normal();   alpha ~ std_normal();    y ~ bernoulli_logit(X * beta + alpha); } profile(\"priors\") {   target += std_normal_lpdf(beta);   target += std_normal_lpdf(alpha); } profile(\"likelihood\") {   target += bernoulli_logit_lpmf(y | X * beta + alpha); } profiling_bernoulli_logit <- write_stan_file(' data {   int<lower=1> k;   int<lower=0> n;   matrix[n, k] X;   array[n] int y; } parameters {   vector[k] beta;   real alpha; } model {   profile(\"priors\") {     target += std_normal_lpdf(beta);     target += std_normal_lpdf(alpha);   }   profile(\"likelihood\") {     target += bernoulli_logit_lpmf(y | X * beta + alpha);   } } ') # Compile the model model <- cmdstan_model(profiling_bernoulli_logit)  # Generate some fake data n <- 1000 k <- 20 X <- matrix(rnorm(n * k), ncol = k)  y <- 3 * X[,1] - 2 * X[,2] + 1 p <- runif(n) y <- ifelse(p < (1 / (1 + exp(-y))), 1, 0) stan_data <- list(k = ncol(X), n = nrow(X), y = y, X = X)  # Run one chain of the model fit <- model$sample(data = stan_data, chains = 1)"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/profiling.html","id":"accessing-the-profiling-information-from-r","dir":"Articles","previous_headings":"","what":"Accessing the profiling information from R","title":"Profiling Stan programs with CmdStanR","text":"raw profiling information can accessed $profiles() method, returns list containing one data frame per chain (profiles across multiple chains automatically aggregated). Details column names available CmdStan documentation. total_time column total time spent inside given profile statement. clear vast majority time spent likelihood function.","code":"fit$profiles() [[1]]         name       thread_id total_time forward_time reverse_time chain_stack 1 likelihood 140336085878592 0.64163101  0.505463460  0.136167550       52590 2     priors 140336085878592 0.00397622  0.003022821  0.000953399       35060   no_chain_stack autodiff_calls no_autodiff_calls 1       35077530          17530                 1 2          35060          17530                 1"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/profiling.html","id":"comparing-to-a-faster-version-of-the-model","dir":"Articles","previous_headings":"","what":"Comparing to a faster version of the model","title":"Profiling Stan programs with CmdStanR","text":"Stan’s specialized glm functions can used make models like faster. case likelihood can replaced ’ll keep profile() statements profiling information new model collected automatically just like previous one. can see total_time column much faster previous model.","code":"target += bernoulli_logit_glm_lpmf(y | X, alpha, beta); profiling_bernoulli_logit_glm <- write_stan_file(' data {   int<lower=1> k;   int<lower=0> n;   matrix[n, k] X;   array[n] int y; } parameters {   vector[k] beta;   real alpha; } model {   profile(\"priors\") {     target += std_normal_lpdf(beta);     target += std_normal_lpdf(alpha);   }   profile(\"likelihood\") {     target += bernoulli_logit_glm_lpmf(y | X, alpha, beta);   } } ') model_glm <- cmdstan_model(profiling_bernoulli_logit_glm) fit_glm <- model_glm$sample(data = stan_data, chains = 1) fit_glm$profiles() [[1]]         name       thread_id  total_time forward_time reverse_time chain_stack 1     priors 140050894243648 0.003928851  0.003003174  0.000925677       34246 2 likelihood 140050894243648 0.420223320  0.419244560  0.000978760       51369   no_chain_stack autodiff_calls no_autodiff_calls 1          34246          17123                 1 2          17123          17123                 1"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/profiling.html","id":"per-gradient-timings-and-memory-usage","dir":"Articles","previous_headings":"","what":"Per-gradient timings, and memory usage","title":"Profiling Stan programs with CmdStanR","text":"columns profiling output documented CmdStan documentation. timing numbers broken forward pass reverse pass, chain_stack no_chain_stack columns contain information many autodiff variables saved process performing calculation. numbers totals – times total times whole calculation, chain_stack counts similarly total counts autodiff variables used whole calculation. often convenient per-gradient calculations (stable across runs different seeds). compute , use autodiff_calls column.","code":"profile_chain_1 <- fit$profiles()[[1]] per_gradient_timing <- profile_chain_1$total_time/profile_chain_1$autodiff_calls print(per_gradient_timing) # two elements for the two profile statements in the model [1] 3.660188e-05 2.268237e-07"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/profiling.html","id":"accessing-and-saving-the-profile-files","dir":"Articles","previous_headings":"","what":"Accessing and saving the profile files","title":"Profiling Stan programs with CmdStanR","text":"sampling (optimization variational inference) finishes, CmdStan stores profiling data CSV files temporary location. paths profiling CSV files can retrieved using $profile_files(). can saved permanent location $save_profile_files() method.","code":"fit$profile_files() [1] \"/tmp/Rtmpe4VADw/model_6580008f67848265f3dfd0e7ae3b0600-profile-202512311806-1-806931.csv\" # see ?save_profile_files for info on optional arguments fit$save_profile_files(dir = \"path/to/directory\")"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/profiling.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Profiling Stan programs with CmdStanR","text":"Gelman, Andrew, Aki Vehtari, Daniel Simpson, Charles C. Margossian, Bob Carpenter, Yuling Yao, Lauren Kennedy, Jonah Gabry, Paul-Christian Bürkner, Martin Modrák. 2020. “Bayesian Workflow.” https://arxiv.org/abs/2011.01808.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/articles/r-markdown.html","id":"option-1-using-rstan-for-all-chunks","dir":"Articles","previous_headings":"","what":"Option 1: Using RStan for all chunks","title":"R Markdown CmdStan Engine","text":"default option. case can write, example:","code":"```{stan, output.var=\"model\"} // Stan model code ```  ```{r} rstan::sampling(model) ```"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/r-markdown.html","id":"option-2-using-cmdstanr-for-all-chunks","dir":"Articles","previous_headings":"","what":"Option 2: Using CmdStanR for all chunks","title":"R Markdown CmdStan Engine","text":"CmdStanR used replacement engine needs registered along following lines: overrides knitr’s built-stan engine stan chunks processed CmdStanR, RStan. course, also means variable specified output.var longer stanmodel object, instead CmdStanModel object, example code look like :","code":"library(cmdstanr) register_knitr_engine(override = TRUE) ```{stan, output.var=\"model\"} // Stan model code ```  ```{r} model$sample() ```"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/r-markdown.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"R Markdown CmdStan Engine","text":"","code":"// This stan chunk results in a CmdStanModel object called \"ex1\" parameters {   array[2] real y; } model {   y[1] ~ normal(0, 1);   y[2] ~ double_exponential(0, 2); } ex1$print() #> // This stan chunk results in a CmdStanModel object called \"ex1\" #> parameters { #>   array[2] real y; #> } #> model { #>   y[1] ~ normal(0, 1); #>   y[2] ~ double_exponential(0, 2); #> } fit <- ex1$sample(   refresh = 0,   seed = 42L ) #> Running MCMC with 4 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #> Chain 3 finished in 0.0 seconds. #> Chain 4 finished in 0.0 seconds. #>  #> All 4 chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.6 seconds.  print(fit) #>  variable  mean median   sd  mad    q5   q95 rhat ess_bulk ess_tail #>      lp__ -1.56  -1.23 1.26 1.04 -4.05 -0.16 1.00     1395     1598 #>      y[1]  0.03   0.03 1.04 1.04 -1.68  1.70 1.00     1803     1921 #>      y[2]  0.06   0.04 2.89 2.05 -4.71  5.10 1.00     2320     1304"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/r-markdown.html","id":"option-3-using-both-rstan-and-cmdstanr-in-the-same-r-markdown-document","dir":"Articles","previous_headings":"","what":"Option 3: Using both RStan and CmdStanR in the same R Markdown document","title":"R Markdown CmdStan Engine","text":"default behavior override built-stan engine assumption user probably using RStan CmdStanR document project, option use exists. registering CmdStanR’s knitr engine, set override = FALSE register engine cmdstan engine: cause stan chunks processed knitr’s built-, RStan-based engine use CmdStanR’s knitr engine cmdstan chunks:","code":"register_knitr_engine(override = FALSE) ```{stan, output.var=\"model_obj1\"} // Results in a stanmodel object from RStan ```  ```{r} rstan::sampling(model_obj1) ```  ```{cmdstan, output.var=\"model_obj2\"} // Results in a CmdStanModel object from CmdStanR ```  ```{r} model_obj2$sample() ```"},{"path":"https://mc-stan.org/cmdstanr/dev/articles/r-markdown.html","id":"caching-chunks","dir":"Articles","previous_headings":"","what":"Caching chunks","title":"R Markdown CmdStan Engine","text":"Use cache=TRUE chunk option avoid re-compiling Stan model code every time R Markdown knit/rendered. can find Stan model file compiled executable document’s cache directory.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/articles/r-markdown.html","id":"running-interactively","dir":"Articles","previous_headings":"","what":"Running interactively","title":"R Markdown CmdStan Engine","text":"running chunks interactively RStudio (e.g. using R Notebooks), observed built-, RStan-based engine used stan chunks even CmdStanR’s engine registered session engine stan. workaround, running chunks interactively, recommended use override = FALSE option change stan chunks cmdstan chunks. worry: template use supports syntax highlighting Stan language, syntax highlighting applied cmdstan chunks document knit/rendered.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jonah Gabry. Author. Rok Češnovar. Author. Andrew Johnson. Author, maintainer. Steve Bronder. Author. Ben Bales. Contributor. Mitzi Morris. Contributor. Mikhail Popov. Contributor. Mike Lawrence. Contributor. William Michael Landau. Contributor. Jacob Socolar. Contributor. Martin Modrák. Contributor. Ven Popov. Contributor.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Gabry J, Češnovar R, Johnson , Bronder S (2025). cmdstanr: R Interface 'CmdStan'. R package version 0.9.0.9000, https://mc-stan.org/cmdstanr/.","code":"@Manual{,   title = {cmdstanr: R Interface to 'CmdStan'},   author = {Jonah Gabry and Rok Češnovar and Andrew Johnson and Steve Bronder},   year = {2025},   note = {R package version 0.9.0.9000},   url = {https://mc-stan.org/cmdstanr/}, }"},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"R Interface to CmdStan","text":"CmdStanR lightweight interface Stan R users (see CmdStanPy Python). new CmdStanR recommend starting vignettes: Getting started CmdStanR CmdStanR work?","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/index.html","id":"goals","dir":"","previous_headings":"","what":"Goals","title":"R Interface to CmdStan","text":"clean interface Stan services CmdStanR can keep Stan releases. R code doesn’t interface directly C++, calls compiled executables. Modularity: CmdStanR runs Stan’s algorithms lets downstream modules analysis. Flexible BSD-3 license.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/index.html","id":"installing-the-r-package","dir":"","previous_headings":"Installation","what":"Installing the R package","title":"R Interface to CmdStan","text":"can install latest release cmdstanr R package install vignettes, take long time build, always available online https://mc-stan.org/cmdstanr/articles/. instead install latest development version package GitHub use","code":"# we recommend running this in a fresh R session or restarting your current session install.packages(\"cmdstanr\", repos = c('https://stan-dev.r-universe.dev', getOption(\"repos\"))) # install.packages(\"remotes\") remotes::install_github(\"stan-dev/cmdstanr\")"},{"path":"https://mc-stan.org/cmdstanr/dev/index.html","id":"installing-cmdstan","dir":"","previous_headings":"Installation","what":"Installing CmdStan","title":"R Interface to CmdStan","text":"don’t already CmdStan installed , addition installing R package, also necessary install CmdStan using CmdStanR’s install_cmdstan() function. suitable C++ toolchain also required. Instructions provided Getting started CmdStanR vignette.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"R Interface to CmdStan","text":"lot work still done, welcome contributions anyone! interested contributing, please comment open issue open new one GitHub. details, please check CONTRIBUTING.md. ### License CmdStanR, like CmdStan core Stan C++ code, licensed following licenses: Code: BSD 3-clause (https://opensource.org/license/bsd-3-clause/) Documentation: CC-4.0 (https://creativecommons.org/licenses//4.0/)","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/CmdStanDiagnose.html","id":null,"dir":"Reference","previous_headings":"","what":"CmdStanDiagnose objects — CmdStanDiagnose","title":"CmdStanDiagnose objects — CmdStanDiagnose","text":"CmdStanDiagnose object object returned $diagnose() method CmdStanModel object.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/CmdStanDiagnose.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"CmdStanDiagnose objects — CmdStanDiagnose","text":"CmdStanDiagnose objects following associated methods:","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/CmdStanDiagnose.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CmdStanDiagnose objects — CmdStanDiagnose","text":"","code":"# \\dontrun{ test <- cmdstanr_example(\"logistic\", method = \"diagnose\")  # retrieve the gradients test$gradients() #>   param_idx     value     model finite_diff        error #> 1         0  1.710110 -18.30620   -18.30620 -1.81553e-08 #> 2         1 -0.468770  -5.97695    -5.97695  1.10331e-08 #> 3         2 -1.800050  20.42290    20.42290  1.19712e-08 #> 4         3 -0.508314  16.91120    16.91120  3.84095e-10 # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/CmdStanGQ.html","id":null,"dir":"Reference","previous_headings":"","what":"CmdStanGQ objects — CmdStanGQ","title":"CmdStanGQ objects — CmdStanGQ","text":"CmdStanGQ object fitted model object returned $generate_quantities() method CmdStanModel object.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/CmdStanGQ.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"CmdStanGQ objects — CmdStanGQ","text":"CmdStanGQ objects following associated methods, (linked) documentation pages.","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/CmdStanGQ.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CmdStanGQ objects — CmdStanGQ","text":"","code":"# \\dontrun{ # first fit a model using MCMC mcmc_program <- write_stan_file(   \"data {     int<lower=0> N;     array[N] int<lower=0,upper=1> y;   }   parameters {     real<lower=0,upper=1> theta;   }   model {     y ~ bernoulli(theta);   }\" ) mod_mcmc <- cmdstan_model(mcmc_program)  data <- list(N = 10, y = c(1,1,0,0,0,1,0,1,0,0)) fit_mcmc <- mod_mcmc$sample(data = data, seed = 123, refresh = 0) #> Running MCMC with 4 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #> Chain 3 finished in 0.0 seconds. #> Chain 4 finished in 0.0 seconds. #>  #> All 4 chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.6 seconds. #>   # stan program for standalone generated quantities # (could keep model block, but not necessary so removing it) gq_program <- write_stan_file(   \"data {     int<lower=0> N;     array[N] int<lower=0,upper=1> y;   }   parameters {     real<lower=0,upper=1> theta;   }   generated quantities {     array[N] int y_rep = bernoulli_rng(rep_vector(theta, N));   }\" )  mod_gq <- cmdstan_model(gq_program) fit_gq <- mod_gq$generate_quantities(fit_mcmc, data = data, seed = 123) #> Running standalone generated quantities after 4 MCMC chains, 1 chain at a time ... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #> Chain 3 finished in 0.0 seconds. #> Chain 4 finished in 0.0 seconds. #>  #> All 4 chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.5 seconds. str(fit_gq$draws()) #>  'draws_array' int [1:1000, 1:4, 1:10] 0 0 0 1 1 0 1 1 0 1 ... #>  - attr(*, \"dimnames\")=List of 3 #>   ..$ iteration: chr [1:1000] \"1\" \"2\" \"3\" \"4\" ... #>   ..$ chain    : chr [1:4] \"1\" \"2\" \"3\" \"4\" #>   ..$ variable : chr [1:10] \"y_rep[1]\" \"y_rep[2]\" \"y_rep[3]\" \"y_rep[4]\" ...  library(posterior) #> This is posterior version 1.6.1 #>  #> Attaching package: ‘posterior’ #> The following objects are masked from ‘package:stats’: #>  #>     mad, sd, var #> The following objects are masked from ‘package:base’: #>  #>     %in%, match as_draws_df(fit_gq$draws()) #> # A draws_df: 1000 iterations, 4 chains, and 10 variables #>    y_rep[1] y_rep[2] y_rep[3] y_rep[4] y_rep[5] y_rep[6] y_rep[7] y_rep[8] #> 1         0        0        0        0        0        1        1        1 #> 2         0        0        0        0        1        1        0        0 #> 3         0        0        0        1        0        0        1        1 #> 4         1        1        0        0        0        0        1        0 #> 5         1        0        1        0        1        0        1        0 #> 6         0        0        0        1        1        0        0        0 #> 7         1        1        0        1        1        1        0        0 #> 8         1        1        1        1        1        0        1        1 #> 9         0        1        0        1        0        1        1        0 #> 10        1        1        1        1        1        1        1        1 #> # ... with 3990 more draws, and 2 more variables #> # ... hidden reserved variables {'.chain', '.iteration', '.draw'} # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/CmdStanLaplace.html","id":null,"dir":"Reference","previous_headings":"","what":"CmdStanLaplace objects — CmdStanLaplace","title":"CmdStanLaplace objects — CmdStanLaplace","text":"CmdStanLaplace object fitted model object returned $laplace() method CmdStanModel object.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/CmdStanLaplace.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"CmdStanLaplace objects — CmdStanLaplace","text":"CmdStanLaplace objects following associated methods, (linked) documentation pages.","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/CmdStanMCMC.html","id":null,"dir":"Reference","previous_headings":"","what":"CmdStanMCMC objects — CmdStanMCMC","title":"CmdStanMCMC objects — CmdStanMCMC","text":"CmdStanMCMC object fitted model object returned $sample() method CmdStanModel object. Like CmdStanModel objects, CmdStanMCMC objects R6 objects.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/CmdStanMCMC.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"CmdStanMCMC objects — CmdStanMCMC","text":"CmdStanMCMC objects following associated methods, (linked) documentation pages.","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/CmdStanMLE.html","id":null,"dir":"Reference","previous_headings":"","what":"CmdStanMLE objects — CmdStanMLE","title":"CmdStanMLE objects — CmdStanMLE","text":"CmdStanMLE object fitted model object returned $optimize() method CmdStanModel object. name \"MLE\" (used historical reasons) bit misleading since object contain parameter estimates corresponding either mode constrained parameter space unconstrained parameter space, depending value jacobian argument model fit (whether model constrained parameters). See $optimize() CmdStan User's Guide details.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/CmdStanMLE.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"CmdStanMLE objects — CmdStanMLE","text":"CmdStanMLE objects following associated methods, (linked) documentation pages.","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/CmdStanModel.html","id":null,"dir":"Reference","previous_headings":"","what":"CmdStanModel objects — CmdStanModel","title":"CmdStanModel objects — CmdStanModel","text":"CmdStanModel object R6 object created cmdstan_model() function. object stores path Stan program compiled executable (created), provides methods fitting model using Stan's algorithms.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/CmdStanModel.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"CmdStanModel objects — CmdStanModel","text":"CmdStanModel objects following associated methods, many (linked) documentation pages:","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/CmdStanModel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CmdStanModel objects — CmdStanModel","text":"","code":"# \\dontrun{ library(cmdstanr) library(posterior) library(bayesplot) #> This is bayesplot version 1.15.0 #> - Online documentation and vignettes at mc-stan.org/bayesplot #> - bayesplot theme set to bayesplot::theme_default() #>    * Does _not_ affect other ggplot2 plots #>    * See ?bayesplot_theme_set for details on theme setting #>  #> Attaching package: ‘bayesplot’ #> The following object is masked from ‘package:posterior’: #>  #>     rhat color_scheme_set(\"brightblue\")  # Set path to CmdStan # (Note: if you installed CmdStan via install_cmdstan() with default settings # then setting the path is unnecessary but the default below should still work. # Otherwise use the `path` argument to specify the location of your # CmdStan installation.) set_cmdstan_path(path = NULL) #> CmdStan path set to: /home/runner/.cmdstan/cmdstan-2.37.0  # Create a CmdStanModel object from a Stan program, # here using the example model that comes with CmdStan file <- file.path(cmdstan_path(), \"examples/bernoulli/bernoulli.stan\") mod <- cmdstan_model(file) mod$print() #> data { #>   int<lower=0> N; #>   array[N] int<lower=0, upper=1> y; #> } #> parameters { #>   real<lower=0, upper=1> theta; #> } #> model { #>   theta ~ beta(1, 1); // uniform prior on interval 0,1 #>   y ~ bernoulli(theta); #> } # Print with line numbers. This can be set globally using the # `cmdstanr_print_line_numbers` option. mod$print(line_numbers = TRUE) #>  1: data { #>  2:   int<lower=0> N; #>  3:   array[N] int<lower=0, upper=1> y; #>  4: } #>  5: parameters { #>  6:   real<lower=0, upper=1> theta; #>  7: } #>  8: model { #>  9:   theta ~ beta(1, 1); // uniform prior on interval 0,1 #> 10:   y ~ bernoulli(theta); #> 11: }  # Data as a named list (like RStan) stan_data <- list(N = 10, y = c(0,1,0,0,0,0,0,0,0,1))  # Run MCMC using the 'sample' method fit_mcmc <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   parallel_chains = 2 ) #> Running MCMC with 2 parallel chains... #>  #> Chain 1 Iteration:    1 / 2000 [  0%]  (Warmup)  #> Chain 1 Iteration:  100 / 2000 [  5%]  (Warmup)  #> Chain 1 Iteration:  200 / 2000 [ 10%]  (Warmup)  #> Chain 1 Iteration:  300 / 2000 [ 15%]  (Warmup)  #> Chain 1 Iteration:  400 / 2000 [ 20%]  (Warmup)  #> Chain 1 Iteration:  500 / 2000 [ 25%]  (Warmup)  #> Chain 1 Iteration:  600 / 2000 [ 30%]  (Warmup)  #> Chain 1 Iteration:  700 / 2000 [ 35%]  (Warmup)  #> Chain 1 Iteration:  800 / 2000 [ 40%]  (Warmup)  #> Chain 1 Iteration:  900 / 2000 [ 45%]  (Warmup)  #> Chain 1 Iteration: 1000 / 2000 [ 50%]  (Warmup)  #> Chain 1 Iteration: 1001 / 2000 [ 50%]  (Sampling)  #> Chain 1 Iteration: 1100 / 2000 [ 55%]  (Sampling)  #> Chain 1 Iteration: 1200 / 2000 [ 60%]  (Sampling)  #> Chain 1 Iteration: 1300 / 2000 [ 65%]  (Sampling)  #> Chain 1 Iteration: 1400 / 2000 [ 70%]  (Sampling)  #> Chain 1 Iteration: 1500 / 2000 [ 75%]  (Sampling)  #> Chain 1 Iteration: 1600 / 2000 [ 80%]  (Sampling)  #> Chain 1 Iteration: 1700 / 2000 [ 85%]  (Sampling)  #> Chain 1 Iteration: 1800 / 2000 [ 90%]  (Sampling)  #> Chain 1 Iteration: 1900 / 2000 [ 95%]  (Sampling)  #> Chain 1 Iteration: 2000 / 2000 [100%]  (Sampling)  #> Chain 2 Iteration:    1 / 2000 [  0%]  (Warmup)  #> Chain 2 Iteration:  100 / 2000 [  5%]  (Warmup)  #> Chain 2 Iteration:  200 / 2000 [ 10%]  (Warmup)  #> Chain 2 Iteration:  300 / 2000 [ 15%]  (Warmup)  #> Chain 2 Iteration:  400 / 2000 [ 20%]  (Warmup)  #> Chain 2 Iteration:  500 / 2000 [ 25%]  (Warmup)  #> Chain 2 Iteration:  600 / 2000 [ 30%]  (Warmup)  #> Chain 2 Iteration:  700 / 2000 [ 35%]  (Warmup)  #> Chain 2 Iteration:  800 / 2000 [ 40%]  (Warmup)  #> Chain 2 Iteration:  900 / 2000 [ 45%]  (Warmup)  #> Chain 2 Iteration: 1000 / 2000 [ 50%]  (Warmup)  #> Chain 2 Iteration: 1001 / 2000 [ 50%]  (Sampling)  #> Chain 2 Iteration: 1100 / 2000 [ 55%]  (Sampling)  #> Chain 2 Iteration: 1200 / 2000 [ 60%]  (Sampling)  #> Chain 2 Iteration: 1300 / 2000 [ 65%]  (Sampling)  #> Chain 2 Iteration: 1400 / 2000 [ 70%]  (Sampling)  #> Chain 2 Iteration: 1500 / 2000 [ 75%]  (Sampling)  #> Chain 2 Iteration: 1600 / 2000 [ 80%]  (Sampling)  #> Chain 2 Iteration: 1700 / 2000 [ 85%]  (Sampling)  #> Chain 2 Iteration: 1800 / 2000 [ 90%]  (Sampling)  #> Chain 2 Iteration: 1900 / 2000 [ 95%]  (Sampling)  #> Chain 2 Iteration: 2000 / 2000 [100%]  (Sampling)  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.1 seconds. #>   # Use 'posterior' package for summaries fit_mcmc$summary() #> # A tibble: 2 × 10 #>   variable   mean median    sd   mad      q5    q95  rhat ess_bulk ess_tail #>   <chr>     <dbl>  <dbl> <dbl> <dbl>   <dbl>  <dbl> <dbl>    <dbl>    <dbl> #> 1 lp__     -7.32  -7.02  0.799 0.355 -8.89   -6.75   1.00     819.    1020. #> 2 theta     0.255  0.240 0.127 0.130  0.0773  0.491  1.00     557.     616.  # Check sampling diagnostics fit_mcmc$diagnostic_summary() #> $num_divergent #> [1] 0 0 #>  #> $num_max_treedepth #> [1] 0 0 #>  #> $ebfmi #> [1] 1.114870 1.030279 #>   # Get posterior draws draws <- fit_mcmc$draws() print(draws) #> # A draws_array: 1000 iterations, 2 chains, and 2 variables #> , , variable = lp__ #>  #>          chain #> iteration    1    2 #>         1 -7.0 -6.8 #>         2 -7.9 -6.9 #>         3 -7.4 -6.9 #>         4 -6.7 -6.8 #>         5 -6.9 -6.8 #>  #> , , variable = theta #>  #>          chain #> iteration    1    2 #>         1 0.17 0.28 #>         2 0.46 0.19 #>         3 0.41 0.19 #>         4 0.25 0.28 #>         5 0.18 0.23 #>  #> # ... with 995 more iterations  # Convert to data frame using posterior::as_draws_df as_draws_df(draws) #> # A draws_df: 1000 iterations, 2 chains, and 2 variables #>    lp__ theta #> 1  -7.0  0.17 #> 2  -7.9  0.46 #> 3  -7.4  0.41 #> 4  -6.7  0.25 #> 5  -6.9  0.18 #> 6  -6.9  0.33 #> 7  -7.2  0.15 #> 8  -6.8  0.29 #> 9  -6.8  0.24 #> 10 -6.8  0.24 #> # ... with 1990 more draws #> # ... hidden reserved variables {'.chain', '.iteration', '.draw'}  # Plot posterior using bayesplot (ggplot2) mcmc_hist(fit_mcmc$draws(\"theta\")) #> `stat_bin()` using `bins = 30`. Pick better value `binwidth`.   # Run 'optimize' method to get a point estimate (default is Stan's LBFGS algorithm) # and also demonstrate specifying data as a path to a file instead of a list my_data_file <- file.path(cmdstan_path(), \"examples/bernoulli/bernoulli.data.json\") fit_optim <- mod$optimize(data = my_data_file, seed = 123) #> Initial log joint probability = -16.144  #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes   #>        6      -5.00402   0.000246518   8.73164e-07           1           1        9     #> Optimization terminated normally:   #>   Convergence detected: relative gradient magnitude is below tolerance  #> Finished in  0.1 seconds. fit_optim$summary() #> # A tibble: 2 × 2 #>   variable estimate #>   <chr>       <dbl> #> 1 lp__       -5.00  #> 2 theta       0.200  # Run 'optimize' again with 'jacobian=TRUE' and then draw from Laplace approximation # to the posterior fit_optim <- mod$optimize(data = my_data_file, jacobian = TRUE) #> Initial log joint probability = -7.33343  #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes   #>        5      -6.74802   0.000459644   7.47424e-07           1           1        8     #> Optimization terminated normally:   #>   Convergence detected: relative gradient magnitude is below tolerance  #> Finished in  0.1 seconds. fit_laplace <- mod$laplace(data = my_data_file, mode = fit_optim, draws = 2000) #> Calculating Hessian  #> Calculating inverse of Cholesky factor  #> Generating draws  #> iteration: 0  #> iteration: 100  #> iteration: 200  #> iteration: 300  #> iteration: 400  #> iteration: 500  #> iteration: 600  #> iteration: 700  #> iteration: 800  #> iteration: 900  #> iteration: 1000  #> iteration: 1100  #> iteration: 1200  #> iteration: 1300  #> iteration: 1400  #> iteration: 1500  #> iteration: 1600  #> iteration: 1700  #> iteration: 1800  #> iteration: 1900  #> Finished in  0.1 seconds. fit_laplace$summary() #> # A tibble: 3 × 7 #>   variable      mean median    sd   mad      q5      q95 #>   <chr>        <dbl>  <dbl> <dbl> <dbl>   <dbl>    <dbl> #> 1 lp__        -7.24  -6.97  0.692 0.299 -8.63   -6.75    #> 2 lp_approx__ -0.503 -0.225 0.716 0.305 -1.99   -0.00156 #> 3 theta        0.269  0.252 0.122 0.122  0.0971  0.496    # Run 'variational' method to use ADVI to approximate posterior fit_vb <- mod$variational(data = stan_data, seed = 123) #> ------------------------------------------------------------  #> EXPERIMENTAL ALGORITHM:  #>   This procedure has not been thoroughly tested and may be unstable  #>   or buggy. The interface is subject to change.  #> ------------------------------------------------------------  #> Gradient evaluation took 2e-06 seconds  #> 1000 transitions using 10 leapfrog steps per transition would take 0.02 seconds.  #> Adjust your expectations accordingly!  #> Begin eta adaptation.  #> Iteration:   1 / 250 [  0%]  (Adaptation)  #> Iteration:  50 / 250 [ 20%]  (Adaptation)  #> Iteration: 100 / 250 [ 40%]  (Adaptation)  #> Iteration: 150 / 250 [ 60%]  (Adaptation)  #> Iteration: 200 / 250 [ 80%]  (Adaptation)  #> Success! Found best value [eta = 1] earlier than expected.  #> Begin stochastic gradient ascent.  #>   iter             ELBO   delta_ELBO_mean   delta_ELBO_med   notes   #>    100           -6.164             1.000            1.000  #>    200           -6.225             0.505            1.000  #>    300           -6.186             0.339            0.010   MEDIAN ELBO CONVERGED  #> Drawing a sample of size 1000 from the approximate posterior...   #> COMPLETED.  #> Finished in  0.1 seconds. fit_vb$summary() #> # A tibble: 3 × 7 #>   variable      mean median    sd   mad     q5      q95 #>   <chr>        <dbl>  <dbl> <dbl> <dbl>  <dbl>    <dbl> #> 1 lp__        -7.14  -6.93  0.528 0.247 -8.21  -6.75    #> 2 lp_approx__ -0.520 -0.244 0.740 0.326 -1.90  -0.00227 #> 3 theta        0.251  0.236 0.107 0.108  0.100  0.446   mcmc_hist(fit_vb$draws(\"theta\")) #> `stat_bin()` using `bins = 30`. Pick better value `binwidth`.   # Run 'pathfinder' method, a new alternative to the variational method fit_pf <- mod$pathfinder(data = stan_data, seed = 123) #> Path [1] :Initial log joint density = -18.273334  #> Path [1] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      7.082e-04   1.432e-05    1.000e+00  1.000e+00       156 -6.216e+00 -6.145e+00                    #> Path [1] :Best Iter: [5] ELBO (-6.145070) evaluations: (156)  #> Path [2] :Initial log joint density = -19.192715  #> Path [2] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.015e-04   2.228e-06    1.000e+00  1.000e+00       156 -6.170e+00 -6.223e+00                    #> Path [2] :Best Iter: [2] ELBO (-6.170358) evaluations: (156)  #> Path [3] :Initial log joint density = -6.774820  #> Path [3] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               4      -6.748e+00      1.137e-04   2.596e-07    1.000e+00  1.000e+00       123 -6.243e+00 -6.178e+00                    #> Path [3] :Best Iter: [4] ELBO (-6.177909) evaluations: (123)  #> Path [4] :Initial log joint density = -7.949193  #> Path [4] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.145e-04   1.301e-06    1.000e+00  1.000e+00       156 -6.235e+00 -6.197e+00                    #> Path [4] :Best Iter: [5] ELBO (-6.197118) evaluations: (156)  #> Finished in  0.1 seconds. fit_pf$summary() #> # A tibble: 4 × 7 #>   variable      mean median    sd   mad      q5    q95 #>   <chr>        <dbl>  <dbl> <dbl> <dbl>   <dbl>  <dbl> #> 1 lp_approx__ -1.07  -0.724 0.871 0.306 -2.82   -0.451 #> 2 path__       2.46   2     1.12  1.48   1       4     #> 3 lp__        -7.26  -6.97  0.720 0.304 -8.77   -6.75  #> 4 theta        0.258  0.241 0.121 0.119  0.0840  0.475 mcmc_hist(fit_pf$draws(\"theta\")) #> `stat_bin()` using `bins = 30`. Pick better value `binwidth`.   # Run 'pathfinder' again with more paths, fewer draws per path, # better covariance approximation, and fewer LBFGSs iterations fit_pf <- mod$pathfinder(data = stan_data, num_paths=10, single_path_draws=40,                          history_size=50, max_lbfgs_iters=100) #> Warning: Number of PSIS draws is larger than the total number of draws returned by the single Pathfinders. This is likely unintentional and leads to re-sampling from the same draws.  #> Path [1] :Initial log joint density = -13.512690  #> Path [1] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      1.842e-03   4.678e-05    1.000e+00  1.000e+00       156 -6.240e+00 -6.342e+00                    #> Path [1] :Best Iter: [4] ELBO (-6.239690) evaluations: (156)  #> Path [2] :Initial log joint density = -9.868976  #> Path [2] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      5.914e-04   6.778e-06    1.000e+00  1.000e+00       156 -6.194e+00 -6.232e+00                    #> Path [2] :Best Iter: [2] ELBO (-6.194321) evaluations: (156)  #> Path [3] :Initial log joint density = -6.920148  #> Path [3] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               4      -6.748e+00      1.368e-03   1.641e-05    1.000e+00  1.000e+00       123 -6.207e+00 -6.260e+00                    #> Path [3] :Best Iter: [2] ELBO (-6.207238) evaluations: (123)  #> Path [4] :Initial log joint density = -17.833187  #> Path [4] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      9.799e-04   2.299e-05    1.000e+00  1.000e+00       156 -6.243e+00 -6.190e+00                    #> Path [4] :Best Iter: [5] ELBO (-6.190028) evaluations: (156)  #> Path [5] :Initial log joint density = -6.839300  #> Path [5] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               3      -6.748e+00      6.135e-03   1.731e-04    9.298e-01  9.298e-01        91 -6.219e+00 -6.277e+00                    #> Path [5] :Best Iter: [2] ELBO (-6.218719) evaluations: (91)  #> Path [6] :Initial log joint density = -9.280909  #> Path [6] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      4.032e-04   3.727e-06    1.000e+00  1.000e+00       156 -6.223e+00 -6.207e+00                    #> Path [6] :Best Iter: [5] ELBO (-6.207135) evaluations: (156)  #> Path [7] :Initial log joint density = -9.855257  #> Path [7] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      5.870e-04   6.698e-06    1.000e+00  1.000e+00       156 -6.244e+00 -6.181e+00                    #> Path [7] :Best Iter: [5] ELBO (-6.180760) evaluations: (156)  #> Path [8] :Initial log joint density = -7.427787  #> Path [8] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      9.584e-05   3.526e-07    1.000e+00  1.000e+00       156 -6.198e+00 -6.185e+00                    #> Path [8] :Best Iter: [5] ELBO (-6.184759) evaluations: (156)  #> Path [9] :Initial log joint density = -6.877897  #> Path [9] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               4      -6.748e+00      1.444e-04   2.192e-05    9.388e-01  9.388e-01       123 -6.242e+00 -6.203e+00                    #> Path [9] :Best Iter: [4] ELBO (-6.203321) evaluations: (123)  #> Path [10] :Initial log joint density = -7.284278  #> Path [10] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               4      -6.748e+00      5.080e-03   1.456e-04    1.000e+00  1.000e+00       123 -6.188e+00 -6.168e+00                    #> Path [10] :Best Iter: [4] ELBO (-6.168415) evaluations: (123)  #> Pareto k value (0.82) is greater than 0.7. Importance resampling was not able to improve the approximation, which may indicate that the approximation itself is poor.  #> Finished in  0.1 seconds.  # Specifying initial values as a function fit_mcmc_w_init_fun <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   refresh = 0,   init = function() list(theta = runif(1)) ) #> Running MCMC with 2 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.2 seconds. #>  fit_mcmc_w_init_fun_2 <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   refresh = 0,   init = function(chain_id) {     # silly but demonstrates optional use of chain_id     list(theta = 1 / (chain_id + 1))   } ) #> Running MCMC with 2 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.2 seconds. #>  fit_mcmc_w_init_fun_2$init() #> [[1]] #> [[1]]$theta #> [1] 0.5 #>  #>  #> [[2]] #> [[2]]$theta #> [1] 0.3333333 #>  #>   # Specifying initial values as a list of lists fit_mcmc_w_init_list <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   refresh = 0,   init = list(     list(theta = 0.75), # chain 1     list(theta = 0.25)  # chain 2   ) ) #> Running MCMC with 2 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.2 seconds. #>  fit_optim_w_init_list <- mod$optimize(   data = stan_data,   seed = 123,   init = list(     list(theta = 0.75)   ) ) #> Initial log joint probability = -11.6657  #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes   #>        6      -5.00402   0.000237915   9.55309e-07           1           1        9     #> Optimization terminated normally:   #>   Convergence detected: relative gradient magnitude is below tolerance  #> Finished in  0.1 seconds. fit_optim_w_init_list$init() #> [[1]] #> [[1]]$theta #> [1] 0.75 #>  #>  # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/CmdStanPathfinder.html","id":null,"dir":"Reference","previous_headings":"","what":"CmdStanPathfinder objects — CmdStanPathfinder","title":"CmdStanPathfinder objects — CmdStanPathfinder","text":"CmdStanPathfinder object fitted model object returned $pathfinder() method CmdStanModel object.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/CmdStanPathfinder.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"CmdStanPathfinder objects — CmdStanPathfinder","text":"CmdStanPathfinder objects following associated methods, (linked) documentation pages.","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/CmdStanVB.html","id":null,"dir":"Reference","previous_headings":"","what":"CmdStanVB objects — CmdStanVB","title":"CmdStanVB objects — CmdStanVB","text":"CmdStanVB object fitted model object returned $variational() method CmdStanModel object.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/CmdStanVB.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"CmdStanVB objects — CmdStanVB","text":"CmdStanVB objects following associated methods, (linked) documentation pages.","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/as_draws.CmdStanMCMC.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a draws object from a CmdStanR fitted model object — as_draws.CmdStanMCMC","title":"Create a draws object from a CmdStanR fitted model object — as_draws.CmdStanMCMC","text":"Create draws object supported posterior package. methods just wrappers around CmdStanR's $draws() method provided convenience.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/as_draws.CmdStanMCMC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a draws object from a CmdStanR fitted model object — as_draws.CmdStanMCMC","text":"","code":"# S3 method for class 'CmdStanMCMC' as_draws(x, ...)  # S3 method for class 'CmdStanMLE' as_draws(x, ...)  # S3 method for class 'CmdStanLaplace' as_draws(x, ...)  # S3 method for class 'CmdStanVB' as_draws(x, ...)  # S3 method for class 'CmdStanGQ' as_draws(x, ...)  # S3 method for class 'CmdStanPathfinder' as_draws(x, ...)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/as_draws.CmdStanMCMC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a draws object from a CmdStanR fitted model object — as_draws.CmdStanMCMC","text":"x CmdStanR fitted model object. ... Optional arguments passed $draws() method (e.g., variables, inc_warmup, etc.).","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/as_draws.CmdStanMCMC.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a draws object from a CmdStanR fitted model object — as_draws.CmdStanMCMC","text":"subset iterations, chains, draws, use posterior::subset_draws() method creating draws object.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/as_draws.CmdStanMCMC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a draws object from a CmdStanR fitted model object — as_draws.CmdStanMCMC","text":"","code":"# \\dontrun{ fit <- cmdstanr_example() as_draws(fit) #> # A draws_array: 1000 iterations, 4 chains, and 105 variables #> , , variable = lp__ #>  #>          chain #> iteration   1   2   3   4 #>         1 -66 -67 -72 -66 #>         2 -66 -64 -67 -67 #>         3 -68 -66 -68 -67 #>         4 -67 -70 -64 -68 #>         5 -71 -65 -67 -68 #>  #> , , variable = alpha #>  #>          chain #> iteration    1     2     3    4 #>         1 0.27  0.79 0.074 0.25 #>         2 0.16  0.38 0.083 0.15 #>         3 0.93  0.11 0.538 0.31 #>         4 0.34 -0.24 0.323 0.28 #>         5 0.62  0.59 0.212 0.41 #>  #> , , variable = beta[1] #>  #>          chain #> iteration     1     2     3     4 #>         1 -0.86 -0.38 -0.65 -0.96 #>         2 -0.67 -0.60 -0.33 -0.33 #>         3 -0.72 -0.49 -0.49 -0.50 #>         4 -0.93 -0.27 -0.50 -0.98 #>         5 -0.50 -0.72 -0.18 -0.78 #>  #> , , variable = beta[2] #>  #>          chain #> iteration      1      2      3      4 #>         1  0.044 -0.061  0.348 -0.447 #>         2 -0.523 -0.331  0.074 -0.094 #>         3 -0.218 -0.253  0.220  0.169 #>         4 -0.327 -0.124 -0.084 -0.259 #>         5 -0.567 -0.360 -0.191 -0.308 #>  #> # ... with 995 more iterations, and 101 more variables  # posterior's as_draws_*() methods will also work posterior::as_draws_rvars(fit) #> # A draws_rvars: 1000 iterations, 4 chains, and 4 variables #> $lp__: rvar<1000,4>[1] mean ± sd: #> [1] -66 ± 1.5  #>  #> $alpha: rvar<1000,4>[1] mean ± sd: #> [1] 0.37 ± 0.22  #>  #> $beta: rvar<1000,4>[3] mean ± sd: #> [1] -0.67 ± 0.25  -0.27 ± 0.23   0.68 ± 0.27  #>  #> $log_lik: rvar<1000,4>[100] mean ± sd: #>   [1] -0.519 ± 0.099  -0.400 ± 0.148  -0.500 ± 0.219  -0.447 ± 0.151  #>   [5] -1.177 ± 0.282  -0.595 ± 0.191  -0.637 ± 0.125  -0.280 ± 0.135  #>   [9] -0.697 ± 0.170  -0.742 ± 0.233  -0.282 ± 0.124  -0.494 ± 0.238  #>  [13] -0.652 ± 0.208  -0.362 ± 0.171  -0.281 ± 0.107  -0.277 ± 0.087  #>  [17] -1.587 ± 0.288  -0.482 ± 0.109  -0.234 ± 0.076  -0.113 ± 0.078  #>  [21] -0.213 ± 0.087  -0.572 ± 0.150  -0.333 ± 0.141  -0.137 ± 0.066  #>  [25] -0.452 ± 0.122  -1.516 ± 0.344  -0.308 ± 0.121  -0.448 ± 0.084  #>  [29] -0.721 ± 0.229  -0.699 ± 0.195  -0.491 ± 0.162  -0.427 ± 0.108  #>  [33] -0.407 ± 0.127  -0.064 ± 0.050  -0.583 ± 0.185  -0.327 ± 0.133  #>  [37] -0.702 ± 0.228  -0.310 ± 0.148  -0.180 ± 0.108  -0.684 ± 0.131  #>  [41] -1.125 ± 0.252  -0.936 ± 0.202  -0.412 ± 0.262  -1.171 ± 0.186  #>  [45] -0.360 ± 0.117  -0.579 ± 0.129  -0.303 ± 0.127  -0.326 ± 0.083  #>  [49] -0.321 ± 0.080  -1.286 ± 0.333  -0.290 ± 0.094  -0.831 ± 0.143  #>  [53] -0.404 ± 0.130  -0.372 ± 0.141  -0.383 ± 0.135  -0.322 ± 0.191  #>  [57] -0.660 ± 0.119  -0.955 ± 0.359  -1.366 ± 0.346  -0.975 ± 0.160  #>  [61] -0.543 ± 0.099  -0.873 ± 0.311  -0.117 ± 0.072  -0.897 ± 0.249  #>  [65] -2.006 ± 0.587  -0.511 ± 0.137  -0.278 ± 0.082  -1.056 ± 0.235  #>  [69] -0.438 ± 0.084  -0.643 ± 0.238  -0.606 ± 0.209  -0.460 ± 0.171  #>  [73] -1.490 ± 0.367  -0.945 ± 0.197  -1.139 ± 0.388  -0.374 ± 0.138  #>  [77] -0.873 ± 0.139  -0.490 ± 0.172  -0.767 ± 0.191  -0.539 ± 0.197  #>  [81] -0.162 ± 0.100  -0.222 ± 0.138  -0.345 ± 0.081  -0.277 ± 0.091  #>  [85] -0.131 ± 0.074  -1.132 ± 0.323  -0.820 ± 0.128  -0.772 ± 0.240  #>  [89] -1.284 ± 0.320  -0.260 ± 0.135  -0.384 ± 0.130  -1.492 ± 0.343  #>  [93] -0.736 ± 0.219  -0.319 ± 0.087  -0.391 ± 0.112  -1.568 ± 0.282  #>  [97] -0.433 ± 0.102  -1.057 ± 0.378  -0.690 ± 0.141  -0.393 ± 0.097  #>  posterior::as_draws_list(fit) #> # A draws_list: 1000 iterations, 4 chains, and 105 variables #>  #> [chain = 1] #> $lp__ #>  [1] -66 -66 -68 -67 -71 -67 -67 -65 -65 -67 #>  #> $alpha #>  [1]  0.272  0.156  0.930  0.336  0.617  0.180  0.036  0.480  0.579 -0.027 #>  #> $`beta[1]` #>  [1] -0.86 -0.67 -0.72 -0.93 -0.50 -0.30 -0.62 -0.61 -0.42 -0.98 #>  #> $`beta[2]` #>  [1]  0.044 -0.523 -0.218 -0.327 -0.567 -0.537 -0.594 -0.537 -0.346 -0.186 #>  #>  #> [chain = 2] #> $lp__ #>  [1] -67 -64 -66 -70 -65 -66 -65 -64 -66 -65 #>  #> $alpha #>  [1]  0.79  0.38  0.11 -0.24  0.59  0.16  0.40  0.48  0.17  0.56 #>  #> $`beta[1]` #>  [1] -0.38 -0.60 -0.49 -0.27 -0.72 -0.96 -0.36 -0.60 -0.50 -0.81 #>  #> $`beta[2]` #>  [1] -0.061 -0.331 -0.253 -0.124 -0.360 -0.115 -0.286 -0.271  0.014 -0.391 #>  #> # ... with 990 more iterations, and 2 more chains, and 101 more variables # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/as_mcmc.list.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert CmdStanMCMC to mcmc.list — as_mcmc.list","title":"Convert CmdStanMCMC to mcmc.list — as_mcmc.list","text":"function converts CmdStanMCMC object mcmc.list object compatible coda package. primarily intended users Stan coming BUGS/JAGS used coda plotting diagnostics. general recommend recent MCMC diagnostics posterior ggplot2-based plotting functions bayesplot, users prefer coda function provides compatibility.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/as_mcmc.list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert CmdStanMCMC to mcmc.list — as_mcmc.list","text":"","code":"as_mcmc.list(x)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/as_mcmc.list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert CmdStanMCMC to mcmc.list — as_mcmc.list","text":"x CmdStanMCMC object.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/as_mcmc.list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert CmdStanMCMC to mcmc.list — as_mcmc.list","text":"mcmc.list object compatible coda package.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/as_mcmc.list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert CmdStanMCMC to mcmc.list — as_mcmc.list","text":"","code":"# \\dontrun{ fit <- cmdstanr_example() x <- as_mcmc.list(fit) # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstan_coercion.html","id":null,"dir":"Reference","previous_headings":"","what":"Coercion methods for CmdStan objects — cmdstan_coercion","title":"Coercion methods for CmdStan objects — cmdstan_coercion","text":"generic functions intended primarily used developers packages interface CmdStanR. Developers can define methods top generics coerce objects CmdStanR's fitted model objects.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstan_coercion.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coercion methods for CmdStan objects — cmdstan_coercion","text":"","code":"as.CmdStanMCMC(object, ...)  as.CmdStanMLE(object, ...)  as.CmdStanLaplace(object, ...)  as.CmdStanVB(object, ...)  as.CmdStanPathfinder(object, ...)  as.CmdStanGQ(object, ...)  as.CmdStanDiagnose(object, ...)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstan_coercion.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coercion methods for CmdStan objects — cmdstan_coercion","text":"object object coerced. ... Additional arguments pass methods.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstan_default_install_path.html","id":null,"dir":"Reference","previous_headings":"","what":"cmdstan_default_install_path — cmdstan_default_install_path","title":"cmdstan_default_install_path — cmdstan_default_install_path","text":"Path  install_cmdstan() default settings installs CmdStan.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstan_default_install_path.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"cmdstan_default_install_path — cmdstan_default_install_path","text":"","code":"cmdstan_default_install_path(old = FALSE, wsl = FALSE)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstan_default_install_path.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"cmdstan_default_install_path — cmdstan_default_install_path","text":"old old default path (.cmdstanr) used instead new one (.cmdstan)? Defaults FALSE may removed future release. wsl Return directory WSL installations?","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstan_default_install_path.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"cmdstan_default_install_path — cmdstan_default_install_path","text":"installation path.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstan_default_path.html","id":null,"dir":"Reference","previous_headings":"","what":"cmdstan_default_path — cmdstan_default_path","title":"cmdstan_default_path — cmdstan_default_path","text":"Returns path installation CmdStan recent release version.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstan_default_path.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"cmdstan_default_path — cmdstan_default_path","text":"","code":"cmdstan_default_path(old = FALSE, dir = NULL)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstan_default_path.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"cmdstan_default_path — cmdstan_default_path","text":"old See cmdstan_default_install_path(). dir Path custom install folder CmdStan installations.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstan_default_path.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"cmdstan_default_path — cmdstan_default_path","text":"Path CmdStan installation recent release version, NULL installation found.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstan_default_path.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"cmdstan_default_path — cmdstan_default_path","text":"Windows systems WSL CmdStan installs, side--side WSL native installs version WSL preferred. Otherwise, recent release chosen, regardless whether native WSL.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstan_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a new CmdStanModel object — cmdstan_model","title":"Create a new CmdStanModel object — cmdstan_model","text":"Create new CmdStanModel object file containing Stan program existing Stan executable. CmdStanModel object stores path Stan program compiled executable (created), provides methods fitting model using Stan's algorithms. See compile ... arguments control whether compilation happens.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstan_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a new CmdStanModel object — cmdstan_model","text":"","code":"cmdstan_model(stan_file = NULL, exe_file = NULL, compile = TRUE, ...)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstan_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a new CmdStanModel object — cmdstan_model","text":"stan_file (string) path .stan file containing Stan program. helper function write_stan_file() provided cases convenient specify Stan program string. stan_file specified exe_file must specified. exe_file (string) path existing Stan model executable. Can provided instead addition stan_file (stan_file omitted CmdStanModel methods like $code() $print() work). argument can used CmdStan 2.27+. compile (logical) compilation? default TRUE. FALSE compilation can done later via $compile() method. ... Optionally, additional arguments pass $compile() method compile=TRUE. options include specifying directory saving executable, turning pedantic mode, specifying include paths, configuring C++ options, . See $compile() details.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstan_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a new CmdStanModel object — cmdstan_model","text":"CmdStanModel object.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstan_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a new CmdStanModel object — cmdstan_model","text":"","code":"# \\dontrun{ library(cmdstanr) library(posterior) library(bayesplot) color_scheme_set(\"brightblue\")  # Set path to CmdStan # (Note: if you installed CmdStan via install_cmdstan() with default settings # then setting the path is unnecessary but the default below should still work. # Otherwise use the `path` argument to specify the location of your # CmdStan installation.) set_cmdstan_path(path = NULL) #> CmdStan path set to: /home/runner/.cmdstan/cmdstan-2.37.0  # Create a CmdStanModel object from a Stan program, # here using the example model that comes with CmdStan file <- file.path(cmdstan_path(), \"examples/bernoulli/bernoulli.stan\") mod <- cmdstan_model(file) mod$print() #> data { #>   int<lower=0> N; #>   array[N] int<lower=0, upper=1> y; #> } #> parameters { #>   real<lower=0, upper=1> theta; #> } #> model { #>   theta ~ beta(1, 1); // uniform prior on interval 0,1 #>   y ~ bernoulli(theta); #> } # Print with line numbers. This can be set globally using the # `cmdstanr_print_line_numbers` option. mod$print(line_numbers = TRUE) #>  1: data { #>  2:   int<lower=0> N; #>  3:   array[N] int<lower=0, upper=1> y; #>  4: } #>  5: parameters { #>  6:   real<lower=0, upper=1> theta; #>  7: } #>  8: model { #>  9:   theta ~ beta(1, 1); // uniform prior on interval 0,1 #> 10:   y ~ bernoulli(theta); #> 11: }  # Data as a named list (like RStan) stan_data <- list(N = 10, y = c(0,1,0,0,0,0,0,0,0,1))  # Run MCMC using the 'sample' method fit_mcmc <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   parallel_chains = 2 ) #> Running MCMC with 2 parallel chains... #>  #> Chain 1 Iteration:    1 / 2000 [  0%]  (Warmup)  #> Chain 1 Iteration:  100 / 2000 [  5%]  (Warmup)  #> Chain 1 Iteration:  200 / 2000 [ 10%]  (Warmup)  #> Chain 1 Iteration:  300 / 2000 [ 15%]  (Warmup)  #> Chain 1 Iteration:  400 / 2000 [ 20%]  (Warmup)  #> Chain 1 Iteration:  500 / 2000 [ 25%]  (Warmup)  #> Chain 1 Iteration:  600 / 2000 [ 30%]  (Warmup)  #> Chain 1 Iteration:  700 / 2000 [ 35%]  (Warmup)  #> Chain 1 Iteration:  800 / 2000 [ 40%]  (Warmup)  #> Chain 1 Iteration:  900 / 2000 [ 45%]  (Warmup)  #> Chain 1 Iteration: 1000 / 2000 [ 50%]  (Warmup)  #> Chain 1 Iteration: 1001 / 2000 [ 50%]  (Sampling)  #> Chain 1 Iteration: 1100 / 2000 [ 55%]  (Sampling)  #> Chain 1 Iteration: 1200 / 2000 [ 60%]  (Sampling)  #> Chain 1 Iteration: 1300 / 2000 [ 65%]  (Sampling)  #> Chain 1 Iteration: 1400 / 2000 [ 70%]  (Sampling)  #> Chain 1 Iteration: 1500 / 2000 [ 75%]  (Sampling)  #> Chain 1 Iteration: 1600 / 2000 [ 80%]  (Sampling)  #> Chain 1 Iteration: 1700 / 2000 [ 85%]  (Sampling)  #> Chain 1 Iteration: 1800 / 2000 [ 90%]  (Sampling)  #> Chain 1 Iteration: 1900 / 2000 [ 95%]  (Sampling)  #> Chain 1 Iteration: 2000 / 2000 [100%]  (Sampling)  #> Chain 2 Iteration:    1 / 2000 [  0%]  (Warmup)  #> Chain 2 Iteration:  100 / 2000 [  5%]  (Warmup)  #> Chain 2 Iteration:  200 / 2000 [ 10%]  (Warmup)  #> Chain 2 Iteration:  300 / 2000 [ 15%]  (Warmup)  #> Chain 2 Iteration:  400 / 2000 [ 20%]  (Warmup)  #> Chain 2 Iteration:  500 / 2000 [ 25%]  (Warmup)  #> Chain 2 Iteration:  600 / 2000 [ 30%]  (Warmup)  #> Chain 2 Iteration:  700 / 2000 [ 35%]  (Warmup)  #> Chain 2 Iteration:  800 / 2000 [ 40%]  (Warmup)  #> Chain 2 Iteration:  900 / 2000 [ 45%]  (Warmup)  #> Chain 2 Iteration: 1000 / 2000 [ 50%]  (Warmup)  #> Chain 2 Iteration: 1001 / 2000 [ 50%]  (Sampling)  #> Chain 2 Iteration: 1100 / 2000 [ 55%]  (Sampling)  #> Chain 2 Iteration: 1200 / 2000 [ 60%]  (Sampling)  #> Chain 2 Iteration: 1300 / 2000 [ 65%]  (Sampling)  #> Chain 2 Iteration: 1400 / 2000 [ 70%]  (Sampling)  #> Chain 2 Iteration: 1500 / 2000 [ 75%]  (Sampling)  #> Chain 2 Iteration: 1600 / 2000 [ 80%]  (Sampling)  #> Chain 2 Iteration: 1700 / 2000 [ 85%]  (Sampling)  #> Chain 2 Iteration: 1800 / 2000 [ 90%]  (Sampling)  #> Chain 2 Iteration: 1900 / 2000 [ 95%]  (Sampling)  #> Chain 2 Iteration: 2000 / 2000 [100%]  (Sampling)  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.1 seconds. #>   # Use 'posterior' package for summaries fit_mcmc$summary() #> # A tibble: 2 × 10 #>   variable   mean median    sd   mad      q5    q95  rhat ess_bulk ess_tail #>   <chr>     <dbl>  <dbl> <dbl> <dbl>   <dbl>  <dbl> <dbl>    <dbl>    <dbl> #> 1 lp__     -7.32  -7.02  0.799 0.355 -8.89   -6.75   1.00     819.    1020. #> 2 theta     0.255  0.240 0.127 0.130  0.0773  0.491  1.00     557.     616.  # Check sampling diagnostics fit_mcmc$diagnostic_summary() #> $num_divergent #> [1] 0 0 #>  #> $num_max_treedepth #> [1] 0 0 #>  #> $ebfmi #> [1] 1.114870 1.030279 #>   # Get posterior draws draws <- fit_mcmc$draws() print(draws) #> # A draws_array: 1000 iterations, 2 chains, and 2 variables #> , , variable = lp__ #>  #>          chain #> iteration    1    2 #>         1 -7.0 -6.8 #>         2 -7.9 -6.9 #>         3 -7.4 -6.9 #>         4 -6.7 -6.8 #>         5 -6.9 -6.8 #>  #> , , variable = theta #>  #>          chain #> iteration    1    2 #>         1 0.17 0.28 #>         2 0.46 0.19 #>         3 0.41 0.19 #>         4 0.25 0.28 #>         5 0.18 0.23 #>  #> # ... with 995 more iterations  # Convert to data frame using posterior::as_draws_df as_draws_df(draws) #> # A draws_df: 1000 iterations, 2 chains, and 2 variables #>    lp__ theta #> 1  -7.0  0.17 #> 2  -7.9  0.46 #> 3  -7.4  0.41 #> 4  -6.7  0.25 #> 5  -6.9  0.18 #> 6  -6.9  0.33 #> 7  -7.2  0.15 #> 8  -6.8  0.29 #> 9  -6.8  0.24 #> 10 -6.8  0.24 #> # ... with 1990 more draws #> # ... hidden reserved variables {'.chain', '.iteration', '.draw'}  # Plot posterior using bayesplot (ggplot2) mcmc_hist(fit_mcmc$draws(\"theta\")) #> `stat_bin()` using `bins = 30`. Pick better value `binwidth`.   # Run 'optimize' method to get a point estimate (default is Stan's LBFGS algorithm) # and also demonstrate specifying data as a path to a file instead of a list my_data_file <- file.path(cmdstan_path(), \"examples/bernoulli/bernoulli.data.json\") fit_optim <- mod$optimize(data = my_data_file, seed = 123) #> Initial log joint probability = -16.144  #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes   #>        6      -5.00402   0.000246518   8.73164e-07           1           1        9     #> Optimization terminated normally:   #>   Convergence detected: relative gradient magnitude is below tolerance  #> Finished in  0.1 seconds. fit_optim$summary() #> # A tibble: 2 × 2 #>   variable estimate #>   <chr>       <dbl> #> 1 lp__       -5.00  #> 2 theta       0.200  # Run 'optimize' again with 'jacobian=TRUE' and then draw from Laplace approximation # to the posterior fit_optim <- mod$optimize(data = my_data_file, jacobian = TRUE) #> Initial log joint probability = -11.4115  #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes   #>        5      -6.74802    0.00104032   1.63334e-05           1           1        8     #> Optimization terminated normally:   #>   Convergence detected: relative gradient magnitude is below tolerance  #> Finished in  0.1 seconds. fit_laplace <- mod$laplace(data = my_data_file, mode = fit_optim, draws = 2000) #> Calculating Hessian  #> Calculating inverse of Cholesky factor  #> Generating draws  #> iteration: 0  #> iteration: 100  #> iteration: 200  #> iteration: 300  #> iteration: 400  #> iteration: 500  #> iteration: 600  #> iteration: 700  #> iteration: 800  #> iteration: 900  #> iteration: 1000  #> iteration: 1100  #> iteration: 1200  #> iteration: 1300  #> iteration: 1400  #> iteration: 1500  #> iteration: 1600  #> iteration: 1700  #> iteration: 1800  #> iteration: 1900  #> Finished in  0.1 seconds. fit_laplace$summary() #> # A tibble: 3 × 7 #>   variable      mean median    sd   mad      q5      q95 #>   <chr>        <dbl>  <dbl> <dbl> <dbl>   <dbl>    <dbl> #> 1 lp__        -7.23  -6.98  0.685 0.315 -8.55   -6.75    #> 2 lp_approx__ -0.500 -0.228 0.731 0.313 -1.87   -0.00129 #> 3 theta        0.265  0.249 0.121 0.121  0.0994  0.491    # Run 'variational' method to use ADVI to approximate posterior fit_vb <- mod$variational(data = stan_data, seed = 123) #> ------------------------------------------------------------  #> EXPERIMENTAL ALGORITHM:  #>   This procedure has not been thoroughly tested and may be unstable  #>   or buggy. The interface is subject to change.  #> ------------------------------------------------------------  #> Gradient evaluation took 2e-06 seconds  #> 1000 transitions using 10 leapfrog steps per transition would take 0.02 seconds.  #> Adjust your expectations accordingly!  #> Begin eta adaptation.  #> Iteration:   1 / 250 [  0%]  (Adaptation)  #> Iteration:  50 / 250 [ 20%]  (Adaptation)  #> Iteration: 100 / 250 [ 40%]  (Adaptation)  #> Iteration: 150 / 250 [ 60%]  (Adaptation)  #> Iteration: 200 / 250 [ 80%]  (Adaptation)  #> Success! Found best value [eta = 1] earlier than expected.  #> Begin stochastic gradient ascent.  #>   iter             ELBO   delta_ELBO_mean   delta_ELBO_med   notes   #>    100           -6.164             1.000            1.000  #>    200           -6.225             0.505            1.000  #>    300           -6.186             0.339            0.010   MEDIAN ELBO CONVERGED  #> Drawing a sample of size 1000 from the approximate posterior...   #> COMPLETED.  #> Finished in  0.1 seconds. fit_vb$summary() #> # A tibble: 3 × 7 #>   variable      mean median    sd   mad     q5      q95 #>   <chr>        <dbl>  <dbl> <dbl> <dbl>  <dbl>    <dbl> #> 1 lp__        -7.14  -6.93  0.528 0.247 -8.21  -6.75    #> 2 lp_approx__ -0.520 -0.244 0.740 0.326 -1.90  -0.00227 #> 3 theta        0.251  0.236 0.107 0.108  0.100  0.446   mcmc_hist(fit_vb$draws(\"theta\")) #> `stat_bin()` using `bins = 30`. Pick better value `binwidth`.   # Run 'pathfinder' method, a new alternative to the variational method fit_pf <- mod$pathfinder(data = stan_data, seed = 123) #> Path [1] :Initial log joint density = -18.273334  #> Path [1] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      7.082e-04   1.432e-05    1.000e+00  1.000e+00       156 -6.216e+00 -6.145e+00                    #> Path [1] :Best Iter: [5] ELBO (-6.145070) evaluations: (156)  #> Path [2] :Initial log joint density = -19.192715  #> Path [2] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.015e-04   2.228e-06    1.000e+00  1.000e+00       156 -6.170e+00 -6.223e+00                    #> Path [2] :Best Iter: [2] ELBO (-6.170358) evaluations: (156)  #> Path [3] :Initial log joint density = -6.774820  #> Path [3] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               4      -6.748e+00      1.137e-04   2.596e-07    1.000e+00  1.000e+00       123 -6.243e+00 -6.178e+00                    #> Path [3] :Best Iter: [4] ELBO (-6.177909) evaluations: (123)  #> Path [4] :Initial log joint density = -7.949193  #> Path [4] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.145e-04   1.301e-06    1.000e+00  1.000e+00       156 -6.235e+00 -6.197e+00                    #> Path [4] :Best Iter: [5] ELBO (-6.197118) evaluations: (156)  #> Finished in  0.1 seconds. fit_pf$summary() #> # A tibble: 4 × 7 #>   variable      mean median    sd   mad      q5    q95 #>   <chr>        <dbl>  <dbl> <dbl> <dbl>   <dbl>  <dbl> #> 1 lp_approx__ -1.07  -0.724 0.871 0.306 -2.82   -0.451 #> 2 path__       2.46   2     1.12  1.48   1       4     #> 3 lp__        -7.26  -6.97  0.720 0.304 -8.77   -6.75  #> 4 theta        0.258  0.241 0.121 0.119  0.0840  0.475 mcmc_hist(fit_pf$draws(\"theta\")) #> `stat_bin()` using `bins = 30`. Pick better value `binwidth`.   # Run 'pathfinder' again with more paths, fewer draws per path, # better covariance approximation, and fewer LBFGSs iterations fit_pf <- mod$pathfinder(data = stan_data, num_paths=10, single_path_draws=40,                          history_size=50, max_lbfgs_iters=100) #> Warning: Number of PSIS draws is larger than the total number of draws returned by the single Pathfinders. This is likely unintentional and leads to re-sampling from the same draws.  #> Path [1] :Initial log joint density = -7.541509  #> Path [1] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      1.220e-04   5.203e-07    1.000e+00  1.000e+00       156 -6.228e+00 -6.188e+00                    #> Path [1] :Best Iter: [5] ELBO (-6.187606) evaluations: (156)  #> Path [2] :Initial log joint density = -6.951324  #> Path [2] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               4      -6.748e+00      1.680e-03   2.312e-05    1.000e+00  1.000e+00       123 -6.234e+00 -6.217e+00                    #> Path [2] :Best Iter: [4] ELBO (-6.217454) evaluations: (123)  #> Path [3] :Initial log joint density = -8.444499  #> Path [3] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      3.020e-04   2.291e-06    1.000e+00  1.000e+00       156 -6.195e+00 -6.212e+00                    #> Path [3] :Best Iter: [3] ELBO (-6.195295) evaluations: (156)  #> Path [4] :Initial log joint density = -7.136182  #> Path [4] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      1.564e-04   1.111e-07    1.000e+00  1.000e+00       156 -6.233e+00 -6.227e+00                    #> Path [4] :Best Iter: [5] ELBO (-6.226708) evaluations: (156)  #> Path [5] :Initial log joint density = -13.899523  #> Path [5] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      1.939e-03   5.211e-05    1.000e+00  1.000e+00       156 -6.184e+00 -6.201e+00                    #> Path [5] :Best Iter: [4] ELBO (-6.183815) evaluations: (156)  #> Path [6] :Initial log joint density = -14.787394  #> Path [6] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.041e-03   5.986e-05    1.000e+00  1.000e+00       156 -6.177e+00 -6.214e+00                    #> Path [6] :Best Iter: [4] ELBO (-6.176573) evaluations: (156)  #> Path [7] :Initial log joint density = -7.325251  #> Path [7] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               4      -6.748e+00      5.480e-03   1.650e-04    1.000e+00  1.000e+00       123 -6.231e+00 -6.128e+00                    #> Path [7] :Best Iter: [4] ELBO (-6.127784) evaluations: (123)  #> Path [8] :Initial log joint density = -14.766564  #> Path [8] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.041e-03   5.977e-05    1.000e+00  1.000e+00       156 -6.220e+00 -6.209e+00                    #> Path [8] :Best Iter: [5] ELBO (-6.209131) evaluations: (156)  #> Path [9] :Initial log joint density = -6.870337  #> Path [9] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               4      -6.748e+00      1.289e-04   1.880e-05    9.410e-01  9.410e-01       123 -6.258e+00 -6.238e+00                    #> Path [9] :Best Iter: [4] ELBO (-6.238179) evaluations: (123)  #> Path [10] :Initial log joint density = -7.310036  #> Path [10] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               4      -6.748e+00      5.332e-03   1.577e-04    1.000e+00  1.000e+00       123 -6.304e+00 -6.212e+00                    #> Path [10] :Best Iter: [4] ELBO (-6.211510) evaluations: (123)  #> Pareto k value (0.74) is greater than 0.7. Importance resampling was not able to improve the approximation, which may indicate that the approximation itself is poor.  #> Finished in  0.1 seconds.  # Specifying initial values as a function fit_mcmc_w_init_fun <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   refresh = 0,   init = function() list(theta = runif(1)) ) #> Running MCMC with 2 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.2 seconds. #>  fit_mcmc_w_init_fun_2 <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   refresh = 0,   init = function(chain_id) {     # silly but demonstrates optional use of chain_id     list(theta = 1 / (chain_id + 1))   } ) #> Running MCMC with 2 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.2 seconds. #>  fit_mcmc_w_init_fun_2$init() #> [[1]] #> [[1]]$theta #> [1] 0.5 #>  #>  #> [[2]] #> [[2]]$theta #> [1] 0.3333333 #>  #>   # Specifying initial values as a list of lists fit_mcmc_w_init_list <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   refresh = 0,   init = list(     list(theta = 0.75), # chain 1     list(theta = 0.25)  # chain 2   ) ) #> Running MCMC with 2 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.2 seconds. #>  fit_optim_w_init_list <- mod$optimize(   data = stan_data,   seed = 123,   init = list(     list(theta = 0.75)   ) ) #> Initial log joint probability = -11.6657  #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes   #>        6      -5.00402   0.000237915   9.55309e-07           1           1        9     #> Optimization terminated normally:   #>   Convergence detected: relative gradient magnitude is below tolerance  #> Finished in  0.1 seconds. fit_optim_w_init_list$init() #> [[1]] #> [[1]]$theta #> [1] 0.75 #>  #>  # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstanr-package.html","id":null,"dir":"Reference","previous_headings":"","what":"CmdStanR: the R interface to CmdStan — cmdstanr-package","title":"CmdStanR: the R interface to CmdStan — cmdstanr-package","text":"Stan Development Team CmdStanR: R interface CmdStan.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstanr-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"CmdStanR: the R interface to CmdStan — cmdstanr-package","text":"CmdStanR (cmdstanr package) interface Stan (mc-stan.org) R users. provides necessary objects functions compile Stan program run Stan's algorithms R via CmdStan, shell interface Stan (mc-stan.org/users/interfaces/cmdstan).","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstanr-package.html","id":"different-ways-of-interfacing-with-stan-s-c-","dir":"Reference","previous_headings":"","what":"Different ways of interfacing with Stan’s C++","title":"CmdStanR: the R interface to CmdStan — cmdstanr-package","text":"RStan interface (rstan package) -memory interface Stan relies R packages like Rcpp inline call C++ code R. hand, CmdStanR interface directly call C++ code R, instead relying CmdStan interface behind scenes compilation, running algorithms, writing results output files.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstanr-package.html","id":"advantages-of-rstan","dir":"Reference","previous_headings":"","what":"Advantages of RStan","title":"CmdStanR: the R interface to CmdStan — cmdstanr-package","text":"Allows developers distribute R packages pre-compiled Stan programs (like rstanarm) CRAN. (Note: 2023, can mostly achieved CmdStanR well. See Developing using CmdStanR.) Avoids use R6 classes, may result familiar syntax many R users. CRAN binaries available Mac Windows.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstanr-package.html","id":"advantages-of-cmdstanr","dir":"Reference","previous_headings":"","what":"Advantages of CmdStanR","title":"CmdStanR: the R interface to CmdStan — cmdstanr-package","text":"Compatible latest versions Stan. Keeping Stan releases complicated RStan, often requiring non-trivial changes rstan package new CRAN releases rstan StanHeaders. CmdStanR latest improvements Stan available R immediately updating CmdStan using cmdstanr::install_cmdstan(). Running Stan via external processes results fewer unexpected crashes, especially RStudio. Less memory overhead. permissive license. RStan uses GPL-3 license license CmdStanR BSD-3, bit permissive license used CmdStan Stan C++ source code.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstanr-package.html","id":"getting-started","dir":"Reference","previous_headings":"","what":"Getting started","title":"CmdStanR: the R interface to CmdStan — cmdstanr-package","text":"CmdStanR requires working version CmdStan. already CmdStan installed see cmdstan_model() get started, otherwise see install_cmdstan() install CmdStan. vignette Getting started CmdStanR demonstrates basic functionality package. list global options see cmdstanr_global_options.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstanr-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"CmdStanR: the R interface to CmdStan — cmdstanr-package","text":"Maintainer: Andrew Johnson andrew.johnson@arjohnsonau.com (ORCID) Authors: Jonah Gabry jgabry@gmail.com Rok Češnovar rok.cesnovar@fri.uni-lj.si Steve Bronder contributors: Ben Bales [contributor] Mitzi Morris [contributor] Mikhail Popov [contributor] Mike Lawrence [contributor] William Michael Landau .landau@gmail.com (ORCID) [contributor] Jacob Socolar [contributor] Martin Modrák [contributor] Ven Popov [contributor]","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstanr-package.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CmdStanR: the R interface to CmdStan — cmdstanr-package","text":"","code":"# \\dontrun{ library(cmdstanr) library(posterior) library(bayesplot) color_scheme_set(\"brightblue\")  # Set path to CmdStan # (Note: if you installed CmdStan via install_cmdstan() with default settings # then setting the path is unnecessary but the default below should still work. # Otherwise use the `path` argument to specify the location of your # CmdStan installation.) set_cmdstan_path(path = NULL) #> CmdStan path set to: /home/runner/.cmdstan/cmdstan-2.37.0  # Create a CmdStanModel object from a Stan program, # here using the example model that comes with CmdStan file <- file.path(cmdstan_path(), \"examples/bernoulli/bernoulli.stan\") mod <- cmdstan_model(file) mod$print() #> data { #>   int<lower=0> N; #>   array[N] int<lower=0, upper=1> y; #> } #> parameters { #>   real<lower=0, upper=1> theta; #> } #> model { #>   theta ~ beta(1, 1); // uniform prior on interval 0,1 #>   y ~ bernoulli(theta); #> } # Print with line numbers. This can be set globally using the # `cmdstanr_print_line_numbers` option. mod$print(line_numbers = TRUE) #>  1: data { #>  2:   int<lower=0> N; #>  3:   array[N] int<lower=0, upper=1> y; #>  4: } #>  5: parameters { #>  6:   real<lower=0, upper=1> theta; #>  7: } #>  8: model { #>  9:   theta ~ beta(1, 1); // uniform prior on interval 0,1 #> 10:   y ~ bernoulli(theta); #> 11: }  # Data as a named list (like RStan) stan_data <- list(N = 10, y = c(0,1,0,0,0,0,0,0,0,1))  # Run MCMC using the 'sample' method fit_mcmc <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   parallel_chains = 2 ) #> Running MCMC with 2 parallel chains... #>  #> Chain 1 Iteration:    1 / 2000 [  0%]  (Warmup)  #> Chain 1 Iteration:  100 / 2000 [  5%]  (Warmup)  #> Chain 1 Iteration:  200 / 2000 [ 10%]  (Warmup)  #> Chain 1 Iteration:  300 / 2000 [ 15%]  (Warmup)  #> Chain 1 Iteration:  400 / 2000 [ 20%]  (Warmup)  #> Chain 1 Iteration:  500 / 2000 [ 25%]  (Warmup)  #> Chain 1 Iteration:  600 / 2000 [ 30%]  (Warmup)  #> Chain 1 Iteration:  700 / 2000 [ 35%]  (Warmup)  #> Chain 1 Iteration:  800 / 2000 [ 40%]  (Warmup)  #> Chain 1 Iteration:  900 / 2000 [ 45%]  (Warmup)  #> Chain 1 Iteration: 1000 / 2000 [ 50%]  (Warmup)  #> Chain 1 Iteration: 1001 / 2000 [ 50%]  (Sampling)  #> Chain 1 Iteration: 1100 / 2000 [ 55%]  (Sampling)  #> Chain 1 Iteration: 1200 / 2000 [ 60%]  (Sampling)  #> Chain 1 Iteration: 1300 / 2000 [ 65%]  (Sampling)  #> Chain 1 Iteration: 1400 / 2000 [ 70%]  (Sampling)  #> Chain 1 Iteration: 1500 / 2000 [ 75%]  (Sampling)  #> Chain 1 Iteration: 1600 / 2000 [ 80%]  (Sampling)  #> Chain 1 Iteration: 1700 / 2000 [ 85%]  (Sampling)  #> Chain 1 Iteration: 1800 / 2000 [ 90%]  (Sampling)  #> Chain 1 Iteration: 1900 / 2000 [ 95%]  (Sampling)  #> Chain 1 Iteration: 2000 / 2000 [100%]  (Sampling)  #> Chain 2 Iteration:    1 / 2000 [  0%]  (Warmup)  #> Chain 2 Iteration:  100 / 2000 [  5%]  (Warmup)  #> Chain 2 Iteration:  200 / 2000 [ 10%]  (Warmup)  #> Chain 2 Iteration:  300 / 2000 [ 15%]  (Warmup)  #> Chain 2 Iteration:  400 / 2000 [ 20%]  (Warmup)  #> Chain 2 Iteration:  500 / 2000 [ 25%]  (Warmup)  #> Chain 2 Iteration:  600 / 2000 [ 30%]  (Warmup)  #> Chain 2 Iteration:  700 / 2000 [ 35%]  (Warmup)  #> Chain 2 Iteration:  800 / 2000 [ 40%]  (Warmup)  #> Chain 2 Iteration:  900 / 2000 [ 45%]  (Warmup)  #> Chain 2 Iteration: 1000 / 2000 [ 50%]  (Warmup)  #> Chain 2 Iteration: 1001 / 2000 [ 50%]  (Sampling)  #> Chain 2 Iteration: 1100 / 2000 [ 55%]  (Sampling)  #> Chain 2 Iteration: 1200 / 2000 [ 60%]  (Sampling)  #> Chain 2 Iteration: 1300 / 2000 [ 65%]  (Sampling)  #> Chain 2 Iteration: 1400 / 2000 [ 70%]  (Sampling)  #> Chain 2 Iteration: 1500 / 2000 [ 75%]  (Sampling)  #> Chain 2 Iteration: 1600 / 2000 [ 80%]  (Sampling)  #> Chain 2 Iteration: 1700 / 2000 [ 85%]  (Sampling)  #> Chain 2 Iteration: 1800 / 2000 [ 90%]  (Sampling)  #> Chain 2 Iteration: 1900 / 2000 [ 95%]  (Sampling)  #> Chain 2 Iteration: 2000 / 2000 [100%]  (Sampling)  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.1 seconds. #>   # Use 'posterior' package for summaries fit_mcmc$summary() #> # A tibble: 2 × 10 #>   variable   mean median    sd   mad      q5    q95  rhat ess_bulk ess_tail #>   <chr>     <dbl>  <dbl> <dbl> <dbl>   <dbl>  <dbl> <dbl>    <dbl>    <dbl> #> 1 lp__     -7.32  -7.02  0.799 0.355 -8.89   -6.75   1.00     819.    1020. #> 2 theta     0.255  0.240 0.127 0.130  0.0773  0.491  1.00     557.     616.  # Check sampling diagnostics fit_mcmc$diagnostic_summary() #> $num_divergent #> [1] 0 0 #>  #> $num_max_treedepth #> [1] 0 0 #>  #> $ebfmi #> [1] 1.114870 1.030279 #>   # Get posterior draws draws <- fit_mcmc$draws() print(draws) #> # A draws_array: 1000 iterations, 2 chains, and 2 variables #> , , variable = lp__ #>  #>          chain #> iteration    1    2 #>         1 -7.0 -6.8 #>         2 -7.9 -6.9 #>         3 -7.4 -6.9 #>         4 -6.7 -6.8 #>         5 -6.9 -6.8 #>  #> , , variable = theta #>  #>          chain #> iteration    1    2 #>         1 0.17 0.28 #>         2 0.46 0.19 #>         3 0.41 0.19 #>         4 0.25 0.28 #>         5 0.18 0.23 #>  #> # ... with 995 more iterations  # Convert to data frame using posterior::as_draws_df as_draws_df(draws) #> # A draws_df: 1000 iterations, 2 chains, and 2 variables #>    lp__ theta #> 1  -7.0  0.17 #> 2  -7.9  0.46 #> 3  -7.4  0.41 #> 4  -6.7  0.25 #> 5  -6.9  0.18 #> 6  -6.9  0.33 #> 7  -7.2  0.15 #> 8  -6.8  0.29 #> 9  -6.8  0.24 #> 10 -6.8  0.24 #> # ... with 1990 more draws #> # ... hidden reserved variables {'.chain', '.iteration', '.draw'}  # Plot posterior using bayesplot (ggplot2) mcmc_hist(fit_mcmc$draws(\"theta\")) #> `stat_bin()` using `bins = 30`. Pick better value `binwidth`.   # Run 'optimize' method to get a point estimate (default is Stan's LBFGS algorithm) # and also demonstrate specifying data as a path to a file instead of a list my_data_file <- file.path(cmdstan_path(), \"examples/bernoulli/bernoulli.data.json\") fit_optim <- mod$optimize(data = my_data_file, seed = 123) #> Initial log joint probability = -16.144  #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes   #>        6      -5.00402   0.000246518   8.73164e-07           1           1        9     #> Optimization terminated normally:   #>   Convergence detected: relative gradient magnitude is below tolerance  #> Finished in  0.1 seconds. fit_optim$summary() #> # A tibble: 2 × 2 #>   variable estimate #>   <chr>       <dbl> #> 1 lp__       -5.00  #> 2 theta       0.200  # Run 'optimize' again with 'jacobian=TRUE' and then draw from Laplace approximation # to the posterior fit_optim <- mod$optimize(data = my_data_file, jacobian = TRUE) #> Initial log joint probability = -10.7892  #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes   #>        5      -6.74802   0.000877031   1.25264e-05           1           1        8     #> Optimization terminated normally:   #>   Convergence detected: relative gradient magnitude is below tolerance  #> Finished in  0.1 seconds. fit_laplace <- mod$laplace(data = my_data_file, mode = fit_optim, draws = 2000) #> Calculating Hessian  #> Calculating inverse of Cholesky factor  #> Generating draws  #> iteration: 0  #> iteration: 100  #> iteration: 200  #> iteration: 300  #> iteration: 400  #> iteration: 500  #> iteration: 600  #> iteration: 700  #> iteration: 800  #> iteration: 900  #> iteration: 1000  #> iteration: 1100  #> iteration: 1200  #> iteration: 1300  #> iteration: 1400  #> iteration: 1500  #> iteration: 1600  #> iteration: 1700  #> iteration: 1800  #> iteration: 1900  #> Finished in  0.1 seconds. fit_laplace$summary() #> # A tibble: 3 × 7 #>   variable      mean median    sd   mad     q5      q95 #>   <chr>        <dbl>  <dbl> <dbl> <dbl>  <dbl>    <dbl> #> 1 lp__        -7.23  -6.96  0.696 0.302 -8.52  -6.75    #> 2 lp_approx__ -0.497 -0.217 0.721 0.302 -1.85  -0.00126 #> 3 theta        0.266  0.248 0.121 0.121  0.101  0.488    # Run 'variational' method to use ADVI to approximate posterior fit_vb <- mod$variational(data = stan_data, seed = 123) #> ------------------------------------------------------------  #> EXPERIMENTAL ALGORITHM:  #>   This procedure has not been thoroughly tested and may be unstable  #>   or buggy. The interface is subject to change.  #> ------------------------------------------------------------  #> Gradient evaluation took 2e-06 seconds  #> 1000 transitions using 10 leapfrog steps per transition would take 0.02 seconds.  #> Adjust your expectations accordingly!  #> Begin eta adaptation.  #> Iteration:   1 / 250 [  0%]  (Adaptation)  #> Iteration:  50 / 250 [ 20%]  (Adaptation)  #> Iteration: 100 / 250 [ 40%]  (Adaptation)  #> Iteration: 150 / 250 [ 60%]  (Adaptation)  #> Iteration: 200 / 250 [ 80%]  (Adaptation)  #> Success! Found best value [eta = 1] earlier than expected.  #> Begin stochastic gradient ascent.  #>   iter             ELBO   delta_ELBO_mean   delta_ELBO_med   notes   #>    100           -6.164             1.000            1.000  #>    200           -6.225             0.505            1.000  #>    300           -6.186             0.339            0.010   MEDIAN ELBO CONVERGED  #> Drawing a sample of size 1000 from the approximate posterior...   #> COMPLETED.  #> Finished in  0.1 seconds. fit_vb$summary() #> # A tibble: 3 × 7 #>   variable      mean median    sd   mad     q5      q95 #>   <chr>        <dbl>  <dbl> <dbl> <dbl>  <dbl>    <dbl> #> 1 lp__        -7.14  -6.93  0.528 0.247 -8.21  -6.75    #> 2 lp_approx__ -0.520 -0.244 0.740 0.326 -1.90  -0.00227 #> 3 theta        0.251  0.236 0.107 0.108  0.100  0.446   mcmc_hist(fit_vb$draws(\"theta\")) #> `stat_bin()` using `bins = 30`. Pick better value `binwidth`.   # Run 'pathfinder' method, a new alternative to the variational method fit_pf <- mod$pathfinder(data = stan_data, seed = 123) #> Path [1] :Initial log joint density = -18.273334  #> Path [1] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      7.082e-04   1.432e-05    1.000e+00  1.000e+00       156 -6.216e+00 -6.145e+00                    #> Path [1] :Best Iter: [5] ELBO (-6.145070) evaluations: (156)  #> Path [2] :Initial log joint density = -19.192715  #> Path [2] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.015e-04   2.228e-06    1.000e+00  1.000e+00       156 -6.170e+00 -6.223e+00                    #> Path [2] :Best Iter: [2] ELBO (-6.170358) evaluations: (156)  #> Path [3] :Initial log joint density = -6.774820  #> Path [3] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               4      -6.748e+00      1.137e-04   2.596e-07    1.000e+00  1.000e+00       123 -6.243e+00 -6.178e+00                    #> Path [3] :Best Iter: [4] ELBO (-6.177909) evaluations: (123)  #> Path [4] :Initial log joint density = -7.949193  #> Path [4] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.145e-04   1.301e-06    1.000e+00  1.000e+00       156 -6.235e+00 -6.197e+00                    #> Path [4] :Best Iter: [5] ELBO (-6.197118) evaluations: (156)  #> Finished in  0.1 seconds. fit_pf$summary() #> # A tibble: 4 × 7 #>   variable      mean median    sd   mad      q5    q95 #>   <chr>        <dbl>  <dbl> <dbl> <dbl>   <dbl>  <dbl> #> 1 lp_approx__ -1.07  -0.724 0.871 0.306 -2.82   -0.451 #> 2 path__       2.46   2     1.12  1.48   1       4     #> 3 lp__        -7.26  -6.97  0.720 0.304 -8.77   -6.75  #> 4 theta        0.258  0.241 0.121 0.119  0.0840  0.475 mcmc_hist(fit_pf$draws(\"theta\")) #> `stat_bin()` using `bins = 30`. Pick better value `binwidth`.   # Run 'pathfinder' again with more paths, fewer draws per path, # better covariance approximation, and fewer LBFGSs iterations fit_pf <- mod$pathfinder(data = stan_data, num_paths=10, single_path_draws=40,                          history_size=50, max_lbfgs_iters=100) #> Warning: Number of PSIS draws is larger than the total number of draws returned by the single Pathfinders. This is likely unintentional and leads to re-sampling from the same draws.  #> Path [1] :Initial log joint density = -7.609829  #> Path [1] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      1.379e-04   6.344e-07    1.000e+00  1.000e+00       156 -6.153e+00 -6.199e+00                    #> Path [1] :Best Iter: [3] ELBO (-6.152927) evaluations: (156)  #> Path [2] :Initial log joint density = -14.720590  #> Path [2] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.040e-03   5.956e-05    1.000e+00  1.000e+00       156 -6.186e+00 -6.266e+00                    #> Path [2] :Best Iter: [4] ELBO (-6.186135) evaluations: (156)  #> Path [3] :Initial log joint density = -7.694812  #> Path [3] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      1.576e-04   7.882e-07    1.000e+00  1.000e+00       156 -6.225e+00 -6.220e+00                    #> Path [3] :Best Iter: [5] ELBO (-6.219772) evaluations: (156)  #> Path [4] :Initial log joint density = -13.108697  #> Path [4] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      1.712e-03   4.047e-05    1.000e+00  1.000e+00       156 -6.192e+00 -6.292e+00                    #> Path [4] :Best Iter: [3] ELBO (-6.191668) evaluations: (156)  #> Path [5] :Initial log joint density = -9.991863  #> Path [5] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      6.311e-04   7.501e-06    1.000e+00  1.000e+00       156 -6.196e+00 -6.269e+00                    #> Path [5] :Best Iter: [3] ELBO (-6.195823) evaluations: (156)  #> Path [6] :Initial log joint density = -7.141113  #> Path [6] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               4      -6.748e+00      3.637e-03   8.363e-05    1.000e+00  1.000e+00       123 -6.227e+00 -6.246e+00                    #> Path [6] :Best Iter: [3] ELBO (-6.227413) evaluations: (123)  #> Path [7] :Initial log joint density = -8.726749  #> Path [7] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      3.319e-04   2.697e-06    1.000e+00  1.000e+00       156 -6.242e+00 -6.185e+00                    #> Path [7] :Best Iter: [5] ELBO (-6.185500) evaluations: (156)  #> Path [8] :Initial log joint density = -6.755995  #> Path [8] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               3      -6.748e+00      9.827e-04   1.030e-05    9.880e-01  9.880e-01        91 -6.179e+00 -6.227e+00                    #> Path [8] :Best Iter: [2] ELBO (-6.178984) evaluations: (91)  #> Path [9] :Initial log joint density = -6.748537  #> Path [9] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               3      -6.748e+00      8.690e-05   8.072e-07    1.000e+00  1.000e+00        91 -6.207e+00 -6.185e+00                    #> Path [9] :Best Iter: [3] ELBO (-6.185087) evaluations: (91)  #> Path [10] :Initial log joint density = -13.774653  #> Path [10] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      1.911e-03   5.049e-05    1.000e+00  1.000e+00       156 -6.169e+00 -6.197e+00                    #> Path [10] :Best Iter: [4] ELBO (-6.169222) evaluations: (156)  #> Finished in  0.1 seconds.  # Specifying initial values as a function fit_mcmc_w_init_fun <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   refresh = 0,   init = function() list(theta = runif(1)) ) #> Running MCMC with 2 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.2 seconds. #>  fit_mcmc_w_init_fun_2 <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   refresh = 0,   init = function(chain_id) {     # silly but demonstrates optional use of chain_id     list(theta = 1 / (chain_id + 1))   } ) #> Running MCMC with 2 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.2 seconds. #>  fit_mcmc_w_init_fun_2$init() #> [[1]] #> [[1]]$theta #> [1] 0.5 #>  #>  #> [[2]] #> [[2]]$theta #> [1] 0.3333333 #>  #>   # Specifying initial values as a list of lists fit_mcmc_w_init_list <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   refresh = 0,   init = list(     list(theta = 0.75), # chain 1     list(theta = 0.25)  # chain 2   ) ) #> Running MCMC with 2 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.3 seconds. #>  fit_optim_w_init_list <- mod$optimize(   data = stan_data,   seed = 123,   init = list(     list(theta = 0.75)   ) ) #> Initial log joint probability = -11.6657  #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes   #>        6      -5.00402   0.000237915   9.55309e-07           1           1        9     #> Optimization terminated normally:   #>   Convergence detected: relative gradient magnitude is below tolerance  #> Finished in  0.1 seconds. fit_optim_w_init_list$init() #> [[1]] #> [[1]]$theta #> [1] 0.75 #>  #>  # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstanr_example.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit models for use in examples — cmdstanr_example","title":"Fit models for use in examples — cmdstanr_example","text":"Fit models use examples","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstanr_example.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit models for use in examples — cmdstanr_example","text":"","code":"cmdstanr_example(   example = c(\"logistic\", \"schools\", \"schools_ncp\"),   method = c(\"sample\", \"optimize\", \"laplace\", \"variational\", \"pathfinder\", \"diagnose\"),   ...,   quiet = TRUE,   force_recompile = getOption(\"cmdstanr_force_recompile\", default = FALSE) )  print_example_program(example = c(\"logistic\", \"schools\", \"schools_ncp\"))"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstanr_example.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit models for use in examples — cmdstanr_example","text":"example (string) name example. currently available examples \"logistic\": logistic regression intercept 3 predictors. \"schools\": -called \"eight schools\" model, hierarchical meta-analysis. Fitting model result warnings divergences. \"schools_ncp\": non-centered parameterization \"eight schools\" model fixes problem divergences. print Stan code given example use print_example_program(example). method (string) fitting method used? default \"sample\" method (MCMC). ... Arguments passed chosen method. See help pages individual methods details. quiet (logical) TRUE (default) fitting model wrapped utils::capture.output(). force_recompile Passed $compile() method.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstanr_example.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit models for use in examples — cmdstanr_example","text":"fitted model object returned selected method.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstanr_example.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit models for use in examples — cmdstanr_example","text":"","code":"# \\dontrun{ print_example_program(\"logistic\") #> data { #>   int<lower=0> N; #>   int<lower=0> K; #>   array[N] int<lower=0, upper=1> y; #>   matrix[N, K] X; #> } #> parameters { #>   real alpha; #>   vector[K] beta; #> } #> model { #>   target += normal_lpdf(alpha | 0, 1); #>   target += normal_lpdf(beta | 0, 1); #>   target += bernoulli_logit_glm_lpmf(y | X, alpha, beta); #> } #> generated quantities { #>   vector[N] log_lik; #>   for (n in 1 : N) { #>     log_lik[n] = bernoulli_logit_lpmf(y[n] | alpha + X[n] * beta); #>   } #> } fit_logistic_mcmc <- cmdstanr_example(\"logistic\", chains = 2) fit_logistic_mcmc$summary() #> # A tibble: 105 × 10 #>    variable      mean  median    sd    mad         q5      q95  rhat ess_bulk #>    <chr>        <dbl>   <dbl> <dbl>  <dbl>      <dbl>    <dbl> <dbl>    <dbl> #>  1 lp__       -66.0   -65.7   1.45  1.28   -68.8      -64.3    0.999    1047. #>  2 alpha        0.374   0.374 0.223 0.216   -0.000371   0.737  1.000    1996. #>  3 beta[1]     -0.679  -0.670 0.261 0.259   -1.12      -0.266  1.00     2471. #>  4 beta[2]     -0.280  -0.279 0.219 0.217   -0.657      0.0677 1.000    2142. #>  5 beta[3]      0.689   0.686 0.265 0.274    0.257      1.11   1.00     1976. #>  6 log_lik[1]  -0.518  -0.512 0.101 0.0951  -0.699     -0.360  1.000    2111. #>  7 log_lik[2]  -0.395  -0.377 0.141 0.131   -0.646     -0.192  1.000    2157. #>  8 log_lik[3]  -0.501  -0.471 0.219 0.202   -0.910     -0.206  1.00     2228. #>  9 log_lik[4]  -0.442  -0.427 0.150 0.150   -0.707     -0.231  1.000    1983. #> 10 log_lik[5]  -1.18   -1.16  0.286 0.283   -1.68      -0.750  1.00     2106. #> # ℹ 95 more rows #> # ℹ 1 more variable: ess_tail <dbl>  fit_logistic_optim <- cmdstanr_example(\"logistic\", method = \"optimize\") fit_logistic_optim$summary() #> # A tibble: 105 × 2 #>    variable   estimate #>    <chr>         <dbl> #>  1 lp__        -63.9   #>  2 alpha         0.364 #>  3 beta[1]      -0.632 #>  4 beta[2]      -0.259 #>  5 beta[3]       0.649 #>  6 log_lik[1]   -0.515 #>  7 log_lik[2]   -0.394 #>  8 log_lik[3]   -0.469 #>  9 log_lik[4]   -0.442 #> 10 log_lik[5]   -1.14  #> # ℹ 95 more rows  fit_logistic_vb <- cmdstanr_example(\"logistic\", method = \"variational\") fit_logistic_vb$summary() #> # A tibble: 106 × 7 #>    variable       mean  median    sd    mad       q5      q95 #>    <chr>         <dbl>   <dbl> <dbl>  <dbl>    <dbl>    <dbl> #>  1 lp__        -66.1   -65.7   1.50  1.28   -68.9    -64.3    #>  2 lp_approx__  -1.98   -1.68  1.35  1.19    -4.59    -0.381  #>  3 alpha         0.272   0.281 0.205 0.208   -0.0709   0.609  #>  4 beta[1]      -0.649  -0.647 0.258 0.251   -1.08    -0.224  #>  5 beta[2]      -0.336  -0.338 0.226 0.228   -0.711    0.0373 #>  6 beta[3]       0.666   0.668 0.237 0.239    0.277    1.05   #>  7 log_lik[1]   -0.567  -0.558 0.101 0.0982  -0.742   -0.416  #>  8 log_lik[2]   -0.388  -0.364 0.138 0.132   -0.646   -0.198  #>  9 log_lik[3]   -0.602  -0.567 0.249 0.233   -1.07    -0.263  #> 10 log_lik[4]   -0.391  -0.374 0.124 0.121   -0.626   -0.219  #> # ℹ 96 more rows  print_example_program(\"schools\") #> data { #>   int<lower=1> J; #>   vector<lower=0>[J] sigma; #>   vector[J] y; #> } #> parameters { #>   real mu; #>   real<lower=0> tau; #>   vector[J] theta; #> } #> model { #>   target += normal_lpdf(tau | 0, 10); #>   target += normal_lpdf(mu | 0, 10); #>   target += normal_lpdf(theta | mu, tau); #>   target += normal_lpdf(y | theta, sigma); #> } fit_schools_mcmc <- cmdstanr_example(\"schools\") #> Warning: 100 of 4000 (2.0%) transitions ended with a divergence. #> See https://mc-stan.org/misc/warnings for details. #> Warning: 2 of 4 chains had an E-BFMI less than 0.3. #> See https://mc-stan.org/misc/warnings for details. fit_schools_mcmc$summary() #> # A tibble: 11 × 10 #>    variable   mean median    sd   mad       q5   q95  rhat ess_bulk ess_tail #>    <chr>     <dbl>  <dbl> <dbl> <dbl>    <dbl> <dbl> <dbl>    <dbl>    <dbl> #>  1 lp__     -57.5  -57.9   5.57  5.90 -66.2    -47.9  1.01     202.     87.7 #>  2 mu         6.76   6.73  4.09  4.04   0.0809  13.4  1.01     606.    673.  #>  3 tau        5.07   4.17  3.60  3.21   1.03    12.2  1.01     203.     73.1 #>  4 theta[1]   9.37   8.58  6.86  5.88  -0.166   21.5  1.01     837.   1605.  #>  5 theta[2]   7.19   7.19  5.50  5.08  -1.72    16.3  1.01    1122.   2330.  #>  6 theta[3]   5.66   6.01  6.49  5.61  -5.61    15.5  1.00     931.   1788.  #>  7 theta[4]   6.81   6.97  5.66  5.30  -2.93    15.8  1.01     956.   1997.  #>  8 theta[5]   4.97   5.51  5.52  5.15  -4.65    13.1  1.01     818.    809.  #>  9 theta[6]   5.83   6.13  5.86  5.33  -4.43    14.6  1.01    1088.   2229.  #> 10 theta[7]   9.21   8.87  5.76  5.39   0.754   19.1  1.00     755.   1603.  #> 11 theta[8]   7.34   7.21  6.58  5.64  -3.38    17.9  1.01    1151.   1785.   print_example_program(\"schools_ncp\") #> data { #>   int<lower=1> J; #>   vector<lower=0>[J] sigma; #>   vector[J] y; #> } #> parameters { #>   real mu; #>   real<lower=0> tau; #>   vector[J] theta_raw; #> } #> transformed parameters { #>   vector[J] theta = mu + tau * theta_raw; #> } #> model { #>   target += normal_lpdf(tau | 0, 10); #>   target += normal_lpdf(mu | 0, 10); #>   target += normal_lpdf(theta_raw | 0, 1); #>   target += normal_lpdf(y | theta, sigma); #> } fit_schools_ncp_mcmc <- cmdstanr_example(\"schools_ncp\") #> Warning: 1 of 4000 (0.0%) transitions ended with a divergence. #> See https://mc-stan.org/misc/warnings for details. fit_schools_ncp_mcmc$summary() #> # A tibble: 19 × 10 #>    variable     mean   median    sd   mad      q5    q95  rhat ess_bulk ess_tail #>    <chr>       <dbl>    <dbl> <dbl> <dbl>   <dbl>  <dbl> <dbl>    <dbl>    <dbl> #>  1 lp__     -46.8    -46.6    2.42  2.39  -51.2   -43.4  1.00     1597.    2363. #>  2 mu         6.51     6.57   4.16  4.02   -0.472  13.4  1.00     3174.    2417. #>  3 tau        4.78     4.01   3.65  3.46    0.414  11.9  1.00     2041.    2013. #>  4 theta_r…   0.376    0.383  0.968 0.993  -1.25    1.94 1.00     4078.    2970. #>  5 theta_r…   0.0539   0.0478 0.889 0.863  -1.43    1.50 1.000    3497.    2765. #>  6 theta_r…  -0.162   -0.169  0.948 0.939  -1.71    1.44 1.00     4253.    3063. #>  7 theta_r…   0.0210   0.0283 0.924 0.919  -1.54    1.55 1.00     4003.    2595. #>  8 theta_r…  -0.279   -0.279  0.927 0.909  -1.80    1.29 1.00     4657.    2974. #>  9 theta_r…  -0.156   -0.173  0.923 0.923  -1.67    1.38 1.00     4131.    2764. #> 10 theta_r…   0.356    0.361  0.895 0.861  -1.12    1.79 1.00     3913.    2847. #> 11 theta_r…   0.0728   0.0711 0.962 0.938  -1.52    1.68 1.00     4201.    2578. #> 12 theta[1]   9.00     8.38   6.61  5.70   -0.496  21.2  1.00     3941.    2930. #> 13 theta[2]   6.93     6.90   5.52  5.05   -1.93   16.1  1.00     4037.    3058. #> 14 theta[3]   5.42     5.83   6.41  5.64   -5.91   15.0  1.00     3598.    2668. #> 15 theta[4]   6.76     6.70   5.56  5.12   -2.29   15.8  1.00     4455.    3296. #> 16 theta[5]   4.83     5.19   5.68  5.38   -5.17   13.4  1.00     4228.    3006. #> 17 theta[6]   5.48     5.82   5.98  5.28   -4.72   14.6  1.00     4230.    3151. #> 18 theta[7]   8.74     8.39   5.64  5.27    0.391  18.7  1.00     3385.    3292. #> 19 theta[8]   7.01     6.90   6.63  5.59   -3.68   17.6  1.00     3930.    3203.  # optimization fails for hierarchical model cmdstanr_example(\"schools\", \"optimize\", quiet = FALSE) #> Initial log joint probability = -57.1252  #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes   #>       99       122.724      0.164532   4.55678e+09      0.4431      0.4431      178     #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes   #>      183       248.408     0.0553432   4.75335e+16       1e-12       0.001      393  LS failed, Hessian reset   #> Chain 1 Optimization terminated with error:  #> Chain 1   Line search failed to achieve a sufficient decrease, no more progress can be made #> Warning: Fitting finished unexpectedly! Use the $output() method for more information. #> Finished in  0.1 seconds. #> Error: Fitting failed. Unable to print. # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstanr_global_options.html","id":null,"dir":"Reference","previous_headings":"","what":"CmdStanR global options — cmdstanr_global_options","title":"CmdStanR global options — cmdstanr_global_options","text":"options can set via options() entire R session.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/cmdstanr_global_options.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"CmdStanR global options — cmdstanr_global_options","text":"cmdstanr_draws_format: format provided posterior package used returning posterior approximate posterior draws? default depends model fitting method. See draws details. cmdstanr_force_recompile: default recompile models even Stan code changes since last compiled?  See compile details. default FALSE. cmdstanr_max_rows: maximum number rows output print using $print() method. default 10. cmdstanr_print_line_numbers: line numbers included printing Stan program? default FALSE. cmdstanr_no_ver_check: check recent version CmdStan disabled? default FALSE. cmdstanr_output_dir: directory CmdStan write output CSV files fitting models. default temporary directory. Files temporary directory removed part R garbage collection, files explicitly defined directory automatically deleted. cmdstanr_verbose: information printed compiling running models, including showing CmdStan called internally? default FALSE. cmdstanr_warn_inits: warning thrown initial values provided subset parameters? default TRUE. cmdstanr_write_stan_file_dir: directory write_stan_file() write Stan files. default temporary directory. Files temporary directory removed part R garbage collection, files explicitly defined directory automatically deleted. mc.cores: number cores use various parallelization tasks (e.g. running MCMC chains, installing CmdStan). default depends use case documented methods make use mc.cores.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/draws_to_csv.html","id":null,"dir":"Reference","previous_headings":"","what":"Write posterior draws objects to CSV files suitable for running standalone generated quantities with CmdStan. — draws_to_csv","title":"Write posterior draws objects to CSV files suitable for running standalone generated quantities with CmdStan. — draws_to_csv","text":"Write posterior draws objects CSV files suitable running standalone generated quantities CmdStan.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/draws_to_csv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write posterior draws objects to CSV files suitable for running standalone generated quantities with CmdStan. — draws_to_csv","text":"","code":"draws_to_csv(   draws,   sampler_diagnostics = NULL,   dir = tempdir(),   basename = \"fittedParams\" )"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/draws_to_csv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write posterior draws objects to CSV files suitable for running standalone generated quantities with CmdStan. — draws_to_csv","text":"draws posterior::draws_* object. sampler_diagnostics Either NULL posterior::draws_* object sampler diagnostics. dir (string) optional path directory CSV files written. set, temporary directory used. basename (string) dir specified, `basename“ used naming output CSV files. specified, file names randomly generated.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/draws_to_csv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write posterior draws objects to CSV files suitable for running standalone generated quantities with CmdStan. — draws_to_csv","text":"Paths CSV files (one per chain).","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/draws_to_csv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Write posterior draws objects to CSV files suitable for running standalone generated quantities with CmdStan. — draws_to_csv","text":"draws_to_csv() generates CSV suitable running standalone generated quantities CmdStan. CSV file contains single comment #num_samples, equals number iterations supplied draws object. comment followed column names. first column lp__ value, followed sampler diagnostics finnaly variables draws object. #' draws object contain lp__ sampler diagnostics variables, columns zeros created order conform requirements standalone generated quantities method CmdStan. column names line finally followed values draws order column names.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/draws_to_csv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write posterior draws objects to CSV files suitable for running standalone generated quantities with CmdStan. — draws_to_csv","text":"","code":"# \\dontrun{ draws <- posterior::example_draws()  draws_csv_files <- draws_to_csv(draws) print(draws_csv_files) #> [1] \"/tmp/Rtmpaxzs2V/fittedParams-202512311755-1-21af4a.csv\" #> [2] \"/tmp/Rtmpaxzs2V/fittedParams-202512311755-2-21af4a.csv\" #> [3] \"/tmp/Rtmpaxzs2V/fittedParams-202512311755-3-21af4a.csv\" #> [4] \"/tmp/Rtmpaxzs2V/fittedParams-202512311755-4-21af4a.csv\"  # draws_csv_files <- draws_to_csv(draws, #                                 sampler_diagnostic = sampler_diagnostics, #                                 dir = \"~/my_folder\", #                                 basename = \"my-samples\") # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/eng_cmdstan.html","id":null,"dir":"Reference","previous_headings":"","what":"CmdStan knitr engine for Stan — eng_cmdstan","title":"CmdStan knitr engine for Stan — eng_cmdstan","text":"provides knitr engine Stan, suitable usage attempting render Stan chunks compile model code within executable CmdStan. Use register_knitr_engine() make default engine stan chunks. See vignette R Markdown CmdStan Engine example.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/eng_cmdstan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CmdStan knitr engine for Stan — eng_cmdstan","text":"","code":"eng_cmdstan(options)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/eng_cmdstan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CmdStan knitr engine for Stan — eng_cmdstan","text":"options (named list) Chunk options, provided knitr chunk execution.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/eng_cmdstan.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CmdStan knitr engine for Stan — eng_cmdstan","text":"","code":"# \\dontrun{ knitr::knit_engines$set(stan = cmdstanr::eng_cmdstan) # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-cmdstan_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Run CmdStan's stansummary and diagnose utilities — fit-method-cmdstan_summary","title":"Run CmdStan's stansummary and diagnose utilities — fit-method-cmdstan_summary","text":"Run CmdStan's stansummary diagnose utilities. documented CmdStan Guide: https://mc-stan.org/docs/cmdstan-guide/stansummary.html https://mc-stan.org/docs/cmdstan-guide/diagnose.html Although methods can used models fit using $variational() method, much output currently relevant models fit using $sample() method. See $summary() computing similar summaries R rather calling CmdStan's utilites.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-cmdstan_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run CmdStan's stansummary and diagnose utilities — fit-method-cmdstan_summary","text":"","code":"cmdstan_summary(flags = NULL)  cmdstan_diagnose()"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-cmdstan_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run CmdStan's stansummary and diagnose utilities — fit-method-cmdstan_summary","text":"flags optional character vector flags (e.g. flags = c(\"--sig_figs=1\")).","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-cmdstan_summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run CmdStan's stansummary and diagnose utilities — fit-method-cmdstan_summary","text":"","code":"# \\dontrun{ fit <- cmdstanr_example(\"logistic\") fit$cmdstan_diagnose() #> Checking sampler transitions treedepth. #> Treedepth satisfactory for all transitions. #>  #> Checking sampler transitions for divergences. #> No divergent transitions found. #>  #> Checking E-BFMI - sampler transitions HMC potential energy. #> E-BFMI satisfactory. #>  #> Rank-normalized split effective sample size satisfactory for all parameters. #>  #> Rank-normalized split R-hat values satisfactory for all parameters. #>  #> Processing complete, no problems detected. fit$cmdstan_summary() #> Inference for Stan model: logistic_model #> 4 chains: each with iter=1000; warmup=1000; thin=1; 1000 iterations saved. #>  #> Warmup took (0.020, 0.019, 0.020, 0.019) seconds, 0.078 seconds total #> Sampling took (0.057, 0.054, 0.056, 0.056) seconds, 0.22 seconds total #>  #>                     Mean     MCSE  StdDev    MAD     5%       50%       95%  ESS_bulk  ESS_tail  ESS_bulk/s  R_hat #>  #> lp__            -6.6e+01  3.1e-02     1.4    1.3    -69  -6.6e+01  -6.4e+01      2186      3208        9801    1.0 #> accept_stat__       0.90  1.5e-03    0.11  0.082   0.68      0.94       1.0      5398      4191       24205    1.0 #> stepsize__          0.77      nan   0.065  0.040   0.71      0.75      0.88       nan       nan         nan    nan #> treedepth__          2.4  5.2e-02    0.53   0.00    2.0       2.0       3.0       268       199        1203    1.0 #> n_leapfrog__         5.1  1.6e-01     2.0   0.00    3.0       7.0       7.0       477       375        2141    1.0 #> divergent__         0.00      nan    0.00   0.00   0.00      0.00      0.00       nan       nan         nan    nan #> energy__              68  4.8e-02     2.0    1.9     65        68        72      1813      2788        8131    1.0 #>  #> alpha            3.7e-01  3.6e-03    0.22   0.22  0.019   3.7e-01   7.5e-01      3749      3277       16814    1.0 #> beta[1]         -6.7e-01  3.9e-03    0.25   0.25   -1.1  -6.7e-01  -2.7e-01      4263      2751       19115    1.0 #> beta[2]         -2.7e-01  3.5e-03    0.23   0.22  -0.66  -2.7e-01   9.7e-02      4080      2981       18295    1.0 #> beta[3]          6.8e-01  4.4e-03    0.27   0.28   0.26   6.7e-01   1.1e+00      3765      2580       16881    1.0 #> log_lik[1]      -5.2e-01  1.6e-03   0.099  0.099  -0.69  -5.1e-01  -3.7e-01      3973      3220       17815    1.0 #> log_lik[2]      -4.0e-01  2.1e-03    0.15   0.14  -0.66  -3.8e-01  -2.0e-01      4673      3229       20954    1.0 #> log_lik[3]      -5.0e-01  3.5e-03    0.22   0.21  -0.90  -4.7e-01  -2.1e-01      4140      3008       18566    1.0 #> log_lik[4]      -4.5e-01  2.4e-03    0.15   0.14  -0.72  -4.3e-01  -2.4e-01      3972      3013       17812    1.0 #> log_lik[5]      -1.2e+00  4.7e-03    0.29   0.28   -1.7  -1.2e+00  -7.5e-01      3787      2879       16980    1.0 #> log_lik[6]      -6.0e-01  3.2e-03    0.20   0.19  -0.96  -5.7e-01  -3.1e-01      3692      2914       16555    1.0 #> log_lik[7]      -6.4e-01  1.9e-03    0.12   0.12  -0.86  -6.3e-01  -4.4e-01      4250      2980       19058    1.0 #> log_lik[8]      -2.8e-01  2.3e-03    0.14   0.12  -0.54  -2.6e-01  -1.0e-01      3826      3113       17158   1.00 #> log_lik[9]      -7.0e-01  2.7e-03    0.17   0.17   -1.0  -6.9e-01  -4.4e-01      3914      2704       17552    1.0 #> log_lik[10]     -7.4e-01  3.6e-03    0.23   0.23   -1.2  -7.2e-01  -4.1e-01      4136      3074       18546    1.0 #> log_lik[11]     -2.8e-01  2.2e-03    0.13   0.12  -0.52  -2.6e-01  -1.1e-01      3371      2585       15118    1.0 #> log_lik[12]     -5.0e-01  3.6e-03    0.24   0.22  -0.95  -4.5e-01  -1.9e-01      4259      3315       19099    1.0 #> log_lik[13]     -6.5e-01  3.5e-03    0.21   0.20   -1.0  -6.3e-01  -3.4e-01      3933      2661       17637    1.0 #> log_lik[14]     -3.6e-01  2.7e-03    0.17   0.16  -0.68  -3.3e-01  -1.4e-01      4005      3036       17958    1.0 #> log_lik[15]     -2.8e-01  1.8e-03    0.11   0.10  -0.48  -2.6e-01  -1.3e-01      3719      2919       16675    1.0 #> log_lik[16]     -2.8e-01  1.6e-03   0.091  0.086  -0.44  -2.7e-01  -1.5e-01      3355      2692       15044    1.0 #> log_lik[17]     -1.6e+00  5.0e-03    0.30   0.30   -2.1  -1.6e+00  -1.1e+00      3658      2840       16404    1.0 #> log_lik[18]     -4.8e-01  1.8e-03    0.11   0.11  -0.68  -4.7e-01  -3.1e-01      4043      3010       18129    1.0 #> log_lik[19]     -2.3e-01  1.3e-03   0.078  0.076  -0.37  -2.2e-01  -1.2e-01      3580      2848       16052    1.0 #> log_lik[20]     -1.1e-01  1.3e-03   0.079  0.060  -0.26  -9.2e-02  -2.8e-02      3884      3080       17415    1.0 #> log_lik[21]     -2.1e-01  1.5e-03   0.091  0.083  -0.38  -2.0e-01  -9.0e-02      3307      2504       14827    1.0 #> log_lik[22]     -5.7e-01  2.5e-03    0.15   0.15  -0.85  -5.6e-01  -3.4e-01      3749      2895       16813    1.0 #> log_lik[23]     -3.3e-01  2.3e-03    0.14   0.13  -0.60  -3.1e-01  -1.4e-01      4169      3088       18695   1.00 #> log_lik[24]     -1.4e-01  1.1e-03   0.068  0.061  -0.26  -1.2e-01  -5.2e-02      3666      3065       16439   1.00 #> log_lik[25]     -4.5e-01  1.8e-03    0.12   0.12  -0.67  -4.4e-01  -2.8e-01      4522      3033       20278    1.0 #> log_lik[26]     -1.5e+00  5.4e-03    0.35   0.34   -2.1  -1.5e+00  -1.0e+00      4289      2957       19234    1.0 #> log_lik[27]     -3.1e-01  2.2e-03    0.13   0.12  -0.55  -2.9e-01  -1.4e-01      3343      2620       14992    1.0 #> log_lik[28]     -4.5e-01  1.4e-03   0.087  0.085  -0.60  -4.4e-01  -3.1e-01      3626      3214       16262    1.0 #> log_lik[29]     -7.2e-01  3.4e-03    0.23   0.22   -1.1  -7.0e-01  -3.8e-01      4495      3056       20156    1.0 #> log_lik[30]     -7.0e-01  2.9e-03    0.19   0.19   -1.0  -6.8e-01  -4.1e-01      4602      3007       20639    1.0 #> log_lik[31]     -4.9e-01  2.8e-03    0.17   0.16  -0.79  -4.7e-01  -2.5e-01      3534      2882       15849    1.0 #> log_lik[32]     -4.3e-01  1.9e-03    0.11   0.11  -0.62  -4.2e-01  -2.6e-01      3493      2870       15662    1.0 #> log_lik[33]     -4.1e-01  1.8e-03    0.13   0.12  -0.63  -3.9e-01  -2.3e-01      4604      3000       20644    1.0 #> log_lik[34]     -6.4e-02  8.5e-04   0.052  0.036  -0.16  -5.0e-02  -1.3e-02      3709      2916       16634    1.0 #> log_lik[35]     -5.8e-01  2.8e-03    0.18   0.18  -0.91  -5.6e-01  -3.1e-01      4465      3087       20024    1.0 #> log_lik[36]     -3.3e-01  2.1e-03    0.13   0.12  -0.58  -3.0e-01  -1.5e-01      4580      2830       20536    1.0 #> log_lik[37]     -7.0e-01  3.5e-03    0.22   0.22   -1.1  -6.8e-01  -3.8e-01      4350      2872       19508    1.0 #> log_lik[38]     -3.1e-01  2.3e-03    0.15   0.13  -0.59  -2.8e-01  -1.2e-01      4122      3348       18482    1.0 #> log_lik[39]     -1.8e-01  1.8e-03    0.11  0.090  -0.38  -1.5e-01  -5.2e-02      3977      2910       17834    1.0 #> log_lik[40]     -6.8e-01  2.0e-03    0.13   0.13  -0.91  -6.8e-01  -4.8e-01      4356      3084       19534    1.0 #> log_lik[41]     -1.1e+00  4.6e-03    0.26   0.25   -1.6  -1.1e+00  -7.3e-01      3460      2970       15516    1.0 #> log_lik[42]     -9.3e-01  2.9e-03    0.20   0.20   -1.3  -9.2e-01  -6.4e-01      4690      2728       21031    1.0 #> log_lik[43]     -4.1e-01  4.1e-03    0.26   0.23  -0.91  -3.5e-01  -9.9e-02      4762      2863       21354    1.0 #> log_lik[44]     -1.2e+00  3.2e-03    0.19   0.19   -1.5  -1.2e+00  -8.9e-01      3527      2981       15816    1.0 #> log_lik[45]     -3.6e-01  1.9e-03    0.12   0.11  -0.57  -3.4e-01  -1.9e-01      3929      2940       17617    1.0 #> log_lik[46]     -5.8e-01  1.8e-03    0.13   0.13  -0.80  -5.7e-01  -3.9e-01      4867      3259       21826    1.0 #> log_lik[47]     -3.0e-01  2.0e-03    0.13   0.12  -0.54  -2.8e-01  -1.4e-01      4040      3186       18117    1.0 #> log_lik[48]     -3.2e-01  1.4e-03   0.086  0.083  -0.48  -3.2e-01  -2.0e-01      3804      3040       17057    1.0 #> log_lik[49]     -3.2e-01  1.4e-03   0.083  0.082  -0.47  -3.1e-01  -2.0e-01      3366      2805       15092   1.00 #> log_lik[50]     -1.3e+00  5.1e-03    0.33   0.33   -1.9  -1.3e+00  -8.0e-01      4368      2956       19589    1.0 #> log_lik[51]     -2.9e-01  1.5e-03   0.097  0.092  -0.46  -2.8e-01  -1.5e-01      4126      3183       18500    1.0 #> log_lik[52]     -8.3e-01  2.2e-03    0.14   0.14   -1.1  -8.2e-01  -6.2e-01      4233      3088       18983    1.0 #> log_lik[53]     -4.0e-01  2.3e-03    0.13   0.13  -0.65  -3.9e-01  -2.1e-01      3408      2858       15282    1.0 #> log_lik[54]     -3.7e-01  2.2e-03    0.14   0.13  -0.63  -3.5e-01  -1.8e-01      3969      3011       17798    1.0 #> log_lik[55]     -3.8e-01  1.9e-03    0.13   0.13  -0.62  -3.7e-01  -2.0e-01      4582      3282       20546    1.0 #> log_lik[56]     -3.2e-01  3.0e-03    0.19   0.17  -0.71  -2.8e-01  -9.2e-02      4892      2792       21936    1.0 #> log_lik[57]     -6.6e-01  1.8e-03    0.12   0.12  -0.86  -6.5e-01  -4.8e-01      4065      3068       18227    1.0 #> log_lik[58]     -9.6e-01  5.3e-03    0.35   0.34   -1.6  -9.1e-01  -4.6e-01      4725      3241       21186    1.0 #> log_lik[59]     -1.4e+00  5.1e-03    0.34   0.34   -2.0  -1.3e+00  -8.6e-01      4562      2994       20459    1.0 #> log_lik[60]     -9.8e-01  2.6e-03    0.16   0.16   -1.2  -9.7e-01  -7.3e-01      3931      2916       17628    1.0 #> log_lik[61]     -5.4e-01  1.5e-03   0.098  0.097  -0.71  -5.4e-01  -3.9e-01      4154      3222       18630    1.0 #> log_lik[62]     -8.8e-01  5.0e-03    0.31   0.30   -1.5  -8.4e-01  -4.4e-01      4049      3293       18158    1.0 #> log_lik[63]     -1.2e-01  1.3e-03   0.076  0.060  -0.26  -1.0e-01  -3.1e-02      3367      2447       15100   1.00 #> log_lik[64]     -9.0e-01  3.7e-03    0.25   0.25   -1.4  -8.8e-01  -5.3e-01      4679      2753       20984    1.0 #> log_lik[65]     -2.0e+00  1.1e-02    0.61   0.61   -3.1  -2.0e+00  -1.1e+00      3360      2436       15069    1.0 #> log_lik[66]     -5.1e-01  2.2e-03    0.14   0.13  -0.76  -5.0e-01  -3.1e-01      3896      2923       17471    1.0 #> log_lik[67]     -2.8e-01  1.4e-03   0.085  0.082  -0.43  -2.7e-01  -1.6e-01      3742      2937       16781    1.0 #> log_lik[68]     -1.1e+00  3.9e-03    0.24   0.24   -1.5  -1.0e+00  -7.0e-01      4016      2900       18010   1.00 #> log_lik[69]     -4.4e-01  1.5e-03   0.087  0.086  -0.59  -4.3e-01  -3.0e-01      3428      2827       15370   1.00 #> log_lik[70]     -6.4e-01  3.4e-03    0.23   0.23   -1.1  -6.1e-01  -3.1e-01      5102      2774       22879    1.0 #> log_lik[71]     -6.1e-01  3.3e-03    0.21   0.20  -0.99  -5.8e-01  -3.1e-01      4148      2936       18603    1.0 #> log_lik[72]     -4.6e-01  2.8e-03    0.17   0.16  -0.78  -4.3e-01  -2.2e-01      4277      2798       19181    1.0 #> log_lik[73]     -1.5e+00  5.7e-03    0.36   0.36   -2.1  -1.5e+00  -9.5e-01      4199      3107       18828    1.0 #> log_lik[74]     -9.5e-01  3.1e-03    0.19   0.20   -1.3  -9.3e-01  -6.5e-01      3901      2829       17493    1.0 #> log_lik[75]     -1.1e+00  6.3e-03    0.39   0.38   -1.8  -1.1e+00  -5.9e-01      4028      3044       18063    1.0 #> log_lik[76]     -3.7e-01  2.2e-03    0.14   0.13  -0.62  -3.5e-01  -1.8e-01      3961      3059       17760    1.0 #> log_lik[77]     -8.8e-01  2.4e-03    0.14   0.14   -1.1  -8.6e-01  -6.6e-01      3648      3157       16361    1.0 #> log_lik[78]     -4.9e-01  2.7e-03    0.17   0.17  -0.80  -4.7e-01  -2.5e-01      4225      3256       18948    1.0 #> log_lik[79]     -7.7e-01  3.0e-03    0.19   0.18   -1.1  -7.5e-01  -4.9e-01      4149      3215       18604    1.0 #> log_lik[80]     -5.4e-01  2.7e-03    0.19   0.19  -0.89  -5.1e-01  -2.7e-01      5032      3528       22566    1.0 #> log_lik[81]     -1.6e-01  1.5e-03   0.097  0.080  -0.35  -1.4e-01  -4.8e-02      4118      3003       18464    1.0 #> log_lik[82]     -2.2e-01  2.0e-03    0.14   0.12  -0.48  -1.9e-01  -6.3e-02      4413      3054       19790   1.00 #> log_lik[83]     -3.4e-01  1.4e-03   0.083  0.084  -0.49  -3.4e-01  -2.2e-01      3474      2963       15581   1.00 #> log_lik[84]     -2.8e-01  1.5e-03   0.092  0.090  -0.45  -2.6e-01  -1.4e-01      3598      2937       16134   1.00 #> log_lik[85]     -1.3e-01  1.2e-03   0.075  0.064  -0.27  -1.1e-01  -4.1e-02      3780      2909       16953   1.00 #> log_lik[86]     -1.1e+00  4.6e-03    0.31   0.32   -1.7  -1.1e+00  -6.7e-01      4890      3425       21927    1.0 #> log_lik[87]     -8.2e-01  2.0e-03    0.13   0.13   -1.0  -8.1e-01  -6.2e-01      4294      3300       19255    1.0 #> log_lik[88]     -7.7e-01  4.1e-03    0.25   0.24   -1.2  -7.4e-01  -4.2e-01      3778      2960       16941    1.0 #> log_lik[89]     -1.3e+00  4.8e-03    0.31   0.32   -1.8  -1.3e+00  -8.2e-01      4445      3255       19932    1.0 #> log_lik[90]     -2.6e-01  2.0e-03    0.13   0.12  -0.51  -2.3e-01  -9.3e-02      4439      3390       19907    1.0 #> log_lik[91]     -3.8e-01  1.9e-03    0.13   0.12  -0.62  -3.6e-01  -2.0e-01      4506      2707       20206    1.0 #> log_lik[92]     -1.5e+00  6.0e-03    0.35   0.35   -2.1  -1.5e+00  -9.7e-01      3606      2815       16169    1.0 #> log_lik[93]     -7.4e-01  3.5e-03    0.22   0.21   -1.1  -7.1e-01  -4.3e-01      4075      3041       18273    1.0 #> log_lik[94]     -3.2e-01  1.5e-03   0.089  0.088  -0.47  -3.1e-01  -1.9e-01      3593      2891       16113    1.0 #> log_lik[95]     -3.9e-01  2.0e-03    0.12   0.11  -0.60  -3.8e-01  -2.2e-01      3452      2922       15482    1.0 #> log_lik[96]     -1.6e+00  5.0e-03    0.29   0.30   -2.1  -1.6e+00  -1.1e+00      3520      2959       15783   1.00 #> log_lik[97]     -4.3e-01  1.6e-03    0.10  0.098  -0.62  -4.2e-01  -2.8e-01      4408      2968       19765    1.0 #> log_lik[98]     -1.1e+00  5.6e-03    0.37   0.36   -1.8  -1.0e+00  -5.3e-01      4724      3077       21185    1.0 #> log_lik[99]     -6.9e-01  2.1e-03    0.14   0.14  -0.94  -6.8e-01  -4.8e-01      4496      3184       20160    1.0 #> log_lik[100]    -3.9e-01  1.6e-03   0.099  0.097  -0.57  -3.8e-01  -2.5e-01      3979      2918       17844    1.0 #>  #> Samples were drawn using hmc with nuts. #> For each parameter, ESS_bulk and ESS_tail measure the effective sample size for the entire sample (bulk) and for the .05 and .95 tails (tail),  #> and R_hat measures the potential scale reduction on split chains. At convergence R_hat will be very close to 1.00. # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-code.html","id":null,"dir":"Reference","previous_headings":"","what":"Return Stan code — fit-method-code","title":"Return Stan code — fit-method-code","text":"Return Stan code","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-code.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return Stan code — fit-method-code","text":"","code":"code()"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-code.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return Stan code — fit-method-code","text":"character vector one element per line code.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-code.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Return Stan code — fit-method-code","text":"","code":"# \\dontrun{ fit <- cmdstanr_example() fit$code() # character vector #>  [1] \"data {\"                                                             #>  [2] \"  int<lower=0> N;\"                                                  #>  [3] \"  int<lower=0> K;\"                                                  #>  [4] \"  array[N] int<lower=0, upper=1> y;\"                                #>  [5] \"  matrix[N, K] X;\"                                                  #>  [6] \"}\"                                                                  #>  [7] \"parameters {\"                                                       #>  [8] \"  real alpha;\"                                                      #>  [9] \"  vector[K] beta;\"                                                  #> [10] \"}\"                                                                  #> [11] \"model {\"                                                            #> [12] \"  target += normal_lpdf(alpha | 0, 1);\"                             #> [13] \"  target += normal_lpdf(beta | 0, 1);\"                              #> [14] \"  target += bernoulli_logit_glm_lpmf(y | X, alpha, beta);\"          #> [15] \"}\"                                                                  #> [16] \"generated quantities {\"                                             #> [17] \"  vector[N] log_lik;\"                                               #> [18] \"  for (n in 1 : N) {\"                                               #> [19] \"    log_lik[n] = bernoulli_logit_lpmf(y[n] | alpha + X[n] * beta);\" #> [20] \"  }\"                                                                #> [21] \"}\"                                                                  cat(fit$code(), sep = \"\\n\") # pretty print #> data { #>   int<lower=0> N; #>   int<lower=0> K; #>   array[N] int<lower=0, upper=1> y; #>   matrix[N, K] X; #> } #> parameters { #>   real alpha; #>   vector[K] beta; #> } #> model { #>   target += normal_lpdf(alpha | 0, 1); #>   target += normal_lpdf(beta | 0, 1); #>   target += bernoulli_logit_glm_lpmf(y | X, alpha, beta); #> } #> generated quantities { #>   vector[N] log_lik; #>   for (n in 1 : N) { #>     log_lik[n] = bernoulli_logit_lpmf(y[n] | alpha + X[n] * beta); #>   } #> } # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-constrain_variables.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform a set of unconstrained parameter values to the constrained scale — fit-method-constrain_variables","title":"Transform a set of unconstrained parameter values to the constrained scale — fit-method-constrain_variables","text":"$constrain_variables() method transforms input parameters constrained scale.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-constrain_variables.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform a set of unconstrained parameter values to the constrained scale — fit-method-constrain_variables","text":"","code":"constrain_variables(   unconstrained_variables,   transformed_parameters = TRUE,   generated_quantities = TRUE )"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-constrain_variables.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform a set of unconstrained parameter values to the constrained scale — fit-method-constrain_variables","text":"unconstrained_variables (numeric) vector unconstrained parameters constrain. transformed_parameters (logical) Whether return transformed parameters implied newly-constrained parameters (defaults TRUE). generated_quantities (logical) Whether return generated quantities implied newly-constrained parameters (defaults TRUE).","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-constrain_variables.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform a set of unconstrained parameter values to the constrained scale — fit-method-constrain_variables","text":"","code":"# \\dontrun{ fit_mcmc <- cmdstanr_example(\"logistic\", method = \"sample\", force_recompile = TRUE) fit_mcmc$constrain_variables(unconstrained_variables = c(0.5, 1.2, 1.1, 2.2)) #> ar: creating stan/lib/stan_math/lib/sundials_6.1.1/lib/libsundials_nvecserial.a #> ar: creating stan/lib/stan_math/lib/sundials_6.1.1/lib/libsundials_cvodes.a #> ar: creating stan/lib/stan_math/lib/sundials_6.1.1/lib/libsundials_idas.a #> ar: creating stan/lib/stan_math/lib/sundials_6.1.1/lib/libsundials_kinsol.a #> /home/runner/.cmdstan/cmdstan-2.37.0/stan/lib/stan_math/lib/tbb_2020.3/build/Makefile.tbb:28: CONFIG: cfg=release arch=intel64 compiler=gcc target=linux runtime=cc13.3.0_libc2.39_kernel6.11.0 #> In file included from ../tbb_2020.3/src/tbb/concurrent_hash_map.cpp:17: #> ../tbb_2020.3/include/tbb/concurrent_hash_map.h:347:23: warning: ‘template<class _Category, class _Tp, class _Distance, class _Pointer, class _Reference> struct std::iterator’ is deprecated [-Wdeprecated-declarations] #>   347 |         : public std::iterator<std::forward_iterator_tag,Value> #>       |                       ^~~~~~~~ #> In file included from /usr/include/c++/13/bits/stl_construct.h:61, #>                  from /usr/include/c++/13/bits/stl_tempbuf.h:61, #>                  from /usr/include/c++/13/memory:66, #>                  from ../tbb_2020.3/include/tbb/tbb_stddef.h:452, #>                  from ../tbb_2020.3/include/tbb/concurrent_hash_map.h:23: #> /usr/include/c++/13/bits/stl_iterator_base_types.h:127:34: note: declared here #>   127 |     struct _GLIBCXX17_DEPRECATED iterator #>       |                                  ^~~~~~~~ #> cc1plus: note: unrecognized command-line option ‘-Wno-unknown-warning-option’ may have been intended to silence earlier diagnostics #> In file included from ../tbb_2020.3/src/tbb/concurrent_queue.cpp:22: #> ../tbb_2020.3/include/tbb/internal/_concurrent_queue_impl.h:749:21: warning: ‘template<class _Category, class _Tp, class _Distance, class _Pointer, class _Reference> struct std::iterator’ is deprecated [-Wdeprecated-declarations] #>   749 |         public std::iterator<std::forward_iterator_tag,Value> { #>       |                     ^~~~~~~~ #> In file included from /usr/include/c++/13/bits/stl_construct.h:61, #>                  from /usr/include/c++/13/bits/stl_tempbuf.h:61, #>                  from /usr/include/c++/13/memory:66, #>                  from ../tbb_2020.3/include/tbb/tbb_stddef.h:452, #>                  from ../tbb_2020.3/src/tbb/concurrent_queue.cpp:17: #> /usr/include/c++/13/bits/stl_iterator_base_types.h:127:34: note: declared here #>   127 |     struct _GLIBCXX17_DEPRECATED iterator #>       |                                  ^~~~~~~~ #> ../tbb_2020.3/include/tbb/internal/_concurrent_queue_impl.h:1013:21: warning: ‘template<class _Category, class _Tp, class _Distance, class _Pointer, class _Reference> struct std::iterator’ is deprecated [-Wdeprecated-declarations] #>  1013 |         public std::iterator<std::forward_iterator_tag,Value> { #>       |                     ^~~~~~~~ #> /usr/include/c++/13/bits/stl_iterator_base_types.h:127:34: note: declared here #>   127 |     struct _GLIBCXX17_DEPRECATED iterator #>       |                                  ^~~~~~~~ #> cc1plus: note: unrecognized command-line option ‘-Wno-unknown-warning-option’ may have been intended to silence earlier diagnostics #> $alpha #> [1] 0.5 #>  #> $beta #> [1] 1.2 1.1 2.2 #>  #> $log_lik #>   [1] -0.671996961 -0.076521408 -0.050097680 -0.859061944 -4.368940350 #>   [6] -0.026348601 -1.399709850 -1.607383090 -0.197580264 -0.161519876 #>  [11] -0.020289680 -0.005109469 -3.391453198 -0.438505774 -0.019831358 #>  [16] -0.320576250 -0.491982174 -0.985897601 -0.760711848 -0.135968222 #>  [21] -0.090365458 -0.289106971 -2.401995550 -0.741279075 -1.130539252 #>  [26] -0.051754355 -0.052810285 -0.592894549 -4.203884680 -1.627902707 #>  [31] -0.086396696 -0.055223416 -0.702223347 -1.437214411 -4.277397542 #>  [36] -3.430371053 -0.029399304 -2.582700752 -0.082096143 -0.613542693 #>  [41] -1.631715761 -0.780555873 -8.456425184 -1.129873174 -0.803760727 #>  [46] -0.375921603 -0.200697408 -1.179516083 -0.288812923 -0.028251618 #>  [51] -2.203830461 -0.542549041 -0.108332542 -1.410224678 -0.176267923 #>  [56] -6.137792581 -0.301999796 -0.002415079 -1.082073078 -0.661755204 #>  [61] -0.906463865 -0.022520669 -0.200599774 -0.088896080 -4.807633540 #>  [66] -0.027891348 -1.129060197 -0.378523990 -0.287530851 -4.083209231 #>  [71] -4.503703248 -2.056130808 -0.409881228 -2.435290917 -0.022311747 #>  [76] -0.310871780 -1.558477854 -3.416918272 -0.143495888 -0.017064658 #>  [81] -1.422948018 -0.019539438 -0.383208393 -0.083042642 -0.216009949 #>  [86] -3.175676338 -0.547416219 -3.767462435 -1.854701489 -3.595218847 #>  [91] -1.713321036 -4.146153592 -1.389571073 -0.344785402 -0.305319997 #>  [96] -1.233113298 -1.753232181 -0.002618034 -0.608156530 -1.329013367 #>  # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-diagnostic_summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Sampler diagnostic summaries and warnings — fit-method-diagnostic_summary","title":"Sampler diagnostic summaries and warnings — fit-method-diagnostic_summary","text":"Warnings summaries sampler diagnostics. instead get underlying values sampler diagnostics iteration chain use $sampler_diagnostics() method. Currently parameter-specific diagnostics like R-hat effective sample size handled method. diagnostics provided via $summary() method (using posterior::summarize_draws()).","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-diagnostic_summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sampler diagnostic summaries and warnings — fit-method-diagnostic_summary","text":"","code":"diagnostic_summary(   diagnostics = c(\"divergences\", \"treedepth\", \"ebfmi\"),   quiet = FALSE )"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-diagnostic_summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sampler diagnostic summaries and warnings — fit-method-diagnostic_summary","text":"diagnostics (character vector) One diagnostics check. currently supported diagnostics \"divergences, \"treedepth\", \"ebfmi. default check . quiet (logical) warning messages diagnostics suppressed? default FALSE, case warning messages printed addition returning values diagnostics.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-diagnostic_summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sampler diagnostic summaries and warnings — fit-method-diagnostic_summary","text":"list many named elements diagnostics selected. possible elements values : \"num_divergent\": vector number divergences per chain. \"num_max_treedepth\": vector number times max_treedepth hit per chain. \"ebfmi\": vector E-BFMI values per chain.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-diagnostic_summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sampler diagnostic summaries and warnings — fit-method-diagnostic_summary","text":"","code":"# \\dontrun{ fit <- cmdstanr_example(\"schools\") #> Warning: 99 of 4000 (2.0%) transitions ended with a divergence. #> See https://mc-stan.org/misc/warnings for details. #> Warning: 1 of 4 chains had an E-BFMI less than 0.3. #> See https://mc-stan.org/misc/warnings for details. fit$diagnostic_summary() #> Warning: 99 of 4000 (2.0%) transitions ended with a divergence. #> See https://mc-stan.org/misc/warnings for details. #> Warning: 1 of 4 chains had an E-BFMI less than 0.3. #> See https://mc-stan.org/misc/warnings for details. #> $num_divergent #> [1] 39 45  6  9 #>  #> $num_max_treedepth #> [1] 0 0 0 0 #>  #> $ebfmi #> [1] 0.3101370 0.2370734 0.3389424 0.4800299 #>  fit$diagnostic_summary(quiet = TRUE) #> $num_divergent #> [1] 39 45  6  9 #>  #> $num_max_treedepth #> [1] 0 0 0 0 #>  #> $ebfmi #> [1] 0.3101370 0.2370734 0.3389424 0.4800299 #>  # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-draws.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract posterior draws — fit-method-draws","title":"Extract posterior draws — fit-method-draws","text":"Extract posterior draws MCMC approximate posterior draws variational approximation using formats provided posterior package. variables include parameters, transformed parameters, generated quantities Stan program well lp__, total log probability (target) accumulated model block.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-draws.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract posterior draws — fit-method-draws","text":"","code":"draws(   variables = NULL,   inc_warmup = FALSE,   format = getOption(\"cmdstanr_draws_format\") )"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-draws.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract posterior draws — fit-method-draws","text":"variables (character vector) Optionally, names variables (parameters, transformed parameters, generated quantities) read . NULL (default) variables included. empty string (variables=\"\") none included. non-scalar variables elements specific elements can selected: variables = \"theta\" selects elements theta; variables = c(\"theta[1]\", \"theta[3]\") selects 1st 3rd elements. inc_warmup (logical) warmup draws included? Defaults FALSE. Ignored except used CmdStanMCMC objects. format (string) format returned draws point estimates. Must valid format posterior package. defaults following. sampling generated quantities default \"draws_array\". format keeps chains separate. combine chains use formats (e.g. \"draws_matrix\"). point estimates optimization approximate draws variational inference default \"draws_matrix\". use different format can specified full name format posterior package (e.g. format = \"draws_df\") omitting \"draws_\" prefix (e.g. format = \"df\"). Changing default format: change default format entire R session use options(cmdstanr_draws_format = format), format name (quotes) valid format posterior package. example options(cmdstanr_draws_format = \"draws_df\") change default data frame. Note efficiency: models large number parameters (20k+) recommend using \"draws_list\" format, efficient RAM friendly combining draws multiple chains. speed memory constraint recommend selecting format suits coding style post processing phase.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-draws.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract posterior draws — fit-method-draws","text":"Depends value format. defaults : MCMC, 3-D draws_array object (iteration x chain x variable). standalone generated quantities, 3-D draws_array object (iteration x chain x variable). variational inference, 2-D draws_matrix object (draw x variable) chains. additional variable lp_approx__ also included, log density variational approximation posterior evaluated draws. optimization, 1-row draws_matrix one column per variable. actually draws, just point estimates stored draws_matrix format. See $mle() extract numeric vector.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-draws.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract posterior draws — fit-method-draws","text":"","code":"# \\dontrun{ # logistic regression with intercept alpha and coefficients beta fit <- cmdstanr_example(\"logistic\", method = \"sample\")  # returned as 3-D array (see ?posterior::draws_array) draws <- fit$draws() dim(draws) #> [1] 1000    4  105 str(draws) #>  'draws_array' num [1:1000, 1:4, 1:105] -70.3 -68.4 -69.8 -65 -64.3 ... #>  - attr(*, \"dimnames\")=List of 3 #>   ..$ iteration: chr [1:1000] \"1\" \"2\" \"3\" \"4\" ... #>   ..$ chain    : chr [1:4] \"1\" \"2\" \"3\" \"4\" #>   ..$ variable : chr [1:105] \"lp__\" \"alpha\" \"beta[1]\" \"beta[2]\" ...  # can easily convert to other formats (data frame, matrix, list) # using the posterior package head(posterior::as_draws_matrix(draws)) #> # A draws_matrix: 6 iterations, 1 chains, and 105 variables #>     variable #> draw lp__ alpha beta[1] beta[2] beta[3] log_lik[1] log_lik[2] log_lik[3] #>    1  -70 0.095   -0.89  -0.654    1.52      -0.71      -0.11      -0.72 #>    2  -68 0.357   -0.99  -0.583    1.40      -0.56      -0.16      -0.52 #>    3  -70 0.201   -0.15   0.251    0.52      -0.58      -0.38      -0.30 #>    4  -65 0.246   -0.79  -0.028    0.76      -0.53      -0.26      -0.30 #>    5  -64 0.205   -0.59  -0.237    0.55      -0.58      -0.39      -0.54 #>    6  -64 0.535   -0.51  -0.254    0.66      -0.46      -0.47      -0.43 #> # ... with 97 more variables  # or can specify 'format' argument to avoid manual conversion # matrix format combines all chains draws <- fit$draws(format = \"matrix\") head(draws) #> # A draws_matrix: 6 iterations, 1 chains, and 105 variables #>     variable #> draw lp__ alpha beta[1] beta[2] beta[3] log_lik[1] log_lik[2] log_lik[3] #>    1  -70 0.095   -0.89  -0.654    1.52      -0.71      -0.11      -0.72 #>    2  -68 0.357   -0.99  -0.583    1.40      -0.56      -0.16      -0.52 #>    3  -70 0.201   -0.15   0.251    0.52      -0.58      -0.38      -0.30 #>    4  -65 0.246   -0.79  -0.028    0.76      -0.53      -0.26      -0.30 #>    5  -64 0.205   -0.59  -0.237    0.55      -0.58      -0.39      -0.54 #>    6  -64 0.535   -0.51  -0.254    0.66      -0.46      -0.47      -0.43 #> # ... with 97 more variables  # can select specific parameters fit$draws(\"alpha\") #> # A draws_array: 1000 iterations, 4 chains, and 1 variables #> , , variable = alpha #>  #>          chain #> iteration     1    2      3    4 #>         1 0.095 0.28 0.4579 0.43 #>         2 0.357 0.30 0.4601 0.51 #>         3 0.201 0.71 0.3105 0.42 #>         4 0.246 0.31 0.0019 0.47 #>         5 0.205 0.15 0.5531 0.26 #>  #> # ... with 995 more iterations fit$draws(\"beta\")  # selects entire vector beta #> # A draws_array: 1000 iterations, 4 chains, and 3 variables #> , , variable = beta[1] #>  #>          chain #> iteration     1     2     3     4 #>         1 -0.89 -0.66 -0.58 -0.54 #>         2 -0.99 -0.76 -0.49 -0.84 #>         3 -0.15 -0.93 -0.63 -1.06 #>         4 -0.79 -0.96 -0.43 -0.81 #>         5 -0.59 -0.69 -0.97 -0.63 #>  #> , , variable = beta[2] #>  #>          chain #> iteration      1       2       3      4 #>         1 -0.654 -0.2187 -0.4122  0.044 #>         2 -0.583  0.0003 -0.0011 -0.314 #>         3  0.251 -0.3054  0.0416 -0.089 #>         4 -0.028 -0.6455 -0.2830 -0.041 #>         5 -0.237  0.0498 -0.2858 -0.621 #>  #> , , variable = beta[3] #>  #>          chain #> iteration    1    2    3    4 #>         1 1.52 0.27 0.43 0.60 #>         2 1.40 1.08 0.50 0.47 #>         3 0.52 0.42 0.76 0.58 #>         4 0.76 0.52 0.55 0.85 #>         5 0.55 0.43 0.81 0.69 #>  #> # ... with 995 more iterations fit$draws(c(\"alpha\", \"beta[2]\")) #> # A draws_array: 1000 iterations, 4 chains, and 2 variables #> , , variable = alpha #>  #>          chain #> iteration     1    2      3    4 #>         1 0.095 0.28 0.4579 0.43 #>         2 0.357 0.30 0.4601 0.51 #>         3 0.201 0.71 0.3105 0.42 #>         4 0.246 0.31 0.0019 0.47 #>         5 0.205 0.15 0.5531 0.26 #>  #> , , variable = beta[2] #>  #>          chain #> iteration      1       2       3      4 #>         1 -0.654 -0.2187 -0.4122  0.044 #>         2 -0.583  0.0003 -0.0011 -0.314 #>         3  0.251 -0.3054  0.0416 -0.089 #>         4 -0.028 -0.6455 -0.2830 -0.041 #>         5 -0.237  0.0498 -0.2858 -0.621 #>  #> # ... with 995 more iterations  # can be passed directly to bayesplot plotting functions bayesplot::color_scheme_set(\"brightblue\") bayesplot::mcmc_dens(fit$draws(c(\"alpha\", \"beta\")))  bayesplot::mcmc_scatter(fit$draws(c(\"beta[1]\", \"beta[2]\")), alpha = 0.3)    # example using variational inference fit <- cmdstanr_example(\"logistic\", method = \"variational\") head(fit$draws(\"beta\")) # a matrix by default #> # A draws_matrix: 6 iterations, 1 chains, and 3 variables #>     variable #> draw beta[1] beta[2] beta[3] #>    1   -0.68   -0.28    0.74 #>    2   -0.24   -0.29    0.72 #>    3   -0.66   -0.58    0.69 #>    4   -0.64   -0.37    0.70 #>    5   -0.56   -0.13    0.60 #>    6   -0.81   -0.34    1.02 head(fit$draws(\"beta\", format = \"df\")) #> # A draws_df: 6 iterations, 1 chains, and 3 variables #>   beta[1] beta[2] beta[3] #> 1   -0.68   -0.28    0.74 #> 2   -0.24   -0.29    0.72 #> 3   -0.66   -0.58    0.69 #> 4   -0.64   -0.37    0.70 #> 5   -0.56   -0.13    0.60 #> 6   -0.81   -0.34    1.02 #> # ... hidden reserved variables {'.chain', '.iteration', '.draw'} # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-grad_log_prob.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the log-probability and the gradient w.r.t. each input for a given vector of unconstrained parameters — fit-method-grad_log_prob","title":"Calculate the log-probability and the gradient w.r.t. each input for a given vector of unconstrained parameters — fit-method-grad_log_prob","text":"$grad_log_prob() method provides access Stan model's log_prob function derivative.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-grad_log_prob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the log-probability and the gradient w.r.t. each input for a given vector of unconstrained parameters — fit-method-grad_log_prob","text":"","code":"grad_log_prob(   unconstrained_variables,   jacobian = TRUE,   jacobian_adjustment = NULL )"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-grad_log_prob.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the log-probability and the gradient w.r.t. each input for a given vector of unconstrained parameters — fit-method-grad_log_prob","text":"unconstrained_variables (numeric) vector unconstrained parameters. jacobian (logical) Whether include log-density adjustments un/constraining variables. jacobian_adjustment Deprecated. Please use jacobian instead.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-grad_log_prob.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the log-probability and the gradient w.r.t. each input for a given vector of unconstrained parameters — fit-method-grad_log_prob","text":"","code":"# \\dontrun{ fit_mcmc <- cmdstanr_example(\"logistic\", method = \"sample\", force_recompile = TRUE) fit_mcmc$grad_log_prob(unconstrained_variables = c(0.5, 1.2, 1.1, 2.2)) #> [1]   1.462151 -26.619534 -25.528776 -14.286822 #> attr(,\"log_prob\") #> [1] -130.2141 # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-gradients.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract gradients after diagnostic mode — fit-method-gradients","title":"Extract gradients after diagnostic mode — fit-method-gradients","text":"Return data frame containing gradients parameters.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-gradients.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract gradients after diagnostic mode — fit-method-gradients","text":"","code":"gradients()"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-gradients.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract gradients after diagnostic mode — fit-method-gradients","text":"list lists. See Examples.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-gradients.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract gradients after diagnostic mode — fit-method-gradients","text":"","code":"# \\dontrun{ test <- cmdstanr_example(\"logistic\", method = \"diagnose\")  # retrieve the gradients test$gradients() #>   param_idx      value    model finite_diff        error #> 1         0 -0.0740803  11.4505     11.4505 -1.44433e-08 #> 2         1 -0.2718300 -10.4244    -10.4244  2.47002e-08 #> 3         2  1.3967400 -31.3039    -31.3039  1.56456e-08 #> 4         3 -0.5356680  15.1104     15.1104  2.07092e-08 # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-hessian.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the log-probability , the gradient w.r.t. each input, and the hessian for a given vector of unconstrained parameters — fit-method-hessian","title":"Calculate the log-probability , the gradient w.r.t. each input, and the hessian for a given vector of unconstrained parameters — fit-method-hessian","text":"$hessian() method provides access Stan model's log_prob, derivative, hessian.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-hessian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the log-probability , the gradient w.r.t. each input, and the hessian for a given vector of unconstrained parameters — fit-method-hessian","text":"","code":"hessian(unconstrained_variables, jacobian = TRUE, jacobian_adjustment = NULL)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-hessian.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the log-probability , the gradient w.r.t. each input, and the hessian for a given vector of unconstrained parameters — fit-method-hessian","text":"unconstrained_variables (numeric) vector unconstrained parameters. jacobian (logical) Whether include log-density adjustments un/constraining variables. jacobian_adjustment Deprecated. Please use jacobian instead.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-hessian.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the log-probability , the gradient w.r.t. each input, and the hessian for a given vector of unconstrained parameters — fit-method-hessian","text":"","code":"# \\dontrun{ fit_mcmc <- cmdstanr_example(\"logistic\", method = \"sample\", force_recompile = TRUE) # fit_mcmc$init_model_methods(hessian = TRUE) # fit_mcmc$hessian(unconstrained_variables = c(0.5, 1.2, 1.1, 2.2)) # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-init.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract user-specified initial values — fit-method-init","title":"Extract user-specified initial values — fit-method-init","text":"Return user-specified initial values. user provided initial values files R objects (list lists function) via init argument fitting model returned (always list lists format). Currently possible extract initial values generated automatically CmdStan, although CmdStan may support future.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-init.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract user-specified initial values — fit-method-init","text":"","code":"init()"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-init.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract user-specified initial values — fit-method-init","text":"list lists. See Examples.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-init.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract user-specified initial values — fit-method-init","text":"","code":"# \\dontrun{ init_fun <- function() list(alpha = rnorm(1), beta = rnorm(3)) fit <- cmdstanr_example(\"logistic\", init = init_fun, chains = 2) str(fit$init()) #> List of 2 #>  $ :List of 2 #>   ..$ alpha: num 0.227 #>   ..$ beta : num [1:3] 0.978 -0.209 -1.399 #>  $ :List of 2 #>   ..$ alpha: num 0.259 #>   ..$ beta : num [1:3] -0.442 0.569 2.127  # partial inits (only specifying for a subset of parameters) init_list <- list(   list(mu = 10, tau = 2),   list(mu = -10, tau = 1) ) fit <- cmdstanr_example(\"schools_ncp\", init = init_list, chains = 2, adapt_delta = 0.9) #> Init values were only set for a subset of parameters.  #> Missing init values for the following parameters: #>  - chain 1: theta_raw #>  - chain 2: theta_raw #>  #> To disable this message use options(cmdstanr_warn_inits = FALSE).  # only user-specified inits returned str(fit$init()) #> List of 2 #>  $ :List of 2 #>   ..$ mu : int 10 #>   ..$ tau: int 2 #>  $ :List of 2 #>   ..$ mu : int -10 #>   ..$ tau: int 1 # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-init_model_methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Compile additional methods for accessing the model log-probability function and parameter constraining and unconstraining. — fit-method-init_model_methods","title":"Compile additional methods for accessing the model log-probability function and parameter constraining and unconstraining. — fit-method-init_model_methods","text":"$init_model_methods() method compiles initializes log_prob, grad_log_prob, constrain_variables, unconstrain_variables unconstrain_draws functions. available methods fitted model object. requires additional Rcpp package, required fitting models using CmdStanR. Note: may many compiler warnings emitted compilation can ignored long warnings errors.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-init_model_methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compile additional methods for accessing the model log-probability function and parameter constraining and unconstraining. — fit-method-init_model_methods","text":"","code":"init_model_methods(seed = 1, verbose = FALSE, hessian = FALSE)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-init_model_methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compile additional methods for accessing the model log-probability function and parameter constraining and unconstraining. — fit-method-init_model_methods","text":"seed (integer) random seed use initializing model. verbose (logical) Whether show verbose logging compilation. hessian (logical) Whether expose (experimental) hessian method.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-init_model_methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compile additional methods for accessing the model log-probability function and parameter constraining and unconstraining. — fit-method-init_model_methods","text":"","code":"# \\dontrun{ fit_mcmc <- cmdstanr_example(\"logistic\", method = \"sample\", force_recompile = TRUE) # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-inv_metric.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract inverse metric (mass matrix) after MCMC — fit-method-inv_metric","title":"Extract inverse metric (mass matrix) after MCMC — fit-method-inv_metric","text":"Extract inverse metric (mass matrix) MCMC chain.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-inv_metric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract inverse metric (mass matrix) after MCMC — fit-method-inv_metric","text":"","code":"inv_metric(matrix = TRUE)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-inv_metric.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract inverse metric (mass matrix) after MCMC — fit-method-inv_metric","text":"matrix (logical) diagonal metric used, setting matrix = FALSE returns list containing just diagonals matrices instead full matrices. Setting matrix = FALSE effect dense metrics.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-inv_metric.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract inverse metric (mass matrix) after MCMC — fit-method-inv_metric","text":"list length equal number MCMC chains. See matrix argument details.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-inv_metric.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract inverse metric (mass matrix) after MCMC — fit-method-inv_metric","text":"","code":"# \\dontrun{ fit <- cmdstanr_example(\"logistic\") fit$inv_metric() #> $`1` #>           [,1]      [,2]      [,3]      [,4] #> [1,] 0.0463354 0.0000000 0.0000000 0.0000000 #> [2,] 0.0000000 0.0601104 0.0000000 0.0000000 #> [3,] 0.0000000 0.0000000 0.0507043 0.0000000 #> [4,] 0.0000000 0.0000000 0.0000000 0.0636408 #>  #> $`2` #>           [,1]      [,2]      [,3]      [,4] #> [1,] 0.0481084 0.0000000 0.0000000 0.0000000 #> [2,] 0.0000000 0.0561195 0.0000000 0.0000000 #> [3,] 0.0000000 0.0000000 0.0488351 0.0000000 #> [4,] 0.0000000 0.0000000 0.0000000 0.0732373 #>  #> $`3` #>          [,1]      [,2]      [,3]      [,4] #> [1,] 0.042979 0.0000000 0.0000000 0.0000000 #> [2,] 0.000000 0.0677383 0.0000000 0.0000000 #> [3,] 0.000000 0.0000000 0.0434428 0.0000000 #> [4,] 0.000000 0.0000000 0.0000000 0.0843981 #>  #> $`4` #>           [,1]      [,2]     [,3]      [,4] #> [1,] 0.0496743 0.0000000 0.000000 0.0000000 #> [2,] 0.0000000 0.0569424 0.000000 0.0000000 #> [3,] 0.0000000 0.0000000 0.043422 0.0000000 #> [4,] 0.0000000 0.0000000 0.000000 0.0829493 #>  fit$inv_metric(matrix=FALSE) #> $`1` #> [1] 0.0463354 0.0601104 0.0507043 0.0636408 #>  #> $`2` #> [1] 0.0481084 0.0561195 0.0488351 0.0732373 #>  #> $`3` #> [1] 0.0429790 0.0677383 0.0434428 0.0843981 #>  #> $`4` #> [1] 0.0496743 0.0569424 0.0434220 0.0829493 #>   fit <- cmdstanr_example(\"logistic\", metric = \"dense_e\") fit$inv_metric() #> $`1` #>             [,1]        [,2]        [,3]        [,4] #> [1,]  0.04207890 -0.00411326  0.00140018  0.00316808 #> [2,] -0.00411326  0.07005260 -0.00358534 -0.00721287 #> [3,]  0.00140018 -0.00358534  0.04989460 -0.00990938 #> [4,]  0.00316808 -0.00721287 -0.00990938  0.07372540 #>  #> $`2` #>             [,1]         [,2]         [,3]        [,4] #> [1,]  0.04375550 -0.005185460  0.003637290  0.00263089 #> [2,] -0.00518546  0.062107700 -0.000240788 -0.01515610 #> [3,]  0.00363729 -0.000240788  0.048456800 -0.00481198 #> [4,]  0.00263089 -0.015156100 -0.004811980  0.07412660 #>  #> $`3` #>              [,1]        [,2]         [,3]        [,4] #> [1,]  4.03214e-02 -0.00510548 -1.79004e-05  0.00148148 #> [2,] -5.10548e-03  0.06109750 -7.34705e-03  0.00242718 #> [3,] -1.79004e-05 -0.00734705  4.52891e-02 -0.01039730 #> [4,]  1.48148e-03  0.00242718 -1.03973e-02  0.06407940 #>  #> $`4` #>              [,1]         [,2]        [,3]        [,4] #> [1,]  5.18858e-02 -6.89848e-05  0.00192026  0.00576423 #> [2,] -6.89848e-05  6.60642e-02 -0.00448511 -0.00922828 #> [3,]  1.92026e-03 -4.48511e-03  0.04440530 -0.01030510 #> [4,]  5.76423e-03 -9.22828e-03 -0.01030510  0.07884090 #>  # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-log_prob.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the log-probability given a provided vector of unconstrained parameters. — fit-method-log_prob","title":"Calculate the log-probability given a provided vector of unconstrained parameters. — fit-method-log_prob","text":"$log_prob() method provides access Stan model's log_prob function.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-log_prob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the log-probability given a provided vector of unconstrained parameters. — fit-method-log_prob","text":"","code":"log_prob(unconstrained_variables, jacobian = TRUE, jacobian_adjustment = NULL)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-log_prob.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate the log-probability given a provided vector of unconstrained parameters. — fit-method-log_prob","text":"unconstrained_variables (numeric) vector unconstrained parameters. jacobian (logical) Whether include log-density adjustments un/constraining variables. jacobian_adjustment Deprecated. Please use jacobian instead.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-log_prob.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate the log-probability given a provided vector of unconstrained parameters. — fit-method-log_prob","text":"","code":"# \\dontrun{ fit_mcmc <- cmdstanr_example(\"logistic\", method = \"sample\", force_recompile = TRUE) fit_mcmc$log_prob(unconstrained_variables = c(0.5, 1.2, 1.1, 2.2)) #> [1] -130.2141 # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-loo.html","id":null,"dir":"Reference","previous_headings":"","what":"Leave-one-out cross-validation (LOO-CV) — fit-method-loo","title":"Leave-one-out cross-validation (LOO-CV) — fit-method-loo","text":"$loo() method computes approximate LOO-CV using loo package. order use method must compute save pointwise log-likelihood Stan program. See loo::loo.array() loo package vignettes details.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-loo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Leave-one-out cross-validation (LOO-CV) — fit-method-loo","text":"","code":"loo(variables = \"log_lik\", r_eff = FALSE, moment_match = FALSE, ...)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-loo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Leave-one-out cross-validation (LOO-CV) — fit-method-loo","text":"variables (string) name variable Stan program containing pointwise log-likelihood. default look \"log_lik\". argument passed $draws() method. r_eff (multiple options) handle r_eff argument loo(). r_eff measures amount autocorrelation MCMC draws, used compute accurate ESS MCSE estimates pointwise total ELPDs. TRUE call loo::relative_eff.array() compute r_eff argument pass loo::loo.array(). FALSE (default) NULL avoid computing r_eff, can slow. reported ESS MCSE estimates may -optimistic posterior draws far independent. r_eff anything else, object passed r_eff argument loo::loo.array(). moment_match (logical) Whether use moment-matching correction problematic observations. default FALSE. Using moment_match=TRUE result compiling additional methods described fit-method-init_model_methods. allows CmdStanR automatically supply functions log_lik_i, unconstrain_pars, log_prob_upars, log_lik_i_upars arguments loo::loo_moment_match(). ... arguments (e.g., cores, save_psis, etc.) passed loo::loo.array() loo::loo_moment_match.default() (moment_match = TRUE set).","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-loo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Leave-one-out cross-validation (LOO-CV) — fit-method-loo","text":"object returned loo::loo.array() loo::loo_moment_match.default().","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-loo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Leave-one-out cross-validation (LOO-CV) — fit-method-loo","text":"","code":"# \\dontrun{ # the \"logistic\" example model has \"log_lik\" in generated quantities fit <- cmdstanr_example(\"logistic\") loo_result <- fit$loo(cores = 2) print(loo_result) #>  #> Computed from 4000 by 100 log-likelihood matrix. #>  #>          Estimate  SE #> elpd_loo    -63.6 4.1 #> p_loo         3.9 0.5 #> looic       127.3 8.3 #> ------ #> MCSE of elpd_loo is 0.0. #> MCSE and ESS estimates assume independent draws (r_eff=1). #>  #> All Pareto k estimates are good (k < 0.7). #> See help('pareto-k-diagnostic') for details. # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-lp.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract log probability (target) — fit-method-lp","title":"Extract log probability (target) — fit-method-lp","text":"$lp() method extracts lp__, total log probability (target) accumulated model block Stan program. variational inference log density variational approximation posterior available via $lp_approx() method. Laplace approximation unnormalized density approximation posterior available via $lp_approx() method. See Increment log density Distribution Statements sections Stan Reference Manual details normalizing constants dropped log probability calculations.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-lp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract log probability (target) — fit-method-lp","text":"","code":"lp()  lp_approx()  lp_approx()"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-lp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract log probability (target) — fit-method-lp","text":"numeric vector length equal number (post-warmup) draws length equal 1 optimization.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-lp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract log probability (target) — fit-method-lp","text":"lp__ unnormalized log density Stan's unconstrained space. general different unnormalized model log density evaluated posterior draw (constrained space). lp__ intended diagnose sampling efficiency evaluate approximations. variational inference lp_approx__ log density variational approximation lp__ (also unconstrained space). exposed variational method performing checks described Yao et al. (2018) implemented loo package. Laplace approximation lp_approx__ unnormalized density Laplace approximation. can used perform checks case variational method described Yao et al. (2018).","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-lp.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Extract log probability (target) — fit-method-lp","text":"Yao, Y., Vehtari, ., Simpson, D., Gelman, . (2018). Yes, work?: Evaluating variational inference. Proceedings 35th International Conference Machine Learning, PMLR 80:5581–5590.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-lp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract log probability (target) — fit-method-lp","text":"","code":"# \\dontrun{ fit_mcmc <- cmdstanr_example(\"logistic\") head(fit_mcmc$lp()) #> [1] -67.13476 -67.31043 -64.79198 -64.96220 -67.98148 -66.84788  fit_mle <- cmdstanr_example(\"logistic\", method = \"optimize\") fit_mle$lp() #> [1] -63.9218  fit_vb <- cmdstanr_example(\"logistic\", method = \"variational\") plot(fit_vb$lp(), fit_vb$lp_approx())  # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-metadata.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract metadata from CmdStan CSV files — fit-method-metadata","title":"Extract metadata from CmdStan CSV files — fit-method-metadata","text":"$metadata() method returns list information gathered CSV output files, including CmdStan configuration used fitting model. See Examples read_cmdstan_csv().","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-metadata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract metadata from CmdStan CSV files — fit-method-metadata","text":"","code":"metadata()"},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-metadata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract metadata from CmdStan CSV files — fit-method-metadata","text":"","code":"# \\dontrun{ fit_mcmc <- cmdstanr_example(\"logistic\", method = \"sample\") str(fit_mcmc$metadata()) #> List of 42 #>  $ stan_version_major  : num 2 #>  $ stan_version_minor  : num 37 #>  $ stan_version_patch  : num 0 #>  $ start_datetime      : chr \"2025-12-31 18:00:18 UTC\" #>  $ method              : chr \"sample\" #>  $ save_warmup         : int 0 #>  $ thin                : num 1 #>  $ gamma               : num 0.05 #>  $ kappa               : num 0.75 #>  $ t0                  : num 10 #>  $ init_buffer         : num 75 #>  $ term_buffer         : num 50 #>  $ window              : num 25 #>  $ save_metric         : int 0 #>  $ algorithm           : chr \"hmc\" #>  $ engine              : chr \"nuts\" #>  $ metric              : chr \"diag_e\" #>  $ stepsize_jitter     : num 0 #>  $ num_chains          : num 1 #>  $ id                  : num [1:4] 1 2 3 4 #>  $ init                : num [1:4] 2 2 2 2 #>  $ seed                : num 2.02e+09 #>  $ refresh             : num 100 #>  $ sig_figs            : num 8 #>  $ profile_file        : chr \"/tmp/Rtmpaxzs2V/logistic-profile-202512311800-1-87439a.csv\" #>  $ save_cmdstan_config : int 0 #>  $ stanc_version       : chr \"stanc3 v2.37.0\" #>  $ sampler_diagnostics : chr [1:6] \"accept_stat__\" \"stepsize__\" \"treedepth__\" \"n_leapfrog__\" ... #>  $ variables           : chr [1:105] \"lp__\" \"alpha\" \"beta[1]\" \"beta[2]\" ... #>  $ step_size_adaptation: num [1:4] 0.797 0.779 0.701 0.846 #>  $ model_name          : chr \"logistic_model\" #>  $ adapt_engaged       : int 1 #>  $ adapt_delta         : num 0.8 #>  $ max_treedepth       : num 10 #>  $ step_size           : num [1:4] 1 1 1 1 #>  $ iter_warmup         : num 1000 #>  $ iter_sampling       : num 1000 #>  $ threads_per_chain   : num 1 #>  $ time                :'data.frame':\t4 obs. of  4 variables: #>   ..$ chain_id: num [1:4] 1 2 3 4 #>   ..$ warmup  : num [1:4] 0.02 0.019 0.019 0.019 #>   ..$ sampling: num [1:4] 0.054 0.055 0.058 0.053 #>   ..$ total   : num [1:4] 0.074 0.074 0.077 0.072 #>  $ stan_variable_sizes :List of 4 #>   ..$ lp__   : num 1 #>   ..$ alpha  : num 1 #>   ..$ beta   : num 3 #>   ..$ log_lik: num 100 #>  $ stan_variables      : chr [1:4] \"lp__\" \"alpha\" \"beta\" \"log_lik\" #>  $ model_params        : chr [1:105] \"lp__\" \"alpha\" \"beta[1]\" \"beta[2]\" ...  fit_mle <- cmdstanr_example(\"logistic\", method = \"optimize\") str(fit_mle$metadata()) #> List of 32 #>  $ stan_version_major : num 2 #>  $ stan_version_minor : num 37 #>  $ stan_version_patch : num 0 #>  $ start_datetime     : chr \"2025-12-31 18:00:19 UTC\" #>  $ method             : chr \"optimize\" #>  $ algorithm          : chr \"lbfgs\" #>  $ init_alpha         : num 0.001 #>  $ tol_obj            : num 1e-12 #>  $ tol_rel_obj        : num 10000 #>  $ tol_grad           : num 1e-08 #>  $ tol_rel_grad       : num 1e+07 #>  $ tol_param          : num 1e-08 #>  $ history_size       : num 5 #>  $ jacobian           : int 0 #>  $ iter               : num 2000 #>  $ save_iterations    : int 0 #>  $ id                 : num 1 #>  $ init               : num 2 #>  $ seed               : num 1.45e+09 #>  $ refresh            : num 100 #>  $ sig_figs           : num 8 #>  $ profile_file       : chr \"/tmp/Rtmpaxzs2V/logistic-profile-202512311800-1-059841.csv\" #>  $ save_cmdstan_config: int 0 #>  $ stanc_version      : chr \"stanc3 v2.37.0\" #>  $ sampler_diagnostics: chr(0)  #>  $ variables          : chr [1:105] \"lp__\" \"alpha\" \"beta[1]\" \"beta[2]\" ... #>  $ model_name         : chr \"logistic_model\" #>  $ threads            : num 1 #>  $ time               :'data.frame':\t0 obs. of  0 variables #>  $ stan_variable_sizes:List of 4 #>   ..$ lp__   : num 1 #>   ..$ alpha  : num 1 #>   ..$ beta   : num 3 #>   ..$ log_lik: num 100 #>  $ stan_variables     : chr [1:4] \"lp__\" \"alpha\" \"beta\" \"log_lik\" #>  $ model_params       : chr [1:105] \"lp__\" \"alpha\" \"beta[1]\" \"beta[2]\" ...  fit_vb <- cmdstanr_example(\"logistic\", method = \"variational\") str(fit_vb$metadata()) #> List of 30 #>  $ stan_version_major : num 2 #>  $ stan_version_minor : num 37 #>  $ stan_version_patch : num 0 #>  $ start_datetime     : chr \"2025-12-31 18:00:19 UTC\" #>  $ method             : chr \"variational\" #>  $ algorithm          : chr \"meanfield\" #>  $ iter               : num 50 #>  $ grad_samples       : num 1 #>  $ elbo_samples       : num 100 #>  $ eta                : num 1 #>  $ tol_rel_obj        : num 0.01 #>  $ eval_elbo          : num 100 #>  $ output_samples     : num 1000 #>  $ id                 : num 1 #>  $ init               : num 2 #>  $ seed               : num 5.64e+08 #>  $ refresh            : num 100 #>  $ sig_figs           : num 8 #>  $ profile_file       : chr \"/tmp/Rtmpaxzs2V/logistic-profile-202512311800-1-3e064e.csv\" #>  $ save_cmdstan_config: int 0 #>  $ stanc_version      : chr \"stanc3 v2.37.0\" #>  $ sampler_diagnostics: chr(0)  #>  $ variables          : chr [1:106] \"lp__\" \"lp_approx__\" \"alpha\" \"beta[1]\" ... #>  $ model_name         : chr \"logistic_model\" #>  $ adapt_engaged      : int 1 #>  $ threads            : num 1 #>  $ time               :'data.frame':\t0 obs. of  0 variables #>  $ stan_variable_sizes:List of 5 #>   ..$ lp__       : num 1 #>   ..$ lp_approx__: num 1 #>   ..$ alpha      : num 1 #>   ..$ beta       : num 3 #>   ..$ log_lik    : num 100 #>  $ stan_variables     : chr [1:5] \"lp__\" \"lp_approx__\" \"alpha\" \"beta\" ... #>  $ model_params       : chr [1:106] \"lp__\" \"lp_approx__\" \"alpha\" \"beta[1]\" ... # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-mle.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract point estimate after optimization — fit-method-mle","title":"Extract point estimate after optimization — fit-method-mle","text":"$mle() method available CmdStanMLE objects. returns point estimate numeric vector one element per variable. returned vector include lp__, total log probability (target) accumulated model block Stan program, available via $lp() method also included $draws() method. models constrained parameters fit jacobian=TRUE, $mle() method actually returns maximum posteriori (MAP) estimate (posterior mode) rather MLE. See $optimize() CmdStan User's Guide details.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-mle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract point estimate after optimization — fit-method-mle","text":"","code":"mle(variables = NULL)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-mle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract point estimate after optimization — fit-method-mle","text":"variables (character vector) variables (parameters, transformed parameters, generated quantities) include. NULL (default) variables included.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-mle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract point estimate after optimization — fit-method-mle","text":"numeric vector. See Examples.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-mle.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract point estimate after optimization — fit-method-mle","text":"","code":"# \\dontrun{ fit <- cmdstanr_example(\"logistic\", method = \"optimize\") fit$mle(\"alpha\") #>     alpha  #> 0.3644656  fit$mle(\"beta\") #>    beta[1]    beta[2]    beta[3]  #> -0.6315517 -0.2589577  0.6484951  fit$mle(\"beta[2]\") #>    beta[2]  #> -0.2589577  # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-num_chains.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract number of chains after MCMC — fit-method-num_chains","title":"Extract number of chains after MCMC — fit-method-num_chains","text":"$num_chains() method returns number MCMC chains.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-num_chains.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract number of chains after MCMC — fit-method-num_chains","text":"","code":"num_chains()"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-num_chains.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract number of chains after MCMC — fit-method-num_chains","text":"integer.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-num_chains.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract number of chains after MCMC — fit-method-num_chains","text":"","code":"# \\dontrun{ fit_mcmc <- cmdstanr_example(chains = 2) fit_mcmc$num_chains() #> [1] 2 # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-output.html","id":null,"dir":"Reference","previous_headings":"","what":"Access console output — fit-method-output","title":"Access console output — fit-method-output","text":"MCMC, $output() method returns stdout stderr chains list character vectors id=NULL. id argument specified instead pretty prints console output single chain. optimization variational inference $output() just pretty prints console output.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-output.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Access console output — fit-method-output","text":"","code":"output(id = NULL)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-output.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Access console output — fit-method-output","text":"id (integer) chain id. Ignored model fit using MCMC.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-output.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Access console output — fit-method-output","text":"","code":"# \\dontrun{ fit_mcmc <- cmdstanr_example(\"logistic\", method = \"sample\") fit_mcmc$output(1) #>  #> method = sample (Default) #>   sample #>     num_samples = 1000 (Default) #>     num_warmup = 1000 (Default) #>     save_warmup = false (Default) #>     thin = 1 (Default) #>     adapt #>       engaged = true (Default) #>       gamma = 0.05 (Default) #>       delta = 0.8 (Default) #>       kappa = 0.75 (Default) #>       t0 = 10 (Default) #>       init_buffer = 75 (Default) #>       term_buffer = 50 (Default) #>       window = 25 (Default) #>       save_metric = false (Default) #>     algorithm = hmc (Default) #>       hmc #>         engine = nuts (Default) #>           nuts #>             max_depth = 10 (Default) #>         metric = diag_e (Default) #>         metric_file =  (Default) #>         stepsize = 1 (Default) #>         stepsize_jitter = 0 (Default) #>     num_chains = 1 (Default) #> id = 1 (Default) #> data #>   file = /home/runner/work/_temp/Library/cmdstanr/logistic.data.json #> init = 2 (Default) #> random #>   seed = 1078114322 #> output #>   file = /tmp/Rtmpaxzs2V/logistic-202512311800-1-4ec098.csv #>   diagnostic_file =  (Default) #>   refresh = 100 (Default) #>   sig_figs = 8 (Default) #>   profile_file = /tmp/Rtmpaxzs2V/logistic-profile-202512311800-1-94dd11.csv #>   save_cmdstan_config = false (Default) #> num_threads = 1 (Default) #>  #>  #> Gradient evaluation took 7e-06 seconds #> 1000 transitions using 10 leapfrog steps per transition would take 0.07 seconds. #> Adjust your expectations accordingly! #>  #>  #> Iteration:    1 / 2000 [  0%]  (Warmup) #> Iteration:  100 / 2000 [  5%]  (Warmup) #> Iteration:  200 / 2000 [ 10%]  (Warmup) #> Iteration:  300 / 2000 [ 15%]  (Warmup) #> Iteration:  400 / 2000 [ 20%]  (Warmup) #> Iteration:  500 / 2000 [ 25%]  (Warmup) #> Iteration:  600 / 2000 [ 30%]  (Warmup) #> Iteration:  700 / 2000 [ 35%]  (Warmup) #> Iteration:  800 / 2000 [ 40%]  (Warmup) #> Iteration:  900 / 2000 [ 45%]  (Warmup) #> Iteration: 1000 / 2000 [ 50%]  (Warmup) #> Iteration: 1001 / 2000 [ 50%]  (Sampling) #> Iteration: 1100 / 2000 [ 55%]  (Sampling) #> Iteration: 1200 / 2000 [ 60%]  (Sampling) #> Iteration: 1300 / 2000 [ 65%]  (Sampling) #> Iteration: 1400 / 2000 [ 70%]  (Sampling) #> Iteration: 1500 / 2000 [ 75%]  (Sampling) #> Iteration: 1600 / 2000 [ 80%]  (Sampling) #> Iteration: 1700 / 2000 [ 85%]  (Sampling) #> Iteration: 1800 / 2000 [ 90%]  (Sampling) #> Iteration: 1900 / 2000 [ 95%]  (Sampling) #> Iteration: 2000 / 2000 [100%]  (Sampling) #>  #>  Elapsed Time: 0.019 seconds (Warm-up) #>                0.057 seconds (Sampling) #>                0.076 seconds (Total) out <- fit_mcmc$output() str(out) #> List of 4 #>  $ : chr [1:75] \"\" \"method = sample (Default)\" \"  sample\" \"    num_samples = 1000 (Default)\" ... #>  $ : chr [1:75] \"\" \"method = sample (Default)\" \"  sample\" \"    num_samples = 1000 (Default)\" ... #>  $ : chr [1:75] \"\" \"method = sample (Default)\" \"  sample\" \"    num_samples = 1000 (Default)\" ... #>  $ : chr [1:75] \"\" \"method = sample (Default)\" \"  sample\" \"    num_samples = 1000 (Default)\" ...  fit_mle <- cmdstanr_example(\"logistic\", method = \"optimize\") fit_mle$output() #>  #> method = optimize #>   optimize #>     algorithm = lbfgs (Default) #>       lbfgs #>         init_alpha = 0.001 (Default) #>         tol_obj = 1e-12 (Default) #>         tol_rel_obj = 10000 (Default) #>         tol_grad = 1e-08 (Default) #>         tol_rel_grad = 1e+07 (Default) #>         tol_param = 1e-08 (Default) #>         history_size = 5 (Default) #>     jacobian = false (Default) #>     iter = 2000 (Default) #>     save_iterations = false (Default) #> id = 1 (Default) #> data #>   file = /home/runner/work/_temp/Library/cmdstanr/logistic.data.json #> init = 2 (Default) #> random #>   seed = 1549478816 #> output #>   file = /tmp/Rtmpaxzs2V/logistic-202512311800-1-779cf5.csv #>   diagnostic_file =  (Default) #>   refresh = 100 (Default) #>   sig_figs = 8 (Default) #>   profile_file = /tmp/Rtmpaxzs2V/logistic-profile-202512311800-1-04d57d.csv #>   save_cmdstan_config = false (Default) #> num_threads = 1 (Default) #>  #> Initial log joint probability = -163.231 #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes  #>        7      -63.9218   0.000352153    0.00102562       0.944       0.944       11    #> Optimization terminated normally:  #>   Convergence detected: relative gradient magnitude is below tolerance  fit_vb <- cmdstanr_example(\"logistic\", method = \"variational\") fit_vb$output() #>  #> method = variational #>   variational #>     algorithm = meanfield (Default) #>       meanfield #>     iter = 10000 (Default) #>     grad_samples = 1 (Default) #>     elbo_samples = 100 (Default) #>     eta = 1 (Default) #>     adapt #>       engaged = true (Default) #>       iter = 50 (Default) #>     tol_rel_obj = 0.01 (Default) #>     eval_elbo = 100 (Default) #>     output_samples = 1000 (Default) #> id = 1 (Default) #> data #>   file = /home/runner/work/_temp/Library/cmdstanr/logistic.data.json #> init = 2 (Default) #> random #>   seed = 1243032231 #> output #>   file = /tmp/Rtmpaxzs2V/logistic-202512311800-1-047f1c.csv #>   diagnostic_file =  (Default) #>   refresh = 100 (Default) #>   sig_figs = 8 (Default) #>   profile_file = /tmp/Rtmpaxzs2V/logistic-profile-202512311800-1-780abe.csv #>   save_cmdstan_config = false (Default) #> num_threads = 1 (Default) #>  #> ------------------------------------------------------------ #> EXPERIMENTAL ALGORITHM: #>   This procedure has not been thoroughly tested and may be unstable #>   or buggy. The interface is subject to change. #> ------------------------------------------------------------ #>  #>  #>  #> Gradient evaluation took 1.2e-05 seconds #> 1000 transitions using 10 leapfrog steps per transition would take 0.12 seconds. #> Adjust your expectations accordingly! #>  #>  #> Begin eta adaptation. #> Iteration:   1 / 250 [  0%]  (Adaptation) #> Iteration:  50 / 250 [ 20%]  (Adaptation) #> Iteration: 100 / 250 [ 40%]  (Adaptation) #> Iteration: 150 / 250 [ 60%]  (Adaptation) #> Iteration: 200 / 250 [ 80%]  (Adaptation) #> Success! Found best value [eta = 1] earlier than expected. #>  #> Begin stochastic gradient ascent. #>   iter             ELBO   delta_ELBO_mean   delta_ELBO_med   notes  #>    100          -66.476             1.000            1.000 #>    200          -66.497             0.500            1.000 #>    300          -66.520             0.334            0.000   MEDIAN ELBO CONVERGED #>  #> Drawing a sample of size 1000 from the approximate posterior...  #> COMPLETED. # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-profiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Return profiling data — fit-method-profiles","title":"Return profiling data — fit-method-profiles","text":"$profiles() method returns list data frames profiling data profiling data written profile CSV files. See save_profile_files() control files saved. Support profiling Stan programs available CmdStan >= 2.26 requires adding profiling statements Stan program.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-profiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return profiling data — fit-method-profiles","text":"","code":"profiles()"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-profiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return profiling data — fit-method-profiles","text":"list data frames profiling data profiling CSV files created.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-profiles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Return profiling data — fit-method-profiles","text":"","code":"# \\dontrun{ # first fit a model using MCMC mcmc_program <- write_stan_file(   'data {     int<lower=0> N;     array[N] int<lower=0,upper=1> y;   }   parameters {     real<lower=0,upper=1> theta;   }   model {     profile(\"likelihood\") {       y ~ bernoulli(theta);     }   }   generated quantities {     array[N] int y_rep;     profile(\"gq\") {       y_rep = bernoulli_rng(rep_vector(theta, N));     }   } ' ) mod_mcmc <- cmdstan_model(mcmc_program)  data <- list(N = 10, y = c(1,1,0,0,0,1,0,1,0,0)) fit <- mod_mcmc$sample(data = data, seed = 123, refresh = 0) #> Running MCMC with 4 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #> Chain 3 finished in 0.0 seconds. #> Chain 4 finished in 0.0 seconds. #>  #> All 4 chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.5 seconds. #>   fit$profiles() #> [[1]] #>         name       thread_id  total_time forward_time reverse_time chain_stack #> 1 likelihood 140638738282304 0.000760052  0.000541574  0.000218478        6721 #> 2         gq 140638738282304 0.000159391  0.000159391  0.000000000           0 #>   no_chain_stack autodiff_calls no_autodiff_calls #> 1           6721           6721                 1 #> 2              0              0              1000 #>  #> [[2]] #>         name       thread_id  total_time forward_time reverse_time chain_stack #> 1         gq 140067511883584 0.000166736  0.000166736  0.000000000           0 #> 2 likelihood 140067511883584 0.000731558  0.000523824  0.000207734        6792 #>   no_chain_stack autodiff_calls no_autodiff_calls #> 1              0              0              1000 #> 2           6792           6792                 1 #>  #> [[3]] #>         name       thread_id  total_time forward_time reverse_time chain_stack #> 1         gq 139732032702272 0.000164966  0.000164966  0.000000000           0 #> 2 likelihood 139732032702272 0.000741245  0.000533354  0.000207891        6797 #>   no_chain_stack autodiff_calls no_autodiff_calls #> 1              0              0              1000 #> 2           6797           6797                 1 #>  #> [[4]] #>         name       thread_id  total_time forward_time reverse_time chain_stack #> 1         gq 140719613302592 0.000161965  0.000161965  0.000000000           0 #> 2 likelihood 140719613302592 0.000765089  0.000538395  0.000226694        6979 #>   no_chain_stack autodiff_calls no_autodiff_calls #> 1              0              0              1000 #> 2           6979           6979                 1 #>  # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-return_codes.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract return codes from CmdStan — fit-method-return_codes","title":"Extract return codes from CmdStan — fit-method-return_codes","text":"$return_codes() method returns vector return codes CmdStan run(s). return code 0 indicates successful run.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-return_codes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract return codes from CmdStan — fit-method-return_codes","text":"","code":"return_codes()"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-return_codes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract return codes from CmdStan — fit-method-return_codes","text":"integer vector return codes length equal number CmdStan runs (number chains MCMC one otherwise).","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-return_codes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract return codes from CmdStan — fit-method-return_codes","text":"","code":"# \\dontrun{ # example with return codes all zero fit_mcmc <- cmdstanr_example(\"schools\", method = \"sample\") #> Warning: 198 of 4000 (5.0%) transitions ended with a divergence. #> See https://mc-stan.org/misc/warnings for details. #> Warning: 2 of 4 chains had an E-BFMI less than 0.3. #> See https://mc-stan.org/misc/warnings for details. fit_mcmc$return_codes() # should be all zero #> [1] 0 0 0 0  # example of non-zero return code (optimization fails for hierarchical model) fit_opt <- cmdstanr_example(\"schools\", method = \"optimize\") #> Chain 1 Optimization terminated with error:  #> Chain 1   Line search failed to achieve a sufficient decrease, no more progress can be made #> Warning: Fitting finished unexpectedly! Use the $output() method for more information. fit_opt$return_codes() # should be non-zero #> [1] 1 # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-sampler_diagnostics.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract sampler diagnostics after MCMC — fit-method-sampler_diagnostics","title":"Extract sampler diagnostics after MCMC — fit-method-sampler_diagnostics","text":"Extract values sampler diagnostics iteration chain MCMC. instead get summaries diagnostics associated warning messages use $diagnostic_summary() method.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-sampler_diagnostics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract sampler diagnostics after MCMC — fit-method-sampler_diagnostics","text":"","code":"sampler_diagnostics(   inc_warmup = FALSE,   format = getOption(\"cmdstanr_draws_format\", \"draws_array\") )"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-sampler_diagnostics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract sampler diagnostics after MCMC — fit-method-sampler_diagnostics","text":"inc_warmup (logical) warmup draws included? Defaults FALSE. format (string) draws format return. See draws details.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-sampler_diagnostics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract sampler diagnostics after MCMC — fit-method-sampler_diagnostics","text":"Depends format, default 3-D draws_array object (iteration x chain x variable). variables Stan's default MCMC algorithm \"accept_stat__\", \"stepsize__\", \"treedepth__\", \"n_leapfrog__\", \"divergent__\", \"energy__\".","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-sampler_diagnostics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract sampler diagnostics after MCMC — fit-method-sampler_diagnostics","text":"","code":"# \\dontrun{ fit <- cmdstanr_example(\"logistic\") sampler_diagnostics <- fit$sampler_diagnostics() str(sampler_diagnostics) #>  'draws_array' num [1:1000, 1:4, 1:6] 3 2 2 2 2 2 2 3 3 2 ... #>  - attr(*, \"dimnames\")=List of 3 #>   ..$ iteration: chr [1:1000] \"1\" \"2\" \"3\" \"4\" ... #>   ..$ chain    : chr [1:4] \"1\" \"2\" \"3\" \"4\" #>   ..$ variable : chr [1:6] \"treedepth__\" \"divergent__\" \"energy__\" \"accept_stat__\" ...  library(posterior) as_draws_df(sampler_diagnostics) #> # A draws_df: 1000 iterations, 4 chains, and 6 variables #>    treedepth__ divergent__ energy__ accept_stat__ stepsize__ n_leapfrog__ #> 1            3           0       67          0.84       0.77            7 #> 2            2           0       68          0.75       0.77            3 #> 3            2           0       67          0.92       0.77            3 #> 4            2           0       69          0.69       0.77            3 #> 5            2           0       65          0.95       0.77            3 #> 6            2           0       66          0.96       0.77            7 #> 7            2           0       65          1.00       0.77            3 #> 8            3           0       66          0.96       0.77            7 #> 9            3           0       65          0.97       0.77            7 #> 10           2           0       67          0.83       0.77            3 #> # ... with 3990 more draws #> # ... hidden reserved variables {'.chain', '.iteration', '.draw'}  # or specify format to get a data frame instead of calling as_draws_df fit$sampler_diagnostics(format = \"df\") #> # A draws_df: 1000 iterations, 4 chains, and 6 variables #>    treedepth__ divergent__ energy__ accept_stat__ stepsize__ n_leapfrog__ #> 1            3           0       67          0.84       0.77            7 #> 2            2           0       68          0.75       0.77            3 #> 3            2           0       67          0.92       0.77            3 #> 4            2           0       69          0.69       0.77            3 #> 5            2           0       65          0.95       0.77            3 #> 6            2           0       66          0.96       0.77            7 #> 7            2           0       65          1.00       0.77            3 #> 8            3           0       66          0.96       0.77            7 #> 9            3           0       65          0.97       0.77            7 #> 10           2           0       67          0.83       0.77            3 #> # ... with 3990 more draws #> # ... hidden reserved variables {'.chain', '.iteration', '.draw'} # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-save_object.html","id":null,"dir":"Reference","previous_headings":"","what":"Save fitted model object to a file — fit-method-save_object","title":"Save fitted model object to a file — fit-method-save_object","text":"method wrapper around base::saveRDS() ensures posterior draws diagnostics saved saving fitted model object. contents CmdStan output CSV files read R lazily (.e., needed), $save_object() method safest way guarantee everything read saving. See \"Saving fitted model objects\" section Getting started CmdStanR vignette suggestions faster model saving large models.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-save_object.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save fitted model object to a file — fit-method-save_object","text":"","code":"save_object(file, ...)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-save_object.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Save fitted model object to a file — fit-method-save_object","text":"file (string) Path file saved. ... arguments pass base::saveRDS() besides object file.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-save_object.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Save fitted model object to a file — fit-method-save_object","text":"","code":"# \\dontrun{ fit <- cmdstanr_example(\"logistic\")  temp_rds_file <- tempfile(fileext = \".RDS\") fit$save_object(file = temp_rds_file) rm(fit)  fit <- readRDS(temp_rds_file) fit$summary() #> # A tibble: 105 × 10 #>    variable      mean  median     sd    mad       q5      q95  rhat ess_bulk #>    <chr>        <dbl>   <dbl>  <dbl>  <dbl>    <dbl>    <dbl> <dbl>    <dbl> #>  1 lp__       -65.9   -65.6   1.39   1.20   -68.6    -64.3    1.000    1923. #>  2 alpha        0.378   0.378 0.210  0.211    0.0373   0.725  1.00     4192. #>  3 beta[1]     -0.667  -0.658 0.241  0.241   -1.07    -0.270  1.000    3920. #>  4 beta[2]     -0.273  -0.273 0.229  0.229   -0.658    0.0969 1.000    4228. #>  5 beta[3]      0.680   0.678 0.268  0.262    0.243    1.13   1.00     4100. #>  6 log_lik[1]  -0.516  -0.508 0.0963 0.0940  -0.685   -0.367  1.000    4194. #>  7 log_lik[2]  -0.402  -0.381 0.145  0.139   -0.665   -0.200  1.000    4540. #>  8 log_lik[3]  -0.498  -0.462 0.217  0.204   -0.904   -0.208  1.00     4443. #>  9 log_lik[4]  -0.450  -0.432 0.152  0.143   -0.726   -0.236  1.00     3935. #> 10 log_lik[5]  -1.18   -1.16  0.277  0.274   -1.68    -0.758  1.00     4757. #> # ℹ 95 more rows #> # ℹ 1 more variable: ess_tail <dbl> # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-save_output_files.html","id":null,"dir":"Reference","previous_headings":"","what":"Save output and data files — fit-method-save_output_files","title":"Save output and data files — fit-method-save_output_files","text":"fitted model objects methods saving (moving specified location) files created CmdStanR hold CmdStan output csv files input data files. methods move files current location (possibly temporary directory) user-specified location. paths stored fitted model object also updated point new file locations. versions without save_ prefix (e.g., $output_files()) return current file paths without moving files.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-save_output_files.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save output and data files — fit-method-save_output_files","text":"","code":"save_output_files(dir = \".\", basename = NULL, timestamp = TRUE, random = TRUE)  save_latent_dynamics_files(   dir = \".\",   basename = NULL,   timestamp = TRUE,   random = TRUE )  save_profile_files(dir = \".\", basename = NULL, timestamp = TRUE, random = TRUE)  save_data_file(dir = \".\", basename = NULL, timestamp = TRUE, random = TRUE)  save_config_files(dir = \".\", basename = NULL, timestamp = TRUE, random = TRUE)  save_metric_files(dir = \".\", basename = NULL, timestamp = TRUE, random = TRUE)  output_files(include_failed = FALSE)  profile_files(include_failed = FALSE)  latent_dynamics_files(include_failed = FALSE)  data_file()  config_files(include_failed = FALSE)  metric_files(include_failed = FALSE)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-save_output_files.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Save output and data files — fit-method-save_output_files","text":"dir (string) Path directory files saved. basename (string) Base filename use. See Details. timestamp (logical) timestamp added file name(s)? Defaults TRUE. See Details. random (logical) random alphanumeric characters added end file name(s)? Defaults TRUE. See Details. include_failed (logical) CmdStan runs failed also included? default FALSE.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-save_output_files.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Save output and data files — fit-method-save_output_files","text":"$save_* methods print message new file paths (invisibly) return character vector new paths (NA copied). also side effect setting internal paths fitted model object new paths. methods without save_ prefix return character vectors file paths without moving files.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-save_output_files.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Save output and data files — fit-method-save_output_files","text":"$save_output_files() files moved dir names form basename-timestamp-id-random, basename user's provided basename argument; timestamp form format(Sys.time(), \"%Y%m%d%H%M\"); id MCMC chain id (1 non MCMC); random contains six random alphanumeric characters; $save_latent_dynamics_files() everything $save_output_files() except \"-diagnostic-\" included new file name basename. $save_profile_files() everything $save_output_files() except \"-profile-\" included new file name basename. $save_metric_files() everything $save_output_files() except \"-metric-\" included new file name basename. $save_config_files() everything $save_output_files() except \"-config-\" included new file name basename. $save_data_file() id included file name even multiple MCMC chains data file .","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-save_output_files.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Save output and data files — fit-method-save_output_files","text":"","code":"# \\dontrun{ fit <- cmdstanr_example() fit$output_files() #> [1] \"/tmp/Rtmpaxzs2V/logistic-202512311800-1-309b35.csv\" #> [2] \"/tmp/Rtmpaxzs2V/logistic-202512311800-2-309b35.csv\" #> [3] \"/tmp/Rtmpaxzs2V/logistic-202512311800-3-309b35.csv\" #> [4] \"/tmp/Rtmpaxzs2V/logistic-202512311800-4-309b35.csv\" fit$data_file() #> [1] \"/home/runner/work/_temp/Library/cmdstanr/logistic.data.json\"  # just using tempdir for the example my_dir <- tempdir() fit$save_output_files(dir = my_dir, basename = \"banana\") #> Moved 4 files and set internal paths to new locations: #> - /tmp/Rtmpaxzs2V/banana-202512311800-1-0f8a90.csv #> - /tmp/Rtmpaxzs2V/banana-202512311800-2-0f8a90.csv #> - /tmp/Rtmpaxzs2V/banana-202512311800-3-0f8a90.csv #> - /tmp/Rtmpaxzs2V/banana-202512311800-4-0f8a90.csv fit$save_output_files(dir = my_dir, basename = \"tomato\", timestamp = FALSE) #> Moved 4 files and set internal paths to new locations: #> - /tmp/Rtmpaxzs2V/tomato-1-7a3358.csv #> - /tmp/Rtmpaxzs2V/tomato-2-7a3358.csv #> - /tmp/Rtmpaxzs2V/tomato-3-7a3358.csv #> - /tmp/Rtmpaxzs2V/tomato-4-7a3358.csv fit$save_output_files(dir = my_dir, basename = \"lettuce\", timestamp = FALSE, random = FALSE) #> Moved 4 files and set internal paths to new locations: #> - /tmp/Rtmpaxzs2V/lettuce-1.csv #> - /tmp/Rtmpaxzs2V/lettuce-2.csv #> - /tmp/Rtmpaxzs2V/lettuce-3.csv #> - /tmp/Rtmpaxzs2V/lettuce-4.csv # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-summary.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute a summary table of estimates and diagnostics — fit-method-summary","title":"Compute a summary table of estimates and diagnostics — fit-method-summary","text":"$summary() method runs summarise_draws() posterior package returns output. MCMC, post-warmup draws included summary. also $print() method prints summary stats removes extra formatting used printing tibbles returns fitted model object . $print() method may also faster $summary() designed compute summary statistics variables actually fit printed output whereas $summary() compute specified variables order able return user. See Examples.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-summary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute a summary table of estimates and diagnostics — fit-method-summary","text":"","code":"summary(variables = NULL, ...)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-summary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute a summary table of estimates and diagnostics — fit-method-summary","text":"variables (character vector) variables include. ... Optional arguments pass posterior::summarise_draws().","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-summary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute a summary table of estimates and diagnostics — fit-method-summary","text":"$summary() method returns tibble data frame created posterior::summarise_draws(). $print() method returns fitted model object (invisibly), standard behavior print methods R.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-summary.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute a summary table of estimates and diagnostics — fit-method-summary","text":"","code":"# \\dontrun{ fit <- cmdstanr_example(\"logistic\") fit$summary() #> # A tibble: 105 × 10 #>    variable      mean  median     sd   mad       q5      q95  rhat ess_bulk #>    <chr>        <dbl>   <dbl>  <dbl> <dbl>    <dbl>    <dbl> <dbl>    <dbl> #>  1 lp__       -66.0   -65.7   1.39   1.24  -68.7    -64.3    1.000    2291. #>  2 alpha        0.374   0.375 0.220  0.221   0.0112   0.738  1.00     4133. #>  3 beta[1]     -0.666  -0.664 0.248  0.249  -1.08    -0.257  1.00     4471. #>  4 beta[2]     -0.269  -0.267 0.226  0.223  -0.638    0.0973 1.00     4317. #>  5 beta[3]      0.675   0.670 0.269  0.279   0.247    1.12   1.00     3731. #>  6 log_lik[1]  -0.517  -0.511 0.0992 0.101  -0.691   -0.366  1.00     4316. #>  7 log_lik[2]  -0.402  -0.384 0.145  0.135  -0.669   -0.198  1.000    4685. #>  8 log_lik[3]  -0.497  -0.459 0.219  0.203  -0.903   -0.207  1.000    4355. #>  9 log_lik[4]  -0.451  -0.432 0.151  0.147  -0.719   -0.238  1.00     3915. #> 10 log_lik[5]  -1.18   -1.16  0.285  0.280  -1.68    -0.750  1.00     4011. #> # ℹ 95 more rows #> # ℹ 1 more variable: ess_tail <dbl> fit$print() #>    variable   mean median   sd  mad     q5    q95 rhat ess_bulk ess_tail #>  lp__       -65.97 -65.67 1.39 1.24 -68.70 -64.29 1.00     2291     3113 #>  alpha        0.37   0.37 0.22 0.22   0.01   0.74 1.00     4133     3016 #>  beta[1]     -0.67  -0.66 0.25 0.25  -1.08  -0.26 1.00     4471     2959 #>  beta[2]     -0.27  -0.27 0.23 0.22  -0.64   0.10 1.00     4317     3349 #>  beta[3]      0.67   0.67 0.27 0.28   0.25   1.12 1.00     3731     3333 #>  log_lik[1]  -0.52  -0.51 0.10 0.10  -0.69  -0.37 1.00     4316     3363 #>  log_lik[2]  -0.40  -0.38 0.15 0.14  -0.67  -0.20 1.00     4684     3591 #>  log_lik[3]  -0.50  -0.46 0.22 0.20  -0.90  -0.21 1.00     4355     3326 #>  log_lik[4]  -0.45  -0.43 0.15 0.15  -0.72  -0.24 1.00     3915     3271 #>  log_lik[5]  -1.18  -1.16 0.28 0.28  -1.68  -0.75 1.00     4010     3092 #>  #>  # showing 10 of 105 rows (change via 'max_rows' argument or 'cmdstanr_max_rows' option) fit$print(max_rows = 2) # same as print(fit, max_rows = 2) #>  variable   mean median   sd  mad     q5    q95 rhat ess_bulk ess_tail #>     lp__  -65.97 -65.67 1.39 1.24 -68.70 -64.29 1.00     2291     3113 #>     alpha   0.37   0.37 0.22 0.22   0.01   0.74 1.00     4133     3016 #>  #>  # showing 2 of 105 rows (change via 'max_rows' argument or 'cmdstanr_max_rows' option)  # include only certain variables fit$summary(\"beta\") #> # A tibble: 3 × 10 #>   variable   mean median    sd   mad     q5     q95  rhat ess_bulk ess_tail #>   <chr>     <dbl>  <dbl> <dbl> <dbl>  <dbl>   <dbl> <dbl>    <dbl>    <dbl> #> 1 beta[1]  -0.666 -0.664 0.248 0.249 -1.08  -0.257   1.00    4471.    2959. #> 2 beta[2]  -0.269 -0.267 0.226 0.223 -0.638  0.0973  1.00    4317.    3350. #> 3 beta[3]   0.675  0.670 0.269 0.279  0.247  1.12    1.00    3731.    3334. fit$print(c(\"alpha\", \"beta[2]\")) #>  variable  mean median   sd  mad    q5  q95 rhat ess_bulk ess_tail #>   alpha    0.37   0.37 0.22 0.22  0.01 0.74 1.00     4133     3016 #>   beta[2] -0.27  -0.27 0.23 0.22 -0.64 0.10 1.00     4317     3349  # include all variables but only certain summaries fit$summary(NULL, c(\"mean\", \"sd\")) #> # A tibble: 105 × 3 #>    variable      mean     sd #>    <chr>        <dbl>  <dbl> #>  1 lp__       -66.0   1.39   #>  2 alpha        0.374 0.220  #>  3 beta[1]     -0.666 0.248  #>  4 beta[2]     -0.269 0.226  #>  5 beta[3]      0.675 0.269  #>  6 log_lik[1]  -0.517 0.0992 #>  7 log_lik[2]  -0.402 0.145  #>  8 log_lik[3]  -0.497 0.219  #>  9 log_lik[4]  -0.451 0.151  #> 10 log_lik[5]  -1.18  0.285  #> # ℹ 95 more rows  # can use functions created from formulas # for example, calculate Pr(beta > 0) fit$summary(\"beta\", prob_gt_0 = ~ mean(. > 0)) #> # A tibble: 3 × 2 #>   variable prob_gt_0 #>   <chr>        <dbl> #> 1 beta[1]    0.00225 #> 2 beta[2]    0.114   #> 3 beta[3]    0.997    # can combine user-specified functions with # the default summary functions fit$summary(variables = c(\"alpha\", \"beta\"),   posterior::default_summary_measures()[1:4],   quantiles = ~ quantile2(., probs = c(0.025, 0.975)),   posterior::default_convergence_measures()   ) #> # A tibble: 4 × 10 #>   variable   mean median    sd   mad    q2.5  q97.5  rhat ess_bulk ess_tail #>   <chr>     <dbl>  <dbl> <dbl> <dbl>   <dbl>  <dbl> <dbl>    <dbl>    <dbl> #> 1 alpha     0.374  0.375 0.220 0.221 -0.0414  0.824  1.00    4133.    3017. #> 2 beta[1]  -0.666 -0.664 0.248 0.249 -1.17   -0.186  1.00    4471.    2959. #> 3 beta[2]  -0.269 -0.267 0.226 0.223 -0.713   0.166  1.00    4317.    3350. #> 4 beta[3]   0.675  0.670 0.269 0.279  0.170   1.21   1.00    3731.    3334.  # the functions need to calculate the appropriate # value for a matrix input fit$summary(variables = \"alpha\", dim) #> # A tibble: 1 × 3 #>   variable dim.1 dim.2 #>   <chr>    <int> <int> #> 1 alpha     1000     4  # the usual [stats::var()] is therefore not directly suitable as it # will produce a covariance matrix unless the data is converted to a vector fit$print(c(\"alpha\", \"beta\"), var2 = ~var(as.vector(.x))) #>  variable var2 #>   alpha   0.05 #>   beta[1] 0.06 #>   beta[2] 0.05 #>   beta[3] 0.07  # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-time.html","id":null,"dir":"Reference","previous_headings":"","what":"Report timing of CmdStan runs — fit-method-time","title":"Report timing of CmdStan runs — fit-method-time","text":"Report run time seconds. MCMC additional information provided run times individual chains warmup sampling phases. Laplace approximation time include time drawing approximate sample include time taken run $optimize() method.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Report timing of CmdStan runs — fit-method-time","text":"","code":"time()"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Report timing of CmdStan runs — fit-method-time","text":"list elements total: (scalar) total run time. MCMC may different sum chain run times parallelization used. chains: (data frame) MCMC , timing info individual chains. data frame columns \"chain_id\", \"warmup\", \"sampling\", \"total\".","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-time.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Report timing of CmdStan runs — fit-method-time","text":"","code":"# \\dontrun{ fit_mcmc <- cmdstanr_example(\"logistic\", method = \"sample\") fit_mcmc$time() #> $total #> [1] 0.5083249 #>  #> $chains #>   chain_id warmup sampling total #> 1        1  0.019    0.056 0.075 #> 2        2  0.019    0.052 0.071 #> 3        3  0.019    0.056 0.075 #> 4        4  0.019    0.057 0.076 #>   fit_vb <- cmdstanr_example(\"logistic\", method = \"variational\") fit_vb$time() #> $total #> [1] 0.1206679 #>   fit_mle <- cmdstanr_example(\"logistic\", method = \"optimize\", jacobian = TRUE) fit_mle$time() #> $total #> [1] 0.1226351 #>   # use fit_mle to draw samples from laplace approximation fit_laplace <- cmdstanr_example(\"logistic\", method = \"laplace\", mode = fit_mle) fit_laplace$time() # just time for drawing sample not for running optimize #> $total #> [1] 0.1225524 #>  fit_laplace$time()$total + fit_mle$time()$total # total time #> [1] 0.2451875 # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-unconstrain_draws.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform all parameter draws to the unconstrained scale — fit-method-unconstrain_draws","title":"Transform all parameter draws to the unconstrained scale — fit-method-unconstrain_draws","text":"$unconstrain_draws() method transforms parameter draws unconstrained scale. method returns list chain, containing parameter values iteration unconstrained scale. called arguments, draws within fit object unconstrained. Alternatively, either existing draws object character vector paths CSV files can passed.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-unconstrain_draws.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform all parameter draws to the unconstrained scale — fit-method-unconstrain_draws","text":"","code":"unconstrain_draws(   files = NULL,   draws = NULL,   format = getOption(\"cmdstanr_draws_format\", \"draws_array\"),   inc_warmup = FALSE )"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-unconstrain_draws.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform all parameter draws to the unconstrained scale — fit-method-unconstrain_draws","text":"files (character vector) paths CmdStan CSV files. can files generated running CmdStanR running CmdStan directly. draws posterior::draws_* object. format (string) format returned draws. Must valid format posterior package. inc_warmup (logical) warmup draws included? Defaults FALSE.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-unconstrain_draws.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform all parameter draws to the unconstrained scale — fit-method-unconstrain_draws","text":"","code":"# \\dontrun{ fit_mcmc <- cmdstanr_example(\"logistic\", method = \"sample\", force_recompile = TRUE)  # Unconstrain all internal draws unconstrained_internal_draws <- fit_mcmc$unconstrain_draws()  # Unconstrain external CmdStan CSV files unconstrained_csv <- fit_mcmc$unconstrain_draws(files = fit_mcmc$output_files())  # Unconstrain existing draws object unconstrained_draws <- fit_mcmc$unconstrain_draws(draws = fit_mcmc$draws()) # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-unconstrain_variables.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform a set of parameter values to the unconstrained scale — fit-method-unconstrain_variables","title":"Transform a set of parameter values to the unconstrained scale — fit-method-unconstrain_variables","text":"$unconstrain_variables() method transforms input parameters unconstrained scale.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-unconstrain_variables.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform a set of parameter values to the unconstrained scale — fit-method-unconstrain_variables","text":"","code":"unconstrain_variables(variables)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-unconstrain_variables.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform a set of parameter values to the unconstrained scale — fit-method-unconstrain_variables","text":"variables (list) list parameter values transform, format provided init argument $sample() method.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-unconstrain_variables.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform a set of parameter values to the unconstrained scale — fit-method-unconstrain_variables","text":"","code":"# \\dontrun{ fit_mcmc <- cmdstanr_example(\"logistic\", method = \"sample\", force_recompile = TRUE) fit_mcmc$unconstrain_variables(list(alpha = 0.5, beta = c(0.7, 1.1, 0.2))) #> [1] 0.5 0.7 1.1 0.2 # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-variable_skeleton.html","id":null,"dir":"Reference","previous_headings":"","what":"Return the variable skeleton for relist — fit-method-variable_skeleton","title":"Return the variable skeleton for relist — fit-method-variable_skeleton","text":"$variable_skeleton() method returns variable skeleton needed utils::relist() re-structure vector constrained parameter values named list.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-variable_skeleton.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return the variable skeleton for relist — fit-method-variable_skeleton","text":"","code":"variable_skeleton(transformed_parameters = TRUE, generated_quantities = TRUE)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-variable_skeleton.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return the variable skeleton for relist — fit-method-variable_skeleton","text":"transformed_parameters (logical) Whether include transformed parameters skeleton (defaults TRUE). generated_quantities (logical) Whether include generated quantities skeleton (defaults TRUE).","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/fit-method-variable_skeleton.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Return the variable skeleton for relist — fit-method-variable_skeleton","text":"","code":"# \\dontrun{ fit_mcmc <- cmdstanr_example(\"logistic\", method = \"sample\", force_recompile = TRUE) fit_mcmc$variable_skeleton() #> $alpha #> [1] 0 #>  #> $beta #> [1] 0 0 0 #>  #> $log_lik #>   [1] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #>  [38] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #>  [75] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 #>  # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/install_cmdstan.html","id":null,"dir":"Reference","previous_headings":"","what":"Install CmdStan or clean and rebuild an existing installation — install_cmdstan","title":"Install CmdStan or clean and rebuild an existing installation — install_cmdstan","text":"install_cmdstan() function attempts download install latest release CmdStan. Installing previous release new release candidate also possible specifying version release_url argument. See first sections CmdStan installation guide details C++ toolchain required installing CmdStan. rebuild_cmdstan() function cleans rebuilds CmdStan installation. Use function case issues compiling models. cmdstan_make_local() function used read/write makefile flags variables /make/local file CmdStan installation. Writing make/local file can used permanently add makefile flags/variables installation. example adding specific compiler switches, changing C++ compiler, etc. change make/local file typically followed calling rebuild_cmdstan(). check_cmdstan_toolchain() function attempts check required C++ toolchain. called internally install_cmdstan() can also called directly user. Windows , calling function fix = TRUE argument attempt install necessary toolchain components found. Windows users RTools CmdStan versions >= 2.35 additional toolchain configuration required. NOTE: installing CmdStan Windows RTools CmdStan versions prior 2.35.0, additional toolchain configuration still required. enable configuration, set environment variable CMDSTANR_USE_MSYS_TOOLCHAIN 'true' call check_cmdstan_toolchain(fix = TRUE).","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/install_cmdstan.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Install CmdStan or clean and rebuild an existing installation — install_cmdstan","text":"","code":"install_cmdstan(   dir = NULL,   cores = getOption(\"mc.cores\", 2),   quiet = FALSE,   overwrite = FALSE,   timeout = 1200,   version = NULL,   release_url = NULL,   release_file = NULL,   cpp_options = list(),   check_toolchain = TRUE,   wsl = FALSE )  rebuild_cmdstan(   dir = cmdstan_path(),   cores = getOption(\"mc.cores\", 2),   quiet = FALSE,   timeout = 600 )  cmdstan_make_local(dir = cmdstan_path(), cpp_options = NULL, append = TRUE)  check_cmdstan_toolchain(fix = FALSE, quiet = FALSE)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/install_cmdstan.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Install CmdStan or clean and rebuild an existing installation — install_cmdstan","text":"dir (string) path directory install CmdStan. default install directory called .cmdstan within user's home directory (.e, file.path(Sys.getenv(\"HOME\"), \".cmdstan\")). cores (integer) number CPU cores use parallelize building CmdStan speed installation. cores specified default look option \"mc.cores\", can set entire R session options(mc.cores=value). \"mc.cores\" option set default 2. quiet (logical) install_cmdstan(), verbose output system processes suppressed building CmdStan binaries? default FALSE. check_cmdstan_toolchain(), function suppress printing informational messages? default FALSE. TRUE errors printed. overwrite (logical) CmdStan still downloaded installed even installation version found dir? default FALSE, case informative error thrown instead overwriting user's installation. timeout (positive real) Timeout (seconds) build stage installation. version (string) CmdStan release version install. default NULL, downloads latest stable release https://github.com/stan-dev/cmdstan/releases. release_url (string) URL specific CmdStan release release candidate install. See https://github.com/stan-dev/cmdstan/releases. URL point tarball (.tar.gz. file) , e.g., release_url=\"https://github.com/stan-dev/cmdstan/releases/download/v2.25.0/cmdstan-2.25.0.tar.gz\". version release_url specified version used. release_file (string) file path CmdStan release tar.gz file downloaded releases page: https://github.com/stan-dev/cmdstan/releases. example: release_file=\"\"./cmdstan-2.33.1.tar.gz\". release_file specified release_url version ignored. cpp_options (list) makefile flags/variables written make/local file. example, list(\"CXX\" = \"clang++\") force use clang compilation. check_toolchain (logical) install_cmdstan() attempt check required toolchain installed properly configured. default TRUE. wsl (logical) CmdStan installed run Windows Subsystem Linux (WSL). default FALSE. append (logical) cmdstan_make_local(), listed makefile flags appended end existing make/local file? default TRUE. FALSE file overwritten. fix check_cmdstan_toolchain(), CmdStanR attempt fix detected toolchain problems? Currently option available Windows. default FALSE, case problems reported along suggested fixes.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/install_cmdstan.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Install CmdStan or clean and rebuild an existing installation — install_cmdstan","text":"cmdstan_make_local(), cpp_options=NULL existing contents make/local returned without writing anything, otherwise updated contents returned.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/install_cmdstan.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Install CmdStan or clean and rebuild an existing installation — install_cmdstan","text":"","code":"# \\dontrun{ check_cmdstan_toolchain() #> The C++ toolchain required for CmdStan is setup properly!  # install_cmdstan(cores = 4)  cpp_options <- list(   \"CXX\" = \"clang++\",   \"CXXFLAGS+= -march=native\",   PRECOMPILED_HEADERS = TRUE ) # cmdstan_make_local(cpp_options = cpp_options) # rebuild_cmdstan() # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-check_syntax.html","id":null,"dir":"Reference","previous_headings":"","what":"Check syntax of a Stan program — model-method-check_syntax","title":"Check syntax of a Stan program — model-method-check_syntax","text":"$check_syntax() method CmdStanModel object checks Stan program syntax errors returns TRUE (invisibly) parsing succeeds. invalid syntax found error thrown.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-check_syntax.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check syntax of a Stan program — model-method-check_syntax","text":"","code":"check_syntax(   pedantic = FALSE,   include_paths = NULL,   stanc_options = list(),   quiet = FALSE )"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-check_syntax.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check syntax of a Stan program — model-method-check_syntax","text":"pedantic (logical) pedantic mode turned ? default FALSE. Pedantic mode attempts warn potential issues Stan program beyond syntax errors. details see Pedantic mode chapter Stan Reference Manual. include_paths (character vector) Paths directories Stan look files specified #include directives Stan program. stanc_options (list) Stan--C++ transpiler options used compiling model. See documentation $compile() method details. quiet (logical) informational messages suppressed? default FALSE, print message Stan program valid compiler error message syntax errors. TRUE, error message printed.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-check_syntax.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check syntax of a Stan program — model-method-check_syntax","text":"$check_syntax() method returns TRUE (invisibly) model valid.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-check_syntax.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check syntax of a Stan program — model-method-check_syntax","text":"","code":"# \\dontrun{ file <- write_stan_file(\" data {   int N;   array[N] int y; } parameters {   // should have <lower=0> but omitting to demonstrate pedantic mode   real lambda; } model {   y ~ poisson(lambda); } \") mod <- cmdstan_model(file, compile = FALSE)  # the program is syntactically correct, however... mod$check_syntax() #> Stan program is syntactically correct  # pedantic mode will warn that lambda should be constrained to be positive # and that lambda has no prior distribution mod$check_syntax(pedantic = TRUE) #> Warning in '/tmp/Rtmpaxzs2V/model_febb1e69c7387a0e64cf13583e078104.stan', line 11, column 14: A #>     poisson distribution is given parameter lambda as a rate parameter #>     (argument 1), but lambda was not constrained to be strictly positive. #> Warning: The parameter lambda has no priors. This means either no prior is #>     provided, or the prior(s) depend on data variables. In the later case, #>     this may be a false positive. #> Stan program is syntactically correct # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-compile.html","id":null,"dir":"Reference","previous_headings":"","what":"Compile a Stan program — model-method-compile","title":"Compile a Stan program — model-method-compile","text":"$compile() method CmdStanModel object checks syntax Stan program, translates program C++, creates compiled executable. just check syntax Stan program without compiling use $check_syntax() method instead. cases user need explicitly call $compile() method compilation occur calling cmdstan_model(). However possible set compile=FALSE call cmdstan_model() subsequently call $compile() method directly. compilation, paths executable .hpp file containing generated C++ code available via $exe_file() $hpp_file() methods. default create executable directory Stan program write generated C++ code temporary directory. save C++ code non-temporary location use $save_hpp_file(dir).","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-compile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compile a Stan program — model-method-compile","text":"","code":"compile(   quiet = TRUE,   dir = NULL,   pedantic = FALSE,   include_paths = NULL,   user_header = NULL,   cpp_options = list(),   stanc_options = list(),   force_recompile = getOption(\"cmdstanr_force_recompile\", default = FALSE),   compile_model_methods = FALSE,   compile_standalone = FALSE,   dry_run = FALSE,   compile_hessian_method = FALSE,   threads = FALSE )"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-compile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compile a Stan program — model-method-compile","text":"quiet (logical) verbose output CmdStan compilation suppressed? default TRUE, encounter error recommend trying quiet=FALSE see output. dir (string) path directory store CmdStan executable (.hpp file using $save_hpp_file()). default location Stan program. pedantic (logical) pedantic mode turned ? default FALSE. Pedantic mode attempts warn potential issues Stan program beyond syntax errors. details see Pedantic mode section Stan Reference Manual. Note: pedantic check model without compiling model already compiled $check_syntax() method can used instead. include_paths (character vector) Paths directories Stan look files specified #include directives Stan program. user_header (string) path C++ file (.hpp extension) compile Stan model. cpp_options (list) makefile options used compiling model (STAN_THREADS, STAN_MPI, STAN_OPENCL, etc.). Anything otherwise write make/local file. example using threading see Stan case study Reduce Sum: Minimal Example. stanc_options (list) Stan--C++ transpiler options used compiling model. See Examples section well stanc chapter CmdStan Guide details available options: https://mc-stan.org/docs/cmdstan-guide/stanc.html. force_recompile (logical) model recompiled even modified since last compiled. default FALSE. Can also set via global cmdstanr_force_recompile option. compile_model_methods (logical) Compile additional model methods (log_prob(), grad_log_prob(), constrain_variables(), unconstrain_variables()). compile_standalone (logical) functions Stan model compiled use R? TRUE functions available via functions field compiled model object. can also done compilation using $expose_functions() method. dry_run (logical) TRUE, code checks compilation, skip actual C++ compilation. Used speedup tests. compile_hessian_method (logical) (experimental) hessian() method compiled model methods? threads Deprecated removed future release. Please turn threading via cpp_options = list(stan_threads = TRUE) instead.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-compile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compile a Stan program — model-method-compile","text":"$compile() method called side effect creating executable adding path CmdStanModel object, also returns CmdStanModel object invisibly. compilation, $exe_file(), $hpp_file(), $save_hpp_file() methods can used return file paths.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-compile.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compile a Stan program — model-method-compile","text":"","code":"# \\dontrun{ file <- file.path(cmdstan_path(), \"examples/bernoulli/bernoulli.stan\")  # by default compilation happens when cmdstan_model() is called. # to delay compilation until calling the $compile() method set compile=FALSE mod <- cmdstan_model(file, compile = FALSE) mod$compile() mod$exe_file() #> [1] \"/home/runner/.cmdstan/cmdstan-2.37.0/examples/bernoulli/bernoulli\"  # turn on threading support (for using functions that support within-chain parallelization) mod$compile(force_recompile = TRUE, cpp_options = list(stan_threads = TRUE)) mod$exe_file() #> [1] \"/home/runner/.cmdstan/cmdstan-2.37.0/examples/bernoulli/bernoulli\"  # turn on pedantic mode (new in Stan v2.24) file_pedantic <- write_stan_file(\" parameters {   real sigma;  // pedantic mode will warn about missing <lower=0> } model {   sigma ~ exponential(1); } \") mod <- cmdstan_model(file_pedantic, pedantic = TRUE) #> Warning in '/tmp/Rtmpaxzs2V/model-1d87dd5ab1d.stan', line 6, column 2: Parameter #>     sigma is given a exponential distribution, which has strictly positive #>     support, but sigma was not constrained to be strictly positive.  # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-diagnose.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Stan's diagnose method — model-method-diagnose","title":"Run Stan's diagnose method — model-method-diagnose","text":"$diagnose() method CmdStanModel object runs Stan's basic diagnostic feature calculate gradients initial state compare gradients calculated finite differences. Discrepancies two indicate problem model initial states else bug Stan.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-diagnose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Stan's diagnose method — model-method-diagnose","text":"","code":"diagnose(   data = NULL,   seed = NULL,   init = NULL,   output_dir = getOption(\"cmdstanr_output_dir\"),   output_basename = NULL,   epsilon = NULL,   error = NULL )"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-diagnose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Stan's diagnose method — model-method-diagnose","text":"data (multiple options) data use variables specified data block Stan program. One following: named list R objects names corresponding variables declared data block Stan program. Internally list written JSON CmdStan using write_stan_json(). See write_stan_json() details conversions performed R objects passed Stan. path data file compatible CmdStan (JSON R dump). See appendices CmdStan guide details using formats. NULL empty list Stan program data block. seed (positive integer(s)) seed (P)RNG pass CmdStan. case multi-chain sampling single seed automatically augmented run (chain) ID chain uses different seed. exception transformed data block, defaults using seed chains data generated chains RNG functions used. time seed specified vector (one element per chain) RNG functions used transformed data goal generate different data chain. init (multiple options) initialization method use variables declared parameters block Stan program. One following: real number x>0. initializes parameters randomly [-x,x] unconstrained parameter space.; number 0. initializes parameters 0; character vector paths (one per chain) JSON Rdump files containing initial values parameters. See write_stan_json() write R objects JSON files compatible CmdStan. list lists containing initial values parameters. MCMC list contain sublist chain. model fitting methods just one sublist. sublists named elements corresponding parameters specifying initial values. See Examples. function returns single list names corresponding parameters specifying initial values. function can take arguments single argument chain_id. MCMC, function argument chain_id supplied chain id (1 number chains) called generate initial values. See Examples. CmdStanMCMC, CmdStanMLE, CmdStanVB, CmdStanPathfinder, CmdStanLaplace fit object. fit object's parameters subset model parameters parameters drawn Stan's default initialization. fit object must least parameters name dimensions current Stan model. sample pathfinder method, fit object fewer draws requested number chains/paths inits drawn using sampling replacement. Otherwise sampling without replacement used. CmdStanPathfinder fit object used init, . psis_resample set FALSE calculate_lp set TRUE (default), resampling without replacement Pareto smoothed weights used. psis_resample set TRUE calculate_lp set FALSE sampling without replacement uniform weights used select draws. PSIS resampling used select draws  CmdStanVB, CmdStanLaplace fit objects. type inheriting posterior::draws. draws object less samples number requested chains/paths inits drawn using sampling replacement. Otherwise sampling without replacement used. draws object's parameters subset model parameters parameters drawn Stan's default initialization. fit object must least parameters name dimensions current Stan model. output_dir (string) path directory CmdStan write output CSV files. MCMC one file per chain; methods single file. interactive use can typically left NULL (temporary directory) since CmdStanR makes CmdStan output (posterior draws diagnostics) available R via methods fitted model objects. can set entire R session using options(cmdstanr_output_dir). behavior output_dir follows: NULL (default), CSV files written temporary directory saved permanently user calls one $save_* methods fitted model object (e.g., $save_output_files()). temporary files removed fitted model object garbage collected (manually automatically). path, files created output_dir names corresponding defaults used $save_output_files(). output_basename (string) string use prefix names output CSV files CmdStan. NULL (default), basename output CSV files comprised model name, timestamp, 5 random characters. epsilon (positive real) finite difference step size. Default value 1e-6. error (positive real)  error threshold. Default value 1e-6.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-diagnose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run Stan's diagnose method — model-method-diagnose","text":"CmdStanDiagnose object.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-diagnose.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run Stan's diagnose method — model-method-diagnose","text":"","code":"# \\dontrun{ test <- cmdstanr_example(\"logistic\", method = \"diagnose\")  # retrieve the gradients test$gradients() #>   param_idx     value      model finite_diff        error #> 1         0  0.319022   3.751800    3.751800  1.28391e-08 #> 2         1 -1.074650  -0.461525   -0.461525 -1.71248e-08 #> 3         2  1.095310 -19.869200  -19.869200 -1.71546e-08 #> 4         3 -1.702040  28.964000   28.964000 -2.61942e-08 # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-expose_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Expose Stan functions to R — model-method-expose_functions","title":"Expose Stan functions to R — model-method-expose_functions","text":"$expose_functions() method CmdStanModel object compile functions Stan program's functions block expose use R. can also specified via compile_standalone argument $compile() method. method also available fitted model objects (CmdStanMCMC, CmdStanVB, etc.). See Examples. Note: may many compiler warnings emitted compilation can ignored long warnings errors.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-expose_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expose Stan functions to R — model-method-expose_functions","text":"","code":"expose_functions(global = FALSE, verbose = FALSE)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-expose_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expose Stan functions to R — model-method-expose_functions","text":"global (logical) functions added Global Environment? default FALSE, case functions available via functions field R6 object. verbose (logical) detailed information generated code printed console? Defaults FALSE.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-expose_functions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Expose Stan functions to R — model-method-expose_functions","text":"","code":"# \\dontrun{ stan_file <- write_stan_file(  \"  functions {    real a_plus_b(real a, real b) {      return a + b;    }  }  parameters {    real x;  }  model {    x ~ std_normal();  }  \" ) mod <- cmdstan_model(stan_file) mod$expose_functions() mod$functions$a_plus_b(1, 2) #> [1] 3  fit <- mod$sample(refresh = 0) #> Running MCMC with 4 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #> Chain 3 finished in 0.0 seconds. #> Chain 4 finished in 0.0 seconds. #>  #> All 4 chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.5 seconds. #>  fit$expose_functions() # already compiled because of above but this would compile them otherwise #> Functions already compiled, nothing to do! fit$functions$a_plus_b(1, 2) #> [1] 3 # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-format.html","id":null,"dir":"Reference","previous_headings":"","what":"Run stanc's auto-formatter on the model code. — model-method-format","title":"Run stanc's auto-formatter on the model code. — model-method-format","text":"$format() method CmdStanModel object runs stanc's auto-formatter model code. Either saves formatted model directly back file prints inspection.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-format.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run stanc's auto-formatter on the model code. — model-method-format","text":"","code":"format(   overwrite_file = FALSE,   canonicalize = FALSE,   backup = TRUE,   max_line_length = NULL,   quiet = FALSE )"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-format.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run stanc's auto-formatter on the model code. — model-method-format","text":"overwrite_file (logical) formatted code written back input model file. default FALSE. canonicalize (list logical) Defines whether compiler 'canonicalize' Stan model, removing things like deprecated syntax. Default FALSE. TRUE, canonicalizations run. can also supply list strings represent options. case options passed stanc (new Stan 2.29). See User's guide section available canonicalization options. backup (logical) TRUE, create stanfile.bak backups writing file. Disable option sure copies file using version control system like Git. Defaults TRUE. value ignored overwrite_file = FALSE. max_line_length (integer) maximum length line formatting. default NULL, defers default line length stanc. quiet (logical) informational messages suppressed? default FALSE.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-format.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run stanc's auto-formatter on the model code. — model-method-format","text":"$format() method returns TRUE (invisibly) model valid.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-format.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run stanc's auto-formatter on the model code. — model-method-format","text":"","code":"# \\dontrun{  # Example of removing unnecessary whitespace file <- write_stan_file(\" data {   int N;   array[N] int y; } parameters {   real                     lambda; } model {   target +=  poisson_lpmf(y | lambda); } \")  # set compile=FALSE then call format to fix old syntax mod <- cmdstan_model(file, compile = FALSE) mod$format(canonicalize = list(\"deprecations\")) #> data { #>   int N; #>   array[N] int y; #> } #> parameters { #>   real lambda; #> } #> model { #>   target += poisson_lpmf(y | lambda); #> } #>  #>   # overwrite the original file instead of just printing it mod$format(canonicalize = list(\"deprecations\"), overwrite_file = TRUE) #> Old version of the model stored to /tmp/Rtmpaxzs2V/model_39022cccc3fe5384fab5a52b791fead6.stan.bak-20251231180458. mod$compile() # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-generate-quantities.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Stan's standalone generated quantities method — model-method-generate-quantities","title":"Run Stan's standalone generated quantities method — model-method-generate-quantities","text":"$generate_quantities() method CmdStanModel object runs Stan's standalone generated quantities obtain generated quantities based previously fitted parameters.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-generate-quantities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Stan's standalone generated quantities method — model-method-generate-quantities","text":"","code":"generate_quantities(   fitted_params,   data = NULL,   seed = NULL,   output_dir = getOption(\"cmdstanr_output_dir\"),   output_basename = NULL,   sig_figs = NULL,   parallel_chains = getOption(\"mc.cores\", 1),   threads_per_chain = NULL,   opencl_ids = NULL )"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-generate-quantities.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Stan's standalone generated quantities method — model-method-generate-quantities","text":"fitted_params (multiple options) parameter draws use. One following: CmdStanMCMC CmdStanVB fitted model object. posterior::draws_array (MCMC) posterior::draws_matrix (VB) object returned CmdStanR's $draws() method. character vector paths CmdStan CSV output files. NOTE: plan making many calls $generate_quantities() efficient option pass paths CmdStan CSV output files (avoids CmdStanR rewrite draws contained fitted model object CSV time). longer CSV files can use draws_to_csv() write pass resulting file paths $generate_quantities() many times needed. data (multiple options) data use variables specified data block Stan program. One following: named list R objects names corresponding variables declared data block Stan program. Internally list written JSON CmdStan using write_stan_json(). See write_stan_json() details conversions performed R objects passed Stan. path data file compatible CmdStan (JSON R dump). See appendices CmdStan guide details using formats. NULL empty list Stan program data block. seed (positive integer(s)) seed (P)RNG pass CmdStan. case multi-chain sampling single seed automatically augmented run (chain) ID chain uses different seed. exception transformed data block, defaults using seed chains data generated chains RNG functions used. time seed specified vector (one element per chain) RNG functions used transformed data goal generate different data chain. output_dir (string) path directory CmdStan write output CSV files. MCMC one file per chain; methods single file. interactive use can typically left NULL (temporary directory) since CmdStanR makes CmdStan output (posterior draws diagnostics) available R via methods fitted model objects. can set entire R session using options(cmdstanr_output_dir). behavior output_dir follows: NULL (default), CSV files written temporary directory saved permanently user calls one $save_* methods fitted model object (e.g., $save_output_files()). temporary files removed fitted model object garbage collected (manually automatically). path, files created output_dir names corresponding defaults used $save_output_files(). output_basename (string) string use prefix names output CSV files CmdStan. NULL (default), basename output CSV files comprised model name, timestamp, 5 random characters. sig_figs (positive integer) number significant figures used storing output values. default, CmdStan represent output values 6 significant figures. upper limit sig_figs 18. Increasing value result larger output CSV files thus increased usage disk space. parallel_chains (positive integer) maximum number MCMC chains run parallel. parallel_chains specified default look option \"mc.cores\", can set entire R session options(mc.cores=value). \"mc.cores\" option set default 1. threads_per_chain (positive integer) model compiled threading support, number threads use parallelized sections within MCMC chain (e.g., using Stan functions reduce_sum() map_rect()). contrast parallel_chains, specifies number chains run parallel. actual number CPU cores used parallel_chains*threads_per_chain. example using threading see Stan case study Reduce Sum: Minimal Example. opencl_ids (integer vector length 2) platform device IDs OpenCL device use fitting. model must compiled cpp_options = list(stan_opencl = TRUE) argument effect.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-generate-quantities.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run Stan's standalone generated quantities method — model-method-generate-quantities","text":"CmdStanGQ object.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-generate-quantities.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run Stan's standalone generated quantities method — model-method-generate-quantities","text":"","code":"# \\dontrun{ # first fit a model using MCMC mcmc_program <- write_stan_file(   \"data {     int<lower=0> N;     array[N] int<lower=0,upper=1> y;   }   parameters {     real<lower=0,upper=1> theta;   }   model {     y ~ bernoulli(theta);   }\" ) mod_mcmc <- cmdstan_model(mcmc_program)  data <- list(N = 10, y = c(1,1,0,0,0,1,0,1,0,0)) fit_mcmc <- mod_mcmc$sample(data = data, seed = 123, refresh = 0) #> Running MCMC with 4 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #> Chain 3 finished in 0.0 seconds. #> Chain 4 finished in 0.0 seconds. #>  #> All 4 chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.5 seconds. #>   # stan program for standalone generated quantities # (could keep model block, but not necessary so removing it) gq_program <- write_stan_file(   \"data {     int<lower=0> N;     array[N] int<lower=0,upper=1> y;   }   parameters {     real<lower=0,upper=1> theta;   }   generated quantities {     array[N] int y_rep = bernoulli_rng(rep_vector(theta, N));   }\" )  mod_gq <- cmdstan_model(gq_program) fit_gq <- mod_gq$generate_quantities(fit_mcmc, data = data, seed = 123) #> Running standalone generated quantities after 4 MCMC chains, 1 chain at a time ... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #> Chain 3 finished in 0.0 seconds. #> Chain 4 finished in 0.0 seconds. #>  #> All 4 chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.5 seconds. str(fit_gq$draws()) #>  'draws_array' int [1:1000, 1:4, 1:10] 0 0 0 1 1 0 1 1 0 1 ... #>  - attr(*, \"dimnames\")=List of 3 #>   ..$ iteration: chr [1:1000] \"1\" \"2\" \"3\" \"4\" ... #>   ..$ chain    : chr [1:4] \"1\" \"2\" \"3\" \"4\" #>   ..$ variable : chr [1:10] \"y_rep[1]\" \"y_rep[2]\" \"y_rep[3]\" \"y_rep[4]\" ...  library(posterior) as_draws_df(fit_gq$draws()) #> # A draws_df: 1000 iterations, 4 chains, and 10 variables #>    y_rep[1] y_rep[2] y_rep[3] y_rep[4] y_rep[5] y_rep[6] y_rep[7] y_rep[8] #> 1         0        0        0        0        0        1        1        1 #> 2         0        0        0        0        1        1        0        0 #> 3         0        0        0        1        0        0        1        1 #> 4         1        1        0        0        0        0        1        0 #> 5         1        0        1        0        1        0        1        0 #> 6         0        0        0        1        1        0        0        0 #> 7         1        1        0        1        1        1        0        0 #> 8         1        1        1        1        1        0        1        1 #> 9         0        1        0        1        0        1        1        0 #> 10        1        1        1        1        1        1        1        1 #> # ... with 3990 more draws, and 2 more variables #> # ... hidden reserved variables {'.chain', '.iteration', '.draw'} # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-laplace.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Stan's Laplace algorithm — model-method-laplace","title":"Run Stan's Laplace algorithm — model-method-laplace","text":"$laplace() method CmdStanModel object produces sample normal approximation centered mode distribution unconstrained space. mode maximum posteriori (MAP) estimate, samples provide estimate mean standard deviation posterior distribution. mode maximum likelihood estimate (MLE), sample provides estimate standard error likelihood. Whether mode MAP MLE depends value jacobian argument running optimization. See CmdStan User’s Guide details. argument left NULL default default value used installed version CmdStan.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-laplace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Stan's Laplace algorithm — model-method-laplace","text":"","code":"laplace(   data = NULL,   seed = NULL,   refresh = NULL,   init = NULL,   save_latent_dynamics = FALSE,   output_dir = getOption(\"cmdstanr_output_dir\"),   output_basename = NULL,   sig_figs = NULL,   threads = NULL,   opencl_ids = NULL,   mode = NULL,   opt_args = NULL,   jacobian = TRUE,   draws = NULL,   show_messages = TRUE,   show_exceptions = TRUE,   save_cmdstan_config = NULL )"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-laplace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Stan's Laplace algorithm — model-method-laplace","text":"data (multiple options) data use variables specified data block Stan program. One following: named list R objects names corresponding variables declared data block Stan program. Internally list written JSON CmdStan using write_stan_json(). See write_stan_json() details conversions performed R objects passed Stan. path data file compatible CmdStan (JSON R dump). See appendices CmdStan guide details using formats. NULL empty list Stan program data block. seed (positive integer(s)) seed (P)RNG pass CmdStan. case multi-chain sampling single seed automatically augmented run (chain) ID chain uses different seed. exception transformed data block, defaults using seed chains data generated chains RNG functions used. time seed specified vector (one element per chain) RNG functions used transformed data goal generate different data chain. refresh (non-negative integer) number iterations printed screen updates. refresh = 0, error messages printed. init (multiple options) initialization method use variables declared parameters block Stan program. One following: real number x>0. initializes parameters randomly [-x,x] unconstrained parameter space.; number 0. initializes parameters 0; character vector paths (one per chain) JSON Rdump files containing initial values parameters. See write_stan_json() write R objects JSON files compatible CmdStan. list lists containing initial values parameters. MCMC list contain sublist chain. model fitting methods just one sublist. sublists named elements corresponding parameters specifying initial values. See Examples. function returns single list names corresponding parameters specifying initial values. function can take arguments single argument chain_id. MCMC, function argument chain_id supplied chain id (1 number chains) called generate initial values. See Examples. CmdStanMCMC, CmdStanMLE, CmdStanVB, CmdStanPathfinder, CmdStanLaplace fit object. fit object's parameters subset model parameters parameters drawn Stan's default initialization. fit object must least parameters name dimensions current Stan model. sample pathfinder method, fit object fewer draws requested number chains/paths inits drawn using sampling replacement. Otherwise sampling without replacement used. CmdStanPathfinder fit object used init, . psis_resample set FALSE calculate_lp set TRUE (default), resampling without replacement Pareto smoothed weights used. psis_resample set TRUE calculate_lp set FALSE sampling without replacement uniform weights used select draws. PSIS resampling used select draws  CmdStanVB, CmdStanLaplace fit objects. type inheriting posterior::draws. draws object less samples number requested chains/paths inits drawn using sampling replacement. Otherwise sampling without replacement used. draws object's parameters subset model parameters parameters drawn Stan's default initialization. fit object must least parameters name dimensions current Stan model. save_latent_dynamics Ignored method. output_dir (string) path directory CmdStan write output CSV files. MCMC one file per chain; methods single file. interactive use can typically left NULL (temporary directory) since CmdStanR makes CmdStan output (posterior draws diagnostics) available R via methods fitted model objects. can set entire R session using options(cmdstanr_output_dir). behavior output_dir follows: NULL (default), CSV files written temporary directory saved permanently user calls one $save_* methods fitted model object (e.g., $save_output_files()). temporary files removed fitted model object garbage collected (manually automatically). path, files created output_dir names corresponding defaults used $save_output_files(). output_basename (string) string use prefix names output CSV files CmdStan. NULL (default), basename output CSV files comprised model name, timestamp, 5 random characters. sig_figs (positive integer) number significant figures used storing output values. default, CmdStan represent output values 6 significant figures. upper limit sig_figs 18. Increasing value result larger output CSV files thus increased usage disk space. threads (positive integer) model compiled threading support, number threads use parallelized sections (e.g., using Stan functions reduce_sum() map_rect()). opencl_ids (integer vector length 2) platform device IDs OpenCL device use fitting. model must compiled cpp_options = list(stan_opencl = TRUE) argument effect. mode (multiple options) mode center approximation . One following: CmdStanMLE object previous run $optimize(). path CmdStan CSV file running optimization. NULL, case $optimize() run jacobian=jacobian (see jacobian argument ). cases total time reported $time() time Laplace sampling step include time taken run $optimize() method. opt_args (named list) named list optional arguments pass $optimize() mode=NULL. jacobian (logical) Whether enable Jacobian adjustment constrained parameters. default TRUE. See Laplace Sampling section CmdStan User's Guide details. mode NULL value jacobian must match value used optimization originally run. mode NULL value jacobian specified used running optimization. draws (positive integer) number draws take. show_messages (logical) TRUE (default), prints output execution process, iteration numbers elapsed times. output silenced $output() method resulting fit object can used display silenced messages. show_exceptions (logical) TRUE (default), prints informational messages, example rejection current proposal. Disable wish silence messages, usually recommended unless confident model correct numerical error. messages silenced $output() method resulting fit object can used display silenced messages. save_cmdstan_config (logical) TRUE (default), call CmdStan argument \"output save_config=1\" save json file contains argument tree extra information (equivalent output CSV file header). option available CmdStan 2.34.0 later.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-laplace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run Stan's Laplace algorithm — model-method-laplace","text":"CmdStanLaplace object.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-laplace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run Stan's Laplace algorithm — model-method-laplace","text":"","code":"# \\dontrun{ file <- file.path(cmdstan_path(), \"examples/bernoulli/bernoulli.stan\") mod <- cmdstan_model(file) mod$print() #> data { #>   int<lower=0> N; #>   array[N] int<lower=0, upper=1> y; #> } #> parameters { #>   real<lower=0, upper=1> theta; #> } #> model { #>   theta ~ beta(1, 1); // uniform prior on interval 0,1 #>   y ~ bernoulli(theta); #> }  stan_data <- list(N = 10, y = c(0,1,0,0,0,0,0,0,0,1)) fit_mode <- mod$optimize(data = stan_data, jacobian = TRUE) #> Initial log joint probability = -15.9648  #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes   #>        5      -6.74802    0.00187752   5.64457e-05           1           1        8     #> Optimization terminated normally:   #>   Convergence detected: relative gradient magnitude is below tolerance  #> Finished in  0.1 seconds. fit_laplace <- mod$laplace(data = stan_data, mode = fit_mode) #> Calculating Hessian  #> Calculating inverse of Cholesky factor  #> Generating draws  #> iteration: 0  #> iteration: 100  #> iteration: 200  #> iteration: 300  #> iteration: 400  #> iteration: 500  #> iteration: 600  #> iteration: 700  #> iteration: 800  #> iteration: 900  #> Finished in  0.1 seconds. fit_laplace$summary() #> # A tibble: 3 × 7 #>   variable      mean median    sd   mad     q5      q95 #>   <chr>        <dbl>  <dbl> <dbl> <dbl>  <dbl>    <dbl> #> 1 lp__        -7.23  -6.97  0.688 0.295 -8.57  -6.75    #> 2 lp_approx__ -0.495 -0.220 0.732 0.301 -1.94  -0.00358 #> 3 theta        0.263  0.246 0.121 0.121  0.101  0.491    # if mode isn't specified optimize is run internally first fit_laplace <- mod$laplace(data = stan_data) #> Initial log joint probability = -6.77661  #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes   #>        4      -6.74802    0.00012451   3.01958e-07           1           1        7     #> Optimization terminated normally:   #>   Convergence detected: relative gradient magnitude is below tolerance  #> Finished in  0.1 seconds. #> Calculating Hessian  #> Calculating inverse of Cholesky factor  #> Generating draws  #> iteration: 0  #> iteration: 100  #> iteration: 200  #> iteration: 300  #> iteration: 400  #> iteration: 500  #> iteration: 600  #> iteration: 700  #> iteration: 800  #> iteration: 900  #> Finished in  0.1 seconds. fit_laplace$summary() #> # A tibble: 3 × 7 #>   variable      mean median    sd   mad      q5      q95 #>   <chr>        <dbl>  <dbl> <dbl> <dbl>   <dbl>    <dbl> #> 1 lp__        -7.25  -6.98  0.716 0.314 -8.64   -6.75    #> 2 lp_approx__ -0.515 -0.236 0.724 0.324 -2.05   -0.00159 #> 3 theta        0.268  0.249 0.125 0.124  0.0970  0.504    # plot approximate posterior bayesplot::mcmc_hist(fit_laplace$draws(\"theta\")) #> `stat_bin()` using `bins = 30`. Pick better value `binwidth`.  # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-optimize.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Stan's optimization algorithms — model-method-optimize","title":"Run Stan's optimization algorithms — model-method-optimize","text":"$optimize() method CmdStanModel object runs Stan's optimizer find posterior mode. Jacobian adjustment included (default), optimization returns parameter values correspond mode target constrained space (mode exists). Thus option useful optimization want find mode original constrained parameter space. Jacobian adjustment included, optimization returns parameter values correspond mode unconstrained space. useful, example, want make distributional approximation posterior mode (see, Laplace sampling, Jacobian adjustment needs included correct results). model unconstrained parameters, effect including Jacobian. See CmdStan User's Guide details. argument left NULL default default value used installed version CmdStan. See CmdStan User’s Guide details default arguments. default values can also obtained checking metadata example model, e.g., cmdstanr_example(method=\"optimize\")$metadata().","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-optimize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Stan's optimization algorithms — model-method-optimize","text":"","code":"optimize(   data = NULL,   seed = NULL,   refresh = NULL,   init = NULL,   save_latent_dynamics = FALSE,   output_dir = getOption(\"cmdstanr_output_dir\"),   output_basename = NULL,   sig_figs = NULL,   threads = NULL,   opencl_ids = NULL,   algorithm = NULL,   jacobian = FALSE,   init_alpha = NULL,   iter = NULL,   tol_obj = NULL,   tol_rel_obj = NULL,   tol_grad = NULL,   tol_rel_grad = NULL,   tol_param = NULL,   history_size = NULL,   show_messages = TRUE,   show_exceptions = TRUE,   save_cmdstan_config = NULL )"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-optimize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Stan's optimization algorithms — model-method-optimize","text":"data (multiple options) data use variables specified data block Stan program. One following: named list R objects names corresponding variables declared data block Stan program. Internally list written JSON CmdStan using write_stan_json(). See write_stan_json() details conversions performed R objects passed Stan. path data file compatible CmdStan (JSON R dump). See appendices CmdStan guide details using formats. NULL empty list Stan program data block. seed (positive integer(s)) seed (P)RNG pass CmdStan. case multi-chain sampling single seed automatically augmented run (chain) ID chain uses different seed. exception transformed data block, defaults using seed chains data generated chains RNG functions used. time seed specified vector (one element per chain) RNG functions used transformed data goal generate different data chain. refresh (non-negative integer) number iterations printed screen updates. refresh = 0, error messages printed. init (multiple options) initialization method use variables declared parameters block Stan program. One following: real number x>0. initializes parameters randomly [-x,x] unconstrained parameter space.; number 0. initializes parameters 0; character vector paths (one per chain) JSON Rdump files containing initial values parameters. See write_stan_json() write R objects JSON files compatible CmdStan. list lists containing initial values parameters. MCMC list contain sublist chain. model fitting methods just one sublist. sublists named elements corresponding parameters specifying initial values. See Examples. function returns single list names corresponding parameters specifying initial values. function can take arguments single argument chain_id. MCMC, function argument chain_id supplied chain id (1 number chains) called generate initial values. See Examples. CmdStanMCMC, CmdStanMLE, CmdStanVB, CmdStanPathfinder, CmdStanLaplace fit object. fit object's parameters subset model parameters parameters drawn Stan's default initialization. fit object must least parameters name dimensions current Stan model. sample pathfinder method, fit object fewer draws requested number chains/paths inits drawn using sampling replacement. Otherwise sampling without replacement used. CmdStanPathfinder fit object used init, . psis_resample set FALSE calculate_lp set TRUE (default), resampling without replacement Pareto smoothed weights used. psis_resample set TRUE calculate_lp set FALSE sampling without replacement uniform weights used select draws. PSIS resampling used select draws  CmdStanVB, CmdStanLaplace fit objects. type inheriting posterior::draws. draws object less samples number requested chains/paths inits drawn using sampling replacement. Otherwise sampling without replacement used. draws object's parameters subset model parameters parameters drawn Stan's default initialization. fit object must least parameters name dimensions current Stan model. save_latent_dynamics (logical) auxiliary diagnostic information latent dynamics written temporary diagnostic CSV files? argument replaces CmdStan's diagnostic_file argument content written CSV controlled user's CmdStan installation CmdStanR (algorithms content may written). default FALSE, appropriate almost every use case. save temporary files created save_latent_dynamics=TRUE see $save_latent_dynamics_files() method. output_dir (string) path directory CmdStan write output CSV files. MCMC one file per chain; methods single file. interactive use can typically left NULL (temporary directory) since CmdStanR makes CmdStan output (posterior draws diagnostics) available R via methods fitted model objects. can set entire R session using options(cmdstanr_output_dir). behavior output_dir follows: NULL (default), CSV files written temporary directory saved permanently user calls one $save_* methods fitted model object (e.g., $save_output_files()). temporary files removed fitted model object garbage collected (manually automatically). path, files created output_dir names corresponding defaults used $save_output_files(). output_basename (string) string use prefix names output CSV files CmdStan. NULL (default), basename output CSV files comprised model name, timestamp, 5 random characters. sig_figs (positive integer) number significant figures used storing output values. default, CmdStan represent output values 6 significant figures. upper limit sig_figs 18. Increasing value result larger output CSV files thus increased usage disk space. threads (positive integer) model compiled threading support, number threads use parallelized sections (e.g., using Stan functions reduce_sum() map_rect()). opencl_ids (integer vector length 2) platform device IDs OpenCL device use fitting. model must compiled cpp_options = list(stan_opencl = TRUE) argument effect. algorithm (string) optimization algorithm. One \"lbfgs\", \"bfgs\", \"newton\". control parameters available \"lbfgs\" \"bfgs. default values details see CmdStan User's Guide. default values can also obtained running cmdstanr_example(method=\"optimize\")$metadata(). jacobian (logical) Whether use Jacobian adjustment constrained variables. historical reasons, default FALSE, meaning optimization finds mode target original constrained parameter space. Setting TRUE finds mode unconstrained space. See CmdStan User's Guide details. use later $laplace() jacobian argument typically set TRUE. init_alpha (positive real) initial step size parameter. iter (positive integer) maximum number iterations. tol_obj (positive real) Convergence tolerance changes objective function value. tol_rel_obj (positive real) Convergence tolerance relative changes objective function value. tol_grad (positive real) Convergence tolerance norm gradient. tol_rel_grad (positive real) Convergence tolerance relative norm gradient. tol_param (positive real) Convergence tolerance changes parameter value. history_size (positive integer) size history used approximating Hessian. available L-BFGS. show_messages (logical) TRUE (default), prints output execution process, iteration numbers elapsed times. output silenced $output() method resulting fit object can used display silenced messages. show_exceptions (logical) TRUE (default), prints informational messages, example rejection current proposal. Disable wish silence messages, usually recommended unless confident model correct numerical error. messages silenced $output() method resulting fit object can used display silenced messages. save_cmdstan_config (logical) TRUE (default), call CmdStan argument \"output save_config=1\" save json file contains argument tree extra information (equivalent output CSV file header). option available CmdStan 2.34.0 later.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-optimize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run Stan's optimization algorithms — model-method-optimize","text":"CmdStanMLE object.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-optimize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run Stan's optimization algorithms — model-method-optimize","text":"","code":"# \\dontrun{ library(cmdstanr) library(posterior) library(bayesplot) color_scheme_set(\"brightblue\")  # Set path to CmdStan # (Note: if you installed CmdStan via install_cmdstan() with default settings # then setting the path is unnecessary but the default below should still work. # Otherwise use the `path` argument to specify the location of your # CmdStan installation.) set_cmdstan_path(path = NULL) #> CmdStan path set to: /home/runner/.cmdstan/cmdstan-2.37.0  # Create a CmdStanModel object from a Stan program, # here using the example model that comes with CmdStan file <- file.path(cmdstan_path(), \"examples/bernoulli/bernoulli.stan\") mod <- cmdstan_model(file) mod$print() #> data { #>   int<lower=0> N; #>   array[N] int<lower=0, upper=1> y; #> } #> parameters { #>   real<lower=0, upper=1> theta; #> } #> model { #>   theta ~ beta(1, 1); // uniform prior on interval 0,1 #>   y ~ bernoulli(theta); #> } # Print with line numbers. This can be set globally using the # `cmdstanr_print_line_numbers` option. mod$print(line_numbers = TRUE) #>  1: data { #>  2:   int<lower=0> N; #>  3:   array[N] int<lower=0, upper=1> y; #>  4: } #>  5: parameters { #>  6:   real<lower=0, upper=1> theta; #>  7: } #>  8: model { #>  9:   theta ~ beta(1, 1); // uniform prior on interval 0,1 #> 10:   y ~ bernoulli(theta); #> 11: }  # Data as a named list (like RStan) stan_data <- list(N = 10, y = c(0,1,0,0,0,0,0,0,0,1))  # Run MCMC using the 'sample' method fit_mcmc <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   parallel_chains = 2 ) #> Running MCMC with 2 parallel chains... #>  #> Chain 1 Iteration:    1 / 2000 [  0%]  (Warmup)  #> Chain 1 Iteration:  100 / 2000 [  5%]  (Warmup)  #> Chain 1 Iteration:  200 / 2000 [ 10%]  (Warmup)  #> Chain 1 Iteration:  300 / 2000 [ 15%]  (Warmup)  #> Chain 1 Iteration:  400 / 2000 [ 20%]  (Warmup)  #> Chain 1 Iteration:  500 / 2000 [ 25%]  (Warmup)  #> Chain 1 Iteration:  600 / 2000 [ 30%]  (Warmup)  #> Chain 1 Iteration:  700 / 2000 [ 35%]  (Warmup)  #> Chain 1 Iteration:  800 / 2000 [ 40%]  (Warmup)  #> Chain 1 Iteration:  900 / 2000 [ 45%]  (Warmup)  #> Chain 1 Iteration: 1000 / 2000 [ 50%]  (Warmup)  #> Chain 1 Iteration: 1001 / 2000 [ 50%]  (Sampling)  #> Chain 1 Iteration: 1100 / 2000 [ 55%]  (Sampling)  #> Chain 1 Iteration: 1200 / 2000 [ 60%]  (Sampling)  #> Chain 1 Iteration: 1300 / 2000 [ 65%]  (Sampling)  #> Chain 1 Iteration: 1400 / 2000 [ 70%]  (Sampling)  #> Chain 1 Iteration: 1500 / 2000 [ 75%]  (Sampling)  #> Chain 1 Iteration: 1600 / 2000 [ 80%]  (Sampling)  #> Chain 1 Iteration: 1700 / 2000 [ 85%]  (Sampling)  #> Chain 1 Iteration: 1800 / 2000 [ 90%]  (Sampling)  #> Chain 1 Iteration: 1900 / 2000 [ 95%]  (Sampling)  #> Chain 1 Iteration: 2000 / 2000 [100%]  (Sampling)  #> Chain 2 Iteration:    1 / 2000 [  0%]  (Warmup)  #> Chain 2 Iteration:  100 / 2000 [  5%]  (Warmup)  #> Chain 2 Iteration:  200 / 2000 [ 10%]  (Warmup)  #> Chain 2 Iteration:  300 / 2000 [ 15%]  (Warmup)  #> Chain 2 Iteration:  400 / 2000 [ 20%]  (Warmup)  #> Chain 2 Iteration:  500 / 2000 [ 25%]  (Warmup)  #> Chain 2 Iteration:  600 / 2000 [ 30%]  (Warmup)  #> Chain 2 Iteration:  700 / 2000 [ 35%]  (Warmup)  #> Chain 2 Iteration:  800 / 2000 [ 40%]  (Warmup)  #> Chain 2 Iteration:  900 / 2000 [ 45%]  (Warmup)  #> Chain 2 Iteration: 1000 / 2000 [ 50%]  (Warmup)  #> Chain 2 Iteration: 1001 / 2000 [ 50%]  (Sampling)  #> Chain 2 Iteration: 1100 / 2000 [ 55%]  (Sampling)  #> Chain 2 Iteration: 1200 / 2000 [ 60%]  (Sampling)  #> Chain 2 Iteration: 1300 / 2000 [ 65%]  (Sampling)  #> Chain 2 Iteration: 1400 / 2000 [ 70%]  (Sampling)  #> Chain 2 Iteration: 1500 / 2000 [ 75%]  (Sampling)  #> Chain 2 Iteration: 1600 / 2000 [ 80%]  (Sampling)  #> Chain 2 Iteration: 1700 / 2000 [ 85%]  (Sampling)  #> Chain 2 Iteration: 1800 / 2000 [ 90%]  (Sampling)  #> Chain 2 Iteration: 1900 / 2000 [ 95%]  (Sampling)  #> Chain 2 Iteration: 2000 / 2000 [100%]  (Sampling)  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.1 seconds. #>   # Use 'posterior' package for summaries fit_mcmc$summary() #> # A tibble: 2 × 10 #>   variable   mean median    sd   mad      q5    q95  rhat ess_bulk ess_tail #>   <chr>     <dbl>  <dbl> <dbl> <dbl>   <dbl>  <dbl> <dbl>    <dbl>    <dbl> #> 1 lp__     -7.32  -7.02  0.799 0.355 -8.89   -6.75   1.00     819.    1020. #> 2 theta     0.255  0.240 0.127 0.130  0.0773  0.491  1.00     557.     616.  # Check sampling diagnostics fit_mcmc$diagnostic_summary() #> $num_divergent #> [1] 0 0 #>  #> $num_max_treedepth #> [1] 0 0 #>  #> $ebfmi #> [1] 1.114870 1.030279 #>   # Get posterior draws draws <- fit_mcmc$draws() print(draws) #> # A draws_array: 1000 iterations, 2 chains, and 2 variables #> , , variable = lp__ #>  #>          chain #> iteration    1    2 #>         1 -7.0 -6.8 #>         2 -7.9 -6.9 #>         3 -7.4 -6.9 #>         4 -6.7 -6.8 #>         5 -6.9 -6.8 #>  #> , , variable = theta #>  #>          chain #> iteration    1    2 #>         1 0.17 0.28 #>         2 0.46 0.19 #>         3 0.41 0.19 #>         4 0.25 0.28 #>         5 0.18 0.23 #>  #> # ... with 995 more iterations  # Convert to data frame using posterior::as_draws_df as_draws_df(draws) #> # A draws_df: 1000 iterations, 2 chains, and 2 variables #>    lp__ theta #> 1  -7.0  0.17 #> 2  -7.9  0.46 #> 3  -7.4  0.41 #> 4  -6.7  0.25 #> 5  -6.9  0.18 #> 6  -6.9  0.33 #> 7  -7.2  0.15 #> 8  -6.8  0.29 #> 9  -6.8  0.24 #> 10 -6.8  0.24 #> # ... with 1990 more draws #> # ... hidden reserved variables {'.chain', '.iteration', '.draw'}  # Plot posterior using bayesplot (ggplot2) mcmc_hist(fit_mcmc$draws(\"theta\")) #> `stat_bin()` using `bins = 30`. Pick better value `binwidth`.   # Run 'optimize' method to get a point estimate (default is Stan's LBFGS algorithm) # and also demonstrate specifying data as a path to a file instead of a list my_data_file <- file.path(cmdstan_path(), \"examples/bernoulli/bernoulli.data.json\") fit_optim <- mod$optimize(data = my_data_file, seed = 123) #> Initial log joint probability = -16.144  #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes   #>        6      -5.00402   0.000246518   8.73164e-07           1           1        9     #> Optimization terminated normally:   #>   Convergence detected: relative gradient magnitude is below tolerance  #> Finished in  0.1 seconds. fit_optim$summary() #> # A tibble: 2 × 2 #>   variable estimate #>   <chr>       <dbl> #> 1 lp__       -5.00  #> 2 theta       0.200  # Run 'optimize' again with 'jacobian=TRUE' and then draw from Laplace approximation # to the posterior fit_optim <- mod$optimize(data = my_data_file, jacobian = TRUE) #> Initial log joint probability = -7.45349  #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes   #>        5      -6.74802   0.000760664   1.82768e-06           1           1        8     #> Optimization terminated normally:   #>   Convergence detected: relative gradient magnitude is below tolerance  #> Finished in  0.1 seconds. fit_laplace <- mod$laplace(data = my_data_file, mode = fit_optim, draws = 2000) #> Calculating Hessian  #> Calculating inverse of Cholesky factor  #> Generating draws  #> iteration: 0  #> iteration: 100  #> iteration: 200  #> iteration: 300  #> iteration: 400  #> iteration: 500  #> iteration: 600  #> iteration: 700  #> iteration: 800  #> iteration: 900  #> iteration: 1000  #> iteration: 1100  #> iteration: 1200  #> iteration: 1300  #> iteration: 1400  #> iteration: 1500  #> iteration: 1600  #> iteration: 1700  #> iteration: 1800  #> iteration: 1900  #> Finished in  0.1 seconds. fit_laplace$summary() #> # A tibble: 3 × 7 #>   variable      mean median    sd   mad      q5      q95 #>   <chr>        <dbl>  <dbl> <dbl> <dbl>   <dbl>    <dbl> #> 1 lp__        -7.24  -6.97  0.678 0.307 -8.63   -6.75    #> 2 lp_approx__ -0.507 -0.227 0.698 0.310 -1.94   -0.00188 #> 3 theta        0.268  0.250 0.123 0.121  0.0984  0.499    # Run 'variational' method to use ADVI to approximate posterior fit_vb <- mod$variational(data = stan_data, seed = 123) #> ------------------------------------------------------------  #> EXPERIMENTAL ALGORITHM:  #>   This procedure has not been thoroughly tested and may be unstable  #>   or buggy. The interface is subject to change.  #> ------------------------------------------------------------  #> Gradient evaluation took 2e-06 seconds  #> 1000 transitions using 10 leapfrog steps per transition would take 0.02 seconds.  #> Adjust your expectations accordingly!  #> Begin eta adaptation.  #> Iteration:   1 / 250 [  0%]  (Adaptation)  #> Iteration:  50 / 250 [ 20%]  (Adaptation)  #> Iteration: 100 / 250 [ 40%]  (Adaptation)  #> Iteration: 150 / 250 [ 60%]  (Adaptation)  #> Iteration: 200 / 250 [ 80%]  (Adaptation)  #> Success! Found best value [eta = 1] earlier than expected.  #> Begin stochastic gradient ascent.  #>   iter             ELBO   delta_ELBO_mean   delta_ELBO_med   notes   #>    100           -6.164             1.000            1.000  #>    200           -6.225             0.505            1.000  #>    300           -6.186             0.339            0.010   MEDIAN ELBO CONVERGED  #> Drawing a sample of size 1000 from the approximate posterior...   #> COMPLETED.  #> Finished in  0.1 seconds. fit_vb$summary() #> # A tibble: 3 × 7 #>   variable      mean median    sd   mad     q5      q95 #>   <chr>        <dbl>  <dbl> <dbl> <dbl>  <dbl>    <dbl> #> 1 lp__        -7.14  -6.93  0.528 0.247 -8.21  -6.75    #> 2 lp_approx__ -0.520 -0.244 0.740 0.326 -1.90  -0.00227 #> 3 theta        0.251  0.236 0.107 0.108  0.100  0.446   mcmc_hist(fit_vb$draws(\"theta\")) #> `stat_bin()` using `bins = 30`. Pick better value `binwidth`.   # Run 'pathfinder' method, a new alternative to the variational method fit_pf <- mod$pathfinder(data = stan_data, seed = 123) #> Path [1] :Initial log joint density = -18.273334  #> Path [1] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      7.082e-04   1.432e-05    1.000e+00  1.000e+00       156 -6.216e+00 -6.145e+00                    #> Path [1] :Best Iter: [5] ELBO (-6.145070) evaluations: (156)  #> Path [2] :Initial log joint density = -19.192715  #> Path [2] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.015e-04   2.228e-06    1.000e+00  1.000e+00       156 -6.170e+00 -6.223e+00                    #> Path [2] :Best Iter: [2] ELBO (-6.170358) evaluations: (156)  #> Path [3] :Initial log joint density = -6.774820  #> Path [3] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               4      -6.748e+00      1.137e-04   2.596e-07    1.000e+00  1.000e+00       123 -6.243e+00 -6.178e+00                    #> Path [3] :Best Iter: [4] ELBO (-6.177909) evaluations: (123)  #> Path [4] :Initial log joint density = -7.949193  #> Path [4] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.145e-04   1.301e-06    1.000e+00  1.000e+00       156 -6.235e+00 -6.197e+00                    #> Path [4] :Best Iter: [5] ELBO (-6.197118) evaluations: (156)  #> Finished in  0.1 seconds. fit_pf$summary() #> # A tibble: 4 × 7 #>   variable      mean median    sd   mad      q5    q95 #>   <chr>        <dbl>  <dbl> <dbl> <dbl>   <dbl>  <dbl> #> 1 lp_approx__ -1.07  -0.724 0.871 0.306 -2.82   -0.451 #> 2 path__       2.46   2     1.12  1.48   1       4     #> 3 lp__        -7.26  -6.97  0.720 0.304 -8.77   -6.75  #> 4 theta        0.258  0.241 0.121 0.119  0.0840  0.475 mcmc_hist(fit_pf$draws(\"theta\")) #> `stat_bin()` using `bins = 30`. Pick better value `binwidth`.   # Run 'pathfinder' again with more paths, fewer draws per path, # better covariance approximation, and fewer LBFGSs iterations fit_pf <- mod$pathfinder(data = stan_data, num_paths=10, single_path_draws=40,                          history_size=50, max_lbfgs_iters=100) #> Warning: Number of PSIS draws is larger than the total number of draws returned by the single Pathfinders. This is likely unintentional and leads to re-sampling from the same draws.  #> Path [1] :Initial log joint density = -8.310323  #> Path [1] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.823e-04   2.046e-06    1.000e+00  1.000e+00       156 -6.125e+00 -6.208e+00                    #> Path [1] :Best Iter: [3] ELBO (-6.125461) evaluations: (156)  #> Path [2] :Initial log joint density = -6.790997  #> Path [2] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               4      -6.748e+00      2.192e-04   7.752e-07    1.000e+00  1.000e+00       123 -6.187e+00 -6.283e+00                    #> Path [2] :Best Iter: [3] ELBO (-6.187408) evaluations: (123)  #> Path [3] :Initial log joint density = -15.099908  #> Path [3] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.032e-03   6.062e-05    1.000e+00  1.000e+00       156 -6.178e+00 -6.258e+00                    #> Path [3] :Best Iter: [2] ELBO (-6.178157) evaluations: (156)  #> Path [4] :Initial log joint density = -14.659813  #> Path [4] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.038e-03   5.923e-05    1.000e+00  1.000e+00       156 -6.240e+00 -6.208e+00                    #> Path [4] :Best Iter: [5] ELBO (-6.207630) evaluations: (156)  #> Path [5] :Initial log joint density = -7.404606  #> Path [5] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      9.063e-05   3.223e-07    1.000e+00  1.000e+00       156 -6.188e+00 -6.220e+00                    #> Path [5] :Best Iter: [2] ELBO (-6.187733) evaluations: (156)  #> Path [6] :Initial log joint density = -8.140383  #> Path [6] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.529e-04   1.704e-06    1.000e+00  1.000e+00       156 -6.277e+00 -6.250e+00                    #> Path [6] :Best Iter: [5] ELBO (-6.249588) evaluations: (156)  #> Path [7] :Initial log joint density = -9.138920  #> Path [7] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      3.596e-04   3.117e-06    1.000e+00  1.000e+00       156 -6.205e+00 -6.196e+00                    #> Path [7] :Best Iter: [5] ELBO (-6.196231) evaluations: (156)  #> Path [8] :Initial log joint density = -8.762201  #> Path [8] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      3.345e-04   2.735e-06    1.000e+00  1.000e+00       156 -6.208e+00 -6.261e+00                    #> Path [8] :Best Iter: [2] ELBO (-6.207803) evaluations: (156)  #> Path [9] :Initial log joint density = -7.882020  #> Path [9] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.000e-04   1.161e-06    1.000e+00  1.000e+00       156 -6.179e+00 -6.210e+00                    #> Path [9] :Best Iter: [4] ELBO (-6.179298) evaluations: (156)  #> Path [10] :Initial log joint density = -8.613902  #> Path [10] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      3.219e-04   2.555e-06    1.000e+00  1.000e+00       156 -6.201e+00 -6.225e+00                    #> Path [10] :Best Iter: [2] ELBO (-6.200958) evaluations: (156)  #> Finished in  0.1 seconds.  # Specifying initial values as a function fit_mcmc_w_init_fun <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   refresh = 0,   init = function() list(theta = runif(1)) ) #> Running MCMC with 2 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.2 seconds. #>  fit_mcmc_w_init_fun_2 <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   refresh = 0,   init = function(chain_id) {     # silly but demonstrates optional use of chain_id     list(theta = 1 / (chain_id + 1))   } ) #> Running MCMC with 2 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.2 seconds. #>  fit_mcmc_w_init_fun_2$init() #> [[1]] #> [[1]]$theta #> [1] 0.5 #>  #>  #> [[2]] #> [[2]]$theta #> [1] 0.3333333 #>  #>   # Specifying initial values as a list of lists fit_mcmc_w_init_list <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   refresh = 0,   init = list(     list(theta = 0.75), # chain 1     list(theta = 0.25)  # chain 2   ) ) #> Running MCMC with 2 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.2 seconds. #>  fit_optim_w_init_list <- mod$optimize(   data = stan_data,   seed = 123,   init = list(     list(theta = 0.75)   ) ) #> Initial log joint probability = -11.6657  #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes   #>        6      -5.00402   0.000237915   9.55309e-07           1           1        9     #> Optimization terminated normally:   #>   Convergence detected: relative gradient magnitude is below tolerance  #> Finished in  0.1 seconds. fit_optim_w_init_list$init() #> [[1]] #> [[1]]$theta #> [1] 0.75 #>  #>  # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-pathfinder.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Stan's Pathfinder Variational Inference Algorithm — model-method-pathfinder","title":"Run Stan's Pathfinder Variational Inference Algorithm — model-method-pathfinder","text":"$pathfinder() method CmdStanModel object runs Stan's Pathfinder algorithms. Pathfinder variational method approximately sampling differentiable log densities. Starting random initialization, Pathfinder locates normal approximations target density along quasi-Newton optimization path unconstrained space, local covariance estimated using negative inverse Hessian estimates produced LBFGS optimizer. Pathfinder selects normal approximation lowest estimated Kullback-Leibler (KL) divergence true posterior. Finally Pathfinder draws normal approximation returns draws transformed constrained scale. See CmdStan User’s Guide details. argument left NULL default default value used installed version CmdStan","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-pathfinder.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Stan's Pathfinder Variational Inference Algorithm — model-method-pathfinder","text":"","code":"pathfinder(   data = NULL,   seed = NULL,   refresh = NULL,   init = NULL,   save_latent_dynamics = FALSE,   output_dir = getOption(\"cmdstanr_output_dir\"),   output_basename = NULL,   sig_figs = NULL,   opencl_ids = NULL,   num_threads = NULL,   init_alpha = NULL,   tol_obj = NULL,   tol_rel_obj = NULL,   tol_grad = NULL,   tol_rel_grad = NULL,   tol_param = NULL,   history_size = NULL,   single_path_draws = NULL,   draws = NULL,   num_paths = 4,   max_lbfgs_iters = NULL,   num_elbo_draws = NULL,   save_single_paths = NULL,   psis_resample = NULL,   calculate_lp = NULL,   show_messages = TRUE,   show_exceptions = TRUE,   save_cmdstan_config = NULL )"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-pathfinder.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Stan's Pathfinder Variational Inference Algorithm — model-method-pathfinder","text":"data (multiple options) data use variables specified data block Stan program. One following: named list R objects names corresponding variables declared data block Stan program. Internally list written JSON CmdStan using write_stan_json(). See write_stan_json() details conversions performed R objects passed Stan. path data file compatible CmdStan (JSON R dump). See appendices CmdStan guide details using formats. NULL empty list Stan program data block. seed (positive integer(s)) seed (P)RNG pass CmdStan. case multi-chain sampling single seed automatically augmented run (chain) ID chain uses different seed. exception transformed data block, defaults using seed chains data generated chains RNG functions used. time seed specified vector (one element per chain) RNG functions used transformed data goal generate different data chain. refresh (non-negative integer) number iterations printed screen updates. refresh = 0, error messages printed. init (multiple options) initialization method use variables declared parameters block Stan program. One following: real number x>0. initializes parameters randomly [-x,x] unconstrained parameter space.; number 0. initializes parameters 0; character vector paths (one per chain) JSON Rdump files containing initial values parameters. See write_stan_json() write R objects JSON files compatible CmdStan. list lists containing initial values parameters. MCMC list contain sublist chain. model fitting methods just one sublist. sublists named elements corresponding parameters specifying initial values. See Examples. function returns single list names corresponding parameters specifying initial values. function can take arguments single argument chain_id. MCMC, function argument chain_id supplied chain id (1 number chains) called generate initial values. See Examples. CmdStanMCMC, CmdStanMLE, CmdStanVB, CmdStanPathfinder, CmdStanLaplace fit object. fit object's parameters subset model parameters parameters drawn Stan's default initialization. fit object must least parameters name dimensions current Stan model. sample pathfinder method, fit object fewer draws requested number chains/paths inits drawn using sampling replacement. Otherwise sampling without replacement used. CmdStanPathfinder fit object used init, . psis_resample set FALSE calculate_lp set TRUE (default), resampling without replacement Pareto smoothed weights used. psis_resample set TRUE calculate_lp set FALSE sampling without replacement uniform weights used select draws. PSIS resampling used select draws  CmdStanVB, CmdStanLaplace fit objects. type inheriting posterior::draws. draws object less samples number requested chains/paths inits drawn using sampling replacement. Otherwise sampling without replacement used. draws object's parameters subset model parameters parameters drawn Stan's default initialization. fit object must least parameters name dimensions current Stan model. save_latent_dynamics (logical) auxiliary diagnostic information latent dynamics written temporary diagnostic CSV files? argument replaces CmdStan's diagnostic_file argument content written CSV controlled user's CmdStan installation CmdStanR (algorithms content may written). default FALSE, appropriate almost every use case. save temporary files created save_latent_dynamics=TRUE see $save_latent_dynamics_files() method. output_dir (string) path directory CmdStan write output CSV files. MCMC one file per chain; methods single file. interactive use can typically left NULL (temporary directory) since CmdStanR makes CmdStan output (posterior draws diagnostics) available R via methods fitted model objects. can set entire R session using options(cmdstanr_output_dir). behavior output_dir follows: NULL (default), CSV files written temporary directory saved permanently user calls one $save_* methods fitted model object (e.g., $save_output_files()). temporary files removed fitted model object garbage collected (manually automatically). path, files created output_dir names corresponding defaults used $save_output_files(). output_basename (string) string use prefix names output CSV files CmdStan. NULL (default), basename output CSV files comprised model name, timestamp, 5 random characters. sig_figs (positive integer) number significant figures used storing output values. default, CmdStan represent output values 6 significant figures. upper limit sig_figs 18. Increasing value result larger output CSV files thus increased usage disk space. opencl_ids (integer vector length 2) platform device IDs OpenCL device use fitting. model must compiled cpp_options = list(stan_opencl = TRUE) argument effect. num_threads (positive integer) model compiled threading support, number threads use parallelized sections (e.g., multi-path pathfinder well reduce_sum). init_alpha (positive real) initial step size parameter. tol_obj (positive real) Convergence tolerance changes objective function value. tol_rel_obj (positive real) Convergence tolerance relative changes objective function value. tol_grad (positive real) Convergence tolerance norm gradient. tol_rel_grad (positive real) Convergence tolerance relative norm gradient. tol_param (positive real) Convergence tolerance changes parameter value. history_size (positive integer) size history used approximating Hessian. single_path_draws (positive integer) Number draws single pathfinder return. number draws PSIS sampling samples equal single_path_draws * num_paths. draws (positive integer) Number draws return performing pareto smooted importance sampling (PSIS). smaller single_path_draws * num_paths (future versions CmdStan throw warning). num_paths (positive integer) Number single pathfinders run. max_lbfgs_iters (positive integer) maximum number iterations LBFGS. num_elbo_draws (positive integer) Number draws make calculating ELBO approximation iteration LBFGS. save_single_paths (logical) Whether save results single pathfinder runs multi-pathfinder. psis_resample (logical) Whether perform pareto smoothed importance sampling. TRUE, number draws returned equal draws. FALSE, number draws returned equal single_path_draws * num_paths. calculate_lp (logical) Whether calculate log probability draws. TRUE, log probability calculated given output. FALSE, log probability returned draws used determine ELBO pathfinder steps. draws log probability NA. value FALSE also turn pareto smoothed importance sampling lp calculation needed PSIS. show_messages (logical) TRUE (default), prints output execution process, iteration numbers elapsed times. output silenced $output() method resulting fit object can used display silenced messages. show_exceptions (logical) TRUE (default), prints informational messages, example rejection current proposal. Disable wish silence messages, usually recommended unless confident model correct numerical error. messages silenced $output() method resulting fit object can used display silenced messages. save_cmdstan_config (logical) TRUE (default), call CmdStan argument \"output save_config=1\" save json file contains argument tree extra information (equivalent output CSV file header). option available CmdStan 2.34.0 later.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-pathfinder.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run Stan's Pathfinder Variational Inference Algorithm — model-method-pathfinder","text":"CmdStanPathfinder object.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-pathfinder.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run Stan's Pathfinder Variational Inference Algorithm — model-method-pathfinder","text":"","code":"# \\dontrun{ library(cmdstanr) library(posterior) library(bayesplot) color_scheme_set(\"brightblue\")  # Set path to CmdStan # (Note: if you installed CmdStan via install_cmdstan() with default settings # then setting the path is unnecessary but the default below should still work. # Otherwise use the `path` argument to specify the location of your # CmdStan installation.) set_cmdstan_path(path = NULL) #> CmdStan path set to: /home/runner/.cmdstan/cmdstan-2.37.0  # Create a CmdStanModel object from a Stan program, # here using the example model that comes with CmdStan file <- file.path(cmdstan_path(), \"examples/bernoulli/bernoulli.stan\") mod <- cmdstan_model(file) mod$print() #> data { #>   int<lower=0> N; #>   array[N] int<lower=0, upper=1> y; #> } #> parameters { #>   real<lower=0, upper=1> theta; #> } #> model { #>   theta ~ beta(1, 1); // uniform prior on interval 0,1 #>   y ~ bernoulli(theta); #> } # Print with line numbers. This can be set globally using the # `cmdstanr_print_line_numbers` option. mod$print(line_numbers = TRUE) #>  1: data { #>  2:   int<lower=0> N; #>  3:   array[N] int<lower=0, upper=1> y; #>  4: } #>  5: parameters { #>  6:   real<lower=0, upper=1> theta; #>  7: } #>  8: model { #>  9:   theta ~ beta(1, 1); // uniform prior on interval 0,1 #> 10:   y ~ bernoulli(theta); #> 11: }  # Data as a named list (like RStan) stan_data <- list(N = 10, y = c(0,1,0,0,0,0,0,0,0,1))  # Run MCMC using the 'sample' method fit_mcmc <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   parallel_chains = 2 ) #> Running MCMC with 2 parallel chains... #>  #> Chain 1 Iteration:    1 / 2000 [  0%]  (Warmup)  #> Chain 1 Iteration:  100 / 2000 [  5%]  (Warmup)  #> Chain 1 Iteration:  200 / 2000 [ 10%]  (Warmup)  #> Chain 1 Iteration:  300 / 2000 [ 15%]  (Warmup)  #> Chain 1 Iteration:  400 / 2000 [ 20%]  (Warmup)  #> Chain 1 Iteration:  500 / 2000 [ 25%]  (Warmup)  #> Chain 1 Iteration:  600 / 2000 [ 30%]  (Warmup)  #> Chain 1 Iteration:  700 / 2000 [ 35%]  (Warmup)  #> Chain 1 Iteration:  800 / 2000 [ 40%]  (Warmup)  #> Chain 1 Iteration:  900 / 2000 [ 45%]  (Warmup)  #> Chain 1 Iteration: 1000 / 2000 [ 50%]  (Warmup)  #> Chain 1 Iteration: 1001 / 2000 [ 50%]  (Sampling)  #> Chain 1 Iteration: 1100 / 2000 [ 55%]  (Sampling)  #> Chain 1 Iteration: 1200 / 2000 [ 60%]  (Sampling)  #> Chain 1 Iteration: 1300 / 2000 [ 65%]  (Sampling)  #> Chain 1 Iteration: 1400 / 2000 [ 70%]  (Sampling)  #> Chain 1 Iteration: 1500 / 2000 [ 75%]  (Sampling)  #> Chain 1 Iteration: 1600 / 2000 [ 80%]  (Sampling)  #> Chain 1 Iteration: 1700 / 2000 [ 85%]  (Sampling)  #> Chain 1 Iteration: 1800 / 2000 [ 90%]  (Sampling)  #> Chain 1 Iteration: 1900 / 2000 [ 95%]  (Sampling)  #> Chain 1 Iteration: 2000 / 2000 [100%]  (Sampling)  #> Chain 2 Iteration:    1 / 2000 [  0%]  (Warmup)  #> Chain 2 Iteration:  100 / 2000 [  5%]  (Warmup)  #> Chain 2 Iteration:  200 / 2000 [ 10%]  (Warmup)  #> Chain 2 Iteration:  300 / 2000 [ 15%]  (Warmup)  #> Chain 2 Iteration:  400 / 2000 [ 20%]  (Warmup)  #> Chain 2 Iteration:  500 / 2000 [ 25%]  (Warmup)  #> Chain 2 Iteration:  600 / 2000 [ 30%]  (Warmup)  #> Chain 2 Iteration:  700 / 2000 [ 35%]  (Warmup)  #> Chain 2 Iteration:  800 / 2000 [ 40%]  (Warmup)  #> Chain 2 Iteration:  900 / 2000 [ 45%]  (Warmup)  #> Chain 2 Iteration: 1000 / 2000 [ 50%]  (Warmup)  #> Chain 2 Iteration: 1001 / 2000 [ 50%]  (Sampling)  #> Chain 2 Iteration: 1100 / 2000 [ 55%]  (Sampling)  #> Chain 2 Iteration: 1200 / 2000 [ 60%]  (Sampling)  #> Chain 2 Iteration: 1300 / 2000 [ 65%]  (Sampling)  #> Chain 2 Iteration: 1400 / 2000 [ 70%]  (Sampling)  #> Chain 2 Iteration: 1500 / 2000 [ 75%]  (Sampling)  #> Chain 2 Iteration: 1600 / 2000 [ 80%]  (Sampling)  #> Chain 2 Iteration: 1700 / 2000 [ 85%]  (Sampling)  #> Chain 2 Iteration: 1800 / 2000 [ 90%]  (Sampling)  #> Chain 2 Iteration: 1900 / 2000 [ 95%]  (Sampling)  #> Chain 2 Iteration: 2000 / 2000 [100%]  (Sampling)  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.1 seconds. #>   # Use 'posterior' package for summaries fit_mcmc$summary() #> # A tibble: 2 × 10 #>   variable   mean median    sd   mad      q5    q95  rhat ess_bulk ess_tail #>   <chr>     <dbl>  <dbl> <dbl> <dbl>   <dbl>  <dbl> <dbl>    <dbl>    <dbl> #> 1 lp__     -7.32  -7.02  0.799 0.355 -8.89   -6.75   1.00     819.    1020. #> 2 theta     0.255  0.240 0.127 0.130  0.0773  0.491  1.00     557.     616.  # Check sampling diagnostics fit_mcmc$diagnostic_summary() #> $num_divergent #> [1] 0 0 #>  #> $num_max_treedepth #> [1] 0 0 #>  #> $ebfmi #> [1] 1.114870 1.030279 #>   # Get posterior draws draws <- fit_mcmc$draws() print(draws) #> # A draws_array: 1000 iterations, 2 chains, and 2 variables #> , , variable = lp__ #>  #>          chain #> iteration    1    2 #>         1 -7.0 -6.8 #>         2 -7.9 -6.9 #>         3 -7.4 -6.9 #>         4 -6.7 -6.8 #>         5 -6.9 -6.8 #>  #> , , variable = theta #>  #>          chain #> iteration    1    2 #>         1 0.17 0.28 #>         2 0.46 0.19 #>         3 0.41 0.19 #>         4 0.25 0.28 #>         5 0.18 0.23 #>  #> # ... with 995 more iterations  # Convert to data frame using posterior::as_draws_df as_draws_df(draws) #> # A draws_df: 1000 iterations, 2 chains, and 2 variables #>    lp__ theta #> 1  -7.0  0.17 #> 2  -7.9  0.46 #> 3  -7.4  0.41 #> 4  -6.7  0.25 #> 5  -6.9  0.18 #> 6  -6.9  0.33 #> 7  -7.2  0.15 #> 8  -6.8  0.29 #> 9  -6.8  0.24 #> 10 -6.8  0.24 #> # ... with 1990 more draws #> # ... hidden reserved variables {'.chain', '.iteration', '.draw'}  # Plot posterior using bayesplot (ggplot2) mcmc_hist(fit_mcmc$draws(\"theta\")) #> `stat_bin()` using `bins = 30`. Pick better value `binwidth`.   # Run 'optimize' method to get a point estimate (default is Stan's LBFGS algorithm) # and also demonstrate specifying data as a path to a file instead of a list my_data_file <- file.path(cmdstan_path(), \"examples/bernoulli/bernoulli.data.json\") fit_optim <- mod$optimize(data = my_data_file, seed = 123) #> Initial log joint probability = -16.144  #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes   #>        6      -5.00402   0.000246518   8.73164e-07           1           1        9     #> Optimization terminated normally:   #>   Convergence detected: relative gradient magnitude is below tolerance  #> Finished in  0.1 seconds. fit_optim$summary() #> # A tibble: 2 × 2 #>   variable estimate #>   <chr>       <dbl> #> 1 lp__       -5.00  #> 2 theta       0.200  # Run 'optimize' again with 'jacobian=TRUE' and then draw from Laplace approximation # to the posterior fit_optim <- mod$optimize(data = my_data_file, jacobian = TRUE) #> Initial log joint probability = -9.01499  #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes   #>        5      -6.74802    0.00034524   2.91272e-06           1           1        8     #> Optimization terminated normally:   #>   Convergence detected: relative gradient magnitude is below tolerance  #> Finished in  0.1 seconds. fit_laplace <- mod$laplace(data = my_data_file, mode = fit_optim, draws = 2000) #> Calculating Hessian  #> Calculating inverse of Cholesky factor  #> Generating draws  #> iteration: 0  #> iteration: 100  #> iteration: 200  #> iteration: 300  #> iteration: 400  #> iteration: 500  #> iteration: 600  #> iteration: 700  #> iteration: 800  #> iteration: 900  #> iteration: 1000  #> iteration: 1100  #> iteration: 1200  #> iteration: 1300  #> iteration: 1400  #> iteration: 1500  #> iteration: 1600  #> iteration: 1700  #> iteration: 1800  #> iteration: 1900  #> Finished in  0.1 seconds. fit_laplace$summary() #> # A tibble: 3 × 7 #>   variable      mean median    sd   mad     q5      q95 #>   <chr>        <dbl>  <dbl> <dbl> <dbl>  <dbl>    <dbl> #> 1 lp__        -7.24  -6.96  0.708 0.292 -8.71  -6.75    #> 2 lp_approx__ -0.494 -0.218 0.710 0.298 -1.94  -0.00169 #> 3 theta        0.272  0.254 0.123 0.121  0.101  0.502    # Run 'variational' method to use ADVI to approximate posterior fit_vb <- mod$variational(data = stan_data, seed = 123) #> ------------------------------------------------------------  #> EXPERIMENTAL ALGORITHM:  #>   This procedure has not been thoroughly tested and may be unstable  #>   or buggy. The interface is subject to change.  #> ------------------------------------------------------------  #> Gradient evaluation took 2e-06 seconds  #> 1000 transitions using 10 leapfrog steps per transition would take 0.02 seconds.  #> Adjust your expectations accordingly!  #> Begin eta adaptation.  #> Iteration:   1 / 250 [  0%]  (Adaptation)  #> Iteration:  50 / 250 [ 20%]  (Adaptation)  #> Iteration: 100 / 250 [ 40%]  (Adaptation)  #> Iteration: 150 / 250 [ 60%]  (Adaptation)  #> Iteration: 200 / 250 [ 80%]  (Adaptation)  #> Success! Found best value [eta = 1] earlier than expected.  #> Begin stochastic gradient ascent.  #>   iter             ELBO   delta_ELBO_mean   delta_ELBO_med   notes   #>    100           -6.164             1.000            1.000  #>    200           -6.225             0.505            1.000  #>    300           -6.186             0.339            0.010   MEDIAN ELBO CONVERGED  #> Drawing a sample of size 1000 from the approximate posterior...   #> COMPLETED.  #> Finished in  0.1 seconds. fit_vb$summary() #> # A tibble: 3 × 7 #>   variable      mean median    sd   mad     q5      q95 #>   <chr>        <dbl>  <dbl> <dbl> <dbl>  <dbl>    <dbl> #> 1 lp__        -7.14  -6.93  0.528 0.247 -8.21  -6.75    #> 2 lp_approx__ -0.520 -0.244 0.740 0.326 -1.90  -0.00227 #> 3 theta        0.251  0.236 0.107 0.108  0.100  0.446   mcmc_hist(fit_vb$draws(\"theta\")) #> `stat_bin()` using `bins = 30`. Pick better value `binwidth`.   # Run 'pathfinder' method, a new alternative to the variational method fit_pf <- mod$pathfinder(data = stan_data, seed = 123) #> Path [1] :Initial log joint density = -18.273334  #> Path [1] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      7.082e-04   1.432e-05    1.000e+00  1.000e+00       156 -6.216e+00 -6.145e+00                    #> Path [1] :Best Iter: [5] ELBO (-6.145070) evaluations: (156)  #> Path [2] :Initial log joint density = -19.192715  #> Path [2] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.015e-04   2.228e-06    1.000e+00  1.000e+00       156 -6.170e+00 -6.223e+00                    #> Path [2] :Best Iter: [2] ELBO (-6.170358) evaluations: (156)  #> Path [3] :Initial log joint density = -6.774820  #> Path [3] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               4      -6.748e+00      1.137e-04   2.596e-07    1.000e+00  1.000e+00       123 -6.243e+00 -6.178e+00                    #> Path [3] :Best Iter: [4] ELBO (-6.177909) evaluations: (123)  #> Path [4] :Initial log joint density = -7.949193  #> Path [4] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.145e-04   1.301e-06    1.000e+00  1.000e+00       156 -6.235e+00 -6.197e+00                    #> Path [4] :Best Iter: [5] ELBO (-6.197118) evaluations: (156)  #> Finished in  0.1 seconds. fit_pf$summary() #> # A tibble: 4 × 7 #>   variable      mean median    sd   mad      q5    q95 #>   <chr>        <dbl>  <dbl> <dbl> <dbl>   <dbl>  <dbl> #> 1 lp_approx__ -1.07  -0.724 0.871 0.306 -2.82   -0.451 #> 2 path__       2.46   2     1.12  1.48   1       4     #> 3 lp__        -7.26  -6.97  0.720 0.304 -8.77   -6.75  #> 4 theta        0.258  0.241 0.121 0.119  0.0840  0.475 mcmc_hist(fit_pf$draws(\"theta\")) #> `stat_bin()` using `bins = 30`. Pick better value `binwidth`.   # Run 'pathfinder' again with more paths, fewer draws per path, # better covariance approximation, and fewer LBFGSs iterations fit_pf <- mod$pathfinder(data = stan_data, num_paths=10, single_path_draws=40,                          history_size=50, max_lbfgs_iters=100) #> Warning: Number of PSIS draws is larger than the total number of draws returned by the single Pathfinders. This is likely unintentional and leads to re-sampling from the same draws.  #> Path [1] :Initial log joint density = -6.783080  #> Path [1] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               4      -6.748e+00      1.654e-04   4.849e-07    1.000e+00  1.000e+00       123 -6.187e+00 -6.169e+00                    #> Path [1] :Best Iter: [4] ELBO (-6.168710) evaluations: (123)  #> Path [2] :Initial log joint density = -10.189208  #> Path [2] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      6.944e-04   8.705e-06    1.000e+00  1.000e+00       156 -6.227e+00 -6.239e+00                    #> Path [2] :Best Iter: [4] ELBO (-6.226953) evaluations: (156)  #> Path [3] :Initial log joint density = -13.236025  #> Path [3] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      1.756e-03   4.251e-05    1.000e+00  1.000e+00       156 -6.220e+00 -6.217e+00                    #> Path [3] :Best Iter: [5] ELBO (-6.216959) evaluations: (156)  #> Path [4] :Initial log joint density = -7.116461  #> Path [4] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      1.368e-04   8.770e-08    1.000e+00  1.000e+00       156 -6.184e+00 -6.257e+00                    #> Path [4] :Best Iter: [2] ELBO (-6.184288) evaluations: (156)  #> Path [5] :Initial log joint density = -12.455275  #> Path [5] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      1.454e-03   2.968e-05    1.000e+00  1.000e+00       156 -6.226e+00 -6.236e+00                    #> Path [5] :Best Iter: [4] ELBO (-6.226090) evaluations: (156)  #> Path [6] :Initial log joint density = -6.947818  #> Path [6] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               4      -6.748e+00      3.221e-04   6.522e-05    9.203e-01  9.203e-01       123 -6.160e+00 -6.156e+00                    #> Path [6] :Best Iter: [4] ELBO (-6.156025) evaluations: (123)  #> Path [7] :Initial log joint density = -15.152853  #> Path [7] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.028e-03   6.063e-05    1.000e+00  1.000e+00       156 -6.234e+00 -6.243e+00                    #> Path [7] :Best Iter: [4] ELBO (-6.234219) evaluations: (156)  #> Path [8] :Initial log joint density = -6.864548  #> Path [8] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               4      -6.748e+00      8.329e-04   7.178e-06    1.000e+00  1.000e+00       123 -6.203e+00 -6.254e+00                    #> Path [8] :Best Iter: [2] ELBO (-6.202912) evaluations: (123)  #> Path [9] :Initial log joint density = -6.881790  #> Path [9] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               4      -6.748e+00      9.946e-04   9.649e-06    1.000e+00  1.000e+00       123 -6.217e+00 -6.194e+00                    #> Path [9] :Best Iter: [4] ELBO (-6.194380) evaluations: (123)  #> Path [10] :Initial log joint density = -7.206653  #> Path [10] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               4      -6.748e+00      4.306e-03   1.107e-04    1.000e+00  1.000e+00       123 -6.205e+00 -6.213e+00                    #> Path [10] :Best Iter: [2] ELBO (-6.205273) evaluations: (123)  #> Finished in  0.1 seconds.  # Specifying initial values as a function fit_mcmc_w_init_fun <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   refresh = 0,   init = function() list(theta = runif(1)) ) #> Running MCMC with 2 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.2 seconds. #>  fit_mcmc_w_init_fun_2 <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   refresh = 0,   init = function(chain_id) {     # silly but demonstrates optional use of chain_id     list(theta = 1 / (chain_id + 1))   } ) #> Running MCMC with 2 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.2 seconds. #>  fit_mcmc_w_init_fun_2$init() #> [[1]] #> [[1]]$theta #> [1] 0.5 #>  #>  #> [[2]] #> [[2]]$theta #> [1] 0.3333333 #>  #>   # Specifying initial values as a list of lists fit_mcmc_w_init_list <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   refresh = 0,   init = list(     list(theta = 0.75), # chain 1     list(theta = 0.25)  # chain 2   ) ) #> Running MCMC with 2 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.2 seconds. #>  fit_optim_w_init_list <- mod$optimize(   data = stan_data,   seed = 123,   init = list(     list(theta = 0.75)   ) ) #> Initial log joint probability = -11.6657  #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes   #>        6      -5.00402   0.000237915   9.55309e-07           1           1        9     #> Optimization terminated normally:   #>   Convergence detected: relative gradient magnitude is below tolerance  #> Finished in  0.1 seconds. fit_optim_w_init_list$init() #> [[1]] #> [[1]]$theta #> [1] 0.75 #>  #>  # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-sample.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Stan's MCMC algorithms — model-method-sample","title":"Run Stan's MCMC algorithms — model-method-sample","text":"$sample() method CmdStanModel object runs Stan's main Markov chain Monte Carlo algorithm. argument left NULL default default value used installed version CmdStan. See CmdStan User’s Guide details. model fitting diagnostics specified via diagnostics argument checked warnings printed warranted.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-sample.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Stan's MCMC algorithms — model-method-sample","text":"","code":"sample(   data = NULL,   seed = NULL,   refresh = NULL,   init = NULL,   save_latent_dynamics = FALSE,   output_dir = getOption(\"cmdstanr_output_dir\"),   output_basename = NULL,   sig_figs = NULL,   chains = 4,   parallel_chains = getOption(\"mc.cores\", 1),   chain_ids = seq_len(chains),   threads_per_chain = NULL,   opencl_ids = NULL,   iter_warmup = NULL,   iter_sampling = NULL,   save_warmup = FALSE,   thin = NULL,   max_treedepth = NULL,   adapt_engaged = TRUE,   adapt_delta = NULL,   step_size = NULL,   metric = NULL,   metric_file = NULL,   inv_metric = NULL,   init_buffer = NULL,   term_buffer = NULL,   window = NULL,   fixed_param = FALSE,   show_messages = TRUE,   show_exceptions = TRUE,   diagnostics = c(\"divergences\", \"treedepth\", \"ebfmi\"),   save_metric = NULL,   save_cmdstan_config = NULL,   cores = NULL,   num_cores = NULL,   num_chains = NULL,   num_warmup = NULL,   num_samples = NULL,   validate_csv = NULL,   save_extra_diagnostics = NULL,   max_depth = NULL,   stepsize = NULL )"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-sample.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Stan's MCMC algorithms — model-method-sample","text":"data (multiple options) data use variables specified data block Stan program. One following: named list R objects names corresponding variables declared data block Stan program. Internally list written JSON CmdStan using write_stan_json(). See write_stan_json() details conversions performed R objects passed Stan. path data file compatible CmdStan (JSON R dump). See appendices CmdStan guide details using formats. NULL empty list Stan program data block. seed (positive integer(s)) seed (P)RNG pass CmdStan. case multi-chain sampling single seed automatically augmented run (chain) ID chain uses different seed. exception transformed data block, defaults using seed chains data generated chains RNG functions used. time seed specified vector (one element per chain) RNG functions used transformed data goal generate different data chain. refresh (non-negative integer) number iterations printed screen updates. refresh = 0, error messages printed. init (multiple options) initialization method use variables declared parameters block Stan program. One following: real number x>0. initializes parameters randomly [-x,x] unconstrained parameter space.; number 0. initializes parameters 0; character vector paths (one per chain) JSON Rdump files containing initial values parameters. See write_stan_json() write R objects JSON files compatible CmdStan. list lists containing initial values parameters. MCMC list contain sublist chain. model fitting methods just one sublist. sublists named elements corresponding parameters specifying initial values. See Examples. function returns single list names corresponding parameters specifying initial values. function can take arguments single argument chain_id. MCMC, function argument chain_id supplied chain id (1 number chains) called generate initial values. See Examples. CmdStanMCMC, CmdStanMLE, CmdStanVB, CmdStanPathfinder, CmdStanLaplace fit object. fit object's parameters subset model parameters parameters drawn Stan's default initialization. fit object must least parameters name dimensions current Stan model. sample pathfinder method, fit object fewer draws requested number chains/paths inits drawn using sampling replacement. Otherwise sampling without replacement used. CmdStanPathfinder fit object used init, . psis_resample set FALSE calculate_lp set TRUE (default), resampling without replacement Pareto smoothed weights used. psis_resample set TRUE calculate_lp set FALSE sampling without replacement uniform weights used select draws. PSIS resampling used select draws  CmdStanVB, CmdStanLaplace fit objects. type inheriting posterior::draws. draws object less samples number requested chains/paths inits drawn using sampling replacement. Otherwise sampling without replacement used. draws object's parameters subset model parameters parameters drawn Stan's default initialization. fit object must least parameters name dimensions current Stan model. save_latent_dynamics (logical) auxiliary diagnostic information latent dynamics written temporary diagnostic CSV files? argument replaces CmdStan's diagnostic_file argument content written CSV controlled user's CmdStan installation CmdStanR (algorithms content may written). default FALSE, appropriate almost every use case. save temporary files created save_latent_dynamics=TRUE see $save_latent_dynamics_files() method. output_dir (string) path directory CmdStan write output CSV files. MCMC one file per chain; methods single file. interactive use can typically left NULL (temporary directory) since CmdStanR makes CmdStan output (posterior draws diagnostics) available R via methods fitted model objects. can set entire R session using options(cmdstanr_output_dir). behavior output_dir follows: NULL (default), CSV files written temporary directory saved permanently user calls one $save_* methods fitted model object (e.g., $save_output_files()). temporary files removed fitted model object garbage collected (manually automatically). path, files created output_dir names corresponding defaults used $save_output_files(). output_basename (string) string use prefix names output CSV files CmdStan. NULL (default), basename output CSV files comprised model name, timestamp, 5 random characters. sig_figs (positive integer) number significant figures used storing output values. default, CmdStan represent output values 6 significant figures. upper limit sig_figs 18. Increasing value result larger output CSV files thus increased usage disk space. chains (positive integer) number Markov chains run. default 4. parallel_chains (positive integer) maximum number MCMC chains run parallel. parallel_chains specified default look option \"mc.cores\", can set entire R session options(mc.cores=value). \"mc.cores\" option set default 1. chain_ids (integer vector) vector chain IDs. Must contain many unique positive integers number chains. set, default chain IDs used (integers starting 1). threads_per_chain (positive integer) model compiled threading support, number threads use parallelized sections within MCMC chain (e.g., using Stan functions reduce_sum() map_rect()). contrast parallel_chains, specifies number chains run parallel. actual number CPU cores used parallel_chains*threads_per_chain. example using threading see Stan case study Reduce Sum: Minimal Example. opencl_ids (integer vector length 2) platform device IDs OpenCL device use fitting. model must compiled cpp_options = list(stan_opencl = TRUE) argument effect. iter_warmup (positive integer) number warmup iterations run per chain. Note: CmdStan User's Guide referred num_warmup. iter_sampling (positive integer) number post-warmup iterations run per chain. Note: CmdStan User's Guide referred num_samples. save_warmup (logical) warmup iterations saved? default FALSE. thin (positive integer) period saved samples. typically left default (thinning) unless memory problem. max_treedepth (positive integer) maximum allowed tree depth NUTS engine. See Tree Depth section CmdStan User's Guide details. adapt_engaged (logical) warmup adaptation? default TRUE. precomputed inverse metric specified via inv_metric argument (metric_file) , adapt_engaged=TRUE, Stan use provided inverse metric just initial guess adaptation. turn adaptation using precomputed inverse metric set adapt_engaged=FALSE. adapt_delta (real (0,1)) adaptation target acceptance statistic. step_size (positive real) initial step size discrete approximation continuous Hamiltonian dynamics. tuned warmup. metric (string) One \"diag_e\", \"dense_e\", \"unit_e\", specifying geometry base manifold. See Euclidean Metric section CmdStan User's Guide details. specify precomputed (inverse) metric, see inv_metric argument . metric_file (character vector) paths JSON Rdump files (one per chain) compatible CmdStan contain precomputed inverse metrics. metric_file argument inherited CmdStan confusing entry JSON Rdump file(s) must named inv_metric, referring inverse metric. recommend instead using CmdStanR's inv_metric argument (see ) specify inverse metric directly using vector matrix R session. inv_metric (vector, matrix) vector (metric='diag_e') matrix (metric='dense_e') initializing inverse metric. can used alternative metric_file argument. vector interpreted diagonal metric. inverse metric usually set estimate posterior covariance. See adapt_engaged argument details (control ) specifying precomputed inverse metric interacts adaptation. init_buffer (nonnegative integer) Width initial fast timestep adaptation interval warmup. term_buffer (nonnegative integer) Width final fast timestep adaptation interval warmup. window (nonnegative integer) Initial width slow timestep/metric adaptation interval. fixed_param (logical) TRUE, call CmdStan argument \"algorithm=fixed_param\". default FALSE. fixed parameter sampler generates new sample without changing current state Markov chain; generated quantities may change. can useful , example, trying generate pseudo-data using generated quantities block. parameters block empty using fixed_param=TRUE mandatory. fixed_param=TRUE chains parallel_chains arguments set 1. show_messages (logical) TRUE (default), prints output execution process, iteration numbers elapsed times. output silenced $output() method resulting fit object can used display silenced messages. show_exceptions (logical) TRUE (default), prints informational messages, example rejection current proposal. Disable wish silence messages, usually recommended unless confident model correct numerical error. messages silenced $output() method resulting fit object can used display silenced messages. diagnostics (character vector) diagnostics automatically check warn sampling. Setting empty string \"\" NULL can used prevent CmdStanR automatically reading sampler diagnostics CSV wish manually read results validate , example using read_cmdstan_csv(). currently available diagnostics \"divergences\", \"treedepth\", \"ebfmi\" (default check ). diagnostics also available fitting. $sampler_diagnostics() method provides access diagnostic values iteration $diagnostic_summary() method provides summaries diagnostics can regenerate warning messages. Diagnostics like R-hat effective sample size currently available via diagnostics argument can checked fitting using $summary() method. save_metric (logical) TRUE, call CmdStan argument \"adaptation save_metric=1\" save adapted metric separate JSON file elements \"stepsize\", \"metric_type\" \"inv_metric\". default TRUE. option available CmdStan 2.34.0 later. save_cmdstan_config (logical) TRUE (default), call CmdStan argument \"output save_config=1\" save json file contains argument tree extra information (equivalent output CSV file header). option available CmdStan 2.34.0 later. cores, num_cores, num_chains, num_warmup, num_samples, save_extra_diagnostics, max_depth, stepsize, validate_csv Deprecated removed future release.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-sample.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run Stan's MCMC algorithms — model-method-sample","text":"CmdStanMCMC object.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-sample.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run Stan's MCMC algorithms — model-method-sample","text":"","code":"# \\dontrun{ library(cmdstanr) library(posterior) library(bayesplot) color_scheme_set(\"brightblue\")  # Set path to CmdStan # (Note: if you installed CmdStan via install_cmdstan() with default settings # then setting the path is unnecessary but the default below should still work. # Otherwise use the `path` argument to specify the location of your # CmdStan installation.) set_cmdstan_path(path = NULL) #> CmdStan path set to: /home/runner/.cmdstan/cmdstan-2.37.0  # Create a CmdStanModel object from a Stan program, # here using the example model that comes with CmdStan file <- file.path(cmdstan_path(), \"examples/bernoulli/bernoulli.stan\") mod <- cmdstan_model(file) mod$print() #> data { #>   int<lower=0> N; #>   array[N] int<lower=0, upper=1> y; #> } #> parameters { #>   real<lower=0, upper=1> theta; #> } #> model { #>   theta ~ beta(1, 1); // uniform prior on interval 0,1 #>   y ~ bernoulli(theta); #> } # Print with line numbers. This can be set globally using the # `cmdstanr_print_line_numbers` option. mod$print(line_numbers = TRUE) #>  1: data { #>  2:   int<lower=0> N; #>  3:   array[N] int<lower=0, upper=1> y; #>  4: } #>  5: parameters { #>  6:   real<lower=0, upper=1> theta; #>  7: } #>  8: model { #>  9:   theta ~ beta(1, 1); // uniform prior on interval 0,1 #> 10:   y ~ bernoulli(theta); #> 11: }  # Data as a named list (like RStan) stan_data <- list(N = 10, y = c(0,1,0,0,0,0,0,0,0,1))  # Run MCMC using the 'sample' method fit_mcmc <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   parallel_chains = 2 ) #> Running MCMC with 2 parallel chains... #>  #> Chain 1 Iteration:    1 / 2000 [  0%]  (Warmup)  #> Chain 1 Iteration:  100 / 2000 [  5%]  (Warmup)  #> Chain 1 Iteration:  200 / 2000 [ 10%]  (Warmup)  #> Chain 1 Iteration:  300 / 2000 [ 15%]  (Warmup)  #> Chain 1 Iteration:  400 / 2000 [ 20%]  (Warmup)  #> Chain 1 Iteration:  500 / 2000 [ 25%]  (Warmup)  #> Chain 1 Iteration:  600 / 2000 [ 30%]  (Warmup)  #> Chain 1 Iteration:  700 / 2000 [ 35%]  (Warmup)  #> Chain 1 Iteration:  800 / 2000 [ 40%]  (Warmup)  #> Chain 1 Iteration:  900 / 2000 [ 45%]  (Warmup)  #> Chain 1 Iteration: 1000 / 2000 [ 50%]  (Warmup)  #> Chain 1 Iteration: 1001 / 2000 [ 50%]  (Sampling)  #> Chain 1 Iteration: 1100 / 2000 [ 55%]  (Sampling)  #> Chain 1 Iteration: 1200 / 2000 [ 60%]  (Sampling)  #> Chain 1 Iteration: 1300 / 2000 [ 65%]  (Sampling)  #> Chain 1 Iteration: 1400 / 2000 [ 70%]  (Sampling)  #> Chain 1 Iteration: 1500 / 2000 [ 75%]  (Sampling)  #> Chain 1 Iteration: 1600 / 2000 [ 80%]  (Sampling)  #> Chain 1 Iteration: 1700 / 2000 [ 85%]  (Sampling)  #> Chain 1 Iteration: 1800 / 2000 [ 90%]  (Sampling)  #> Chain 1 Iteration: 1900 / 2000 [ 95%]  (Sampling)  #> Chain 1 Iteration: 2000 / 2000 [100%]  (Sampling)  #> Chain 2 Iteration:    1 / 2000 [  0%]  (Warmup)  #> Chain 2 Iteration:  100 / 2000 [  5%]  (Warmup)  #> Chain 2 Iteration:  200 / 2000 [ 10%]  (Warmup)  #> Chain 2 Iteration:  300 / 2000 [ 15%]  (Warmup)  #> Chain 2 Iteration:  400 / 2000 [ 20%]  (Warmup)  #> Chain 2 Iteration:  500 / 2000 [ 25%]  (Warmup)  #> Chain 2 Iteration:  600 / 2000 [ 30%]  (Warmup)  #> Chain 2 Iteration:  700 / 2000 [ 35%]  (Warmup)  #> Chain 2 Iteration:  800 / 2000 [ 40%]  (Warmup)  #> Chain 2 Iteration:  900 / 2000 [ 45%]  (Warmup)  #> Chain 2 Iteration: 1000 / 2000 [ 50%]  (Warmup)  #> Chain 2 Iteration: 1001 / 2000 [ 50%]  (Sampling)  #> Chain 2 Iteration: 1100 / 2000 [ 55%]  (Sampling)  #> Chain 2 Iteration: 1200 / 2000 [ 60%]  (Sampling)  #> Chain 2 Iteration: 1300 / 2000 [ 65%]  (Sampling)  #> Chain 2 Iteration: 1400 / 2000 [ 70%]  (Sampling)  #> Chain 2 Iteration: 1500 / 2000 [ 75%]  (Sampling)  #> Chain 2 Iteration: 1600 / 2000 [ 80%]  (Sampling)  #> Chain 2 Iteration: 1700 / 2000 [ 85%]  (Sampling)  #> Chain 2 Iteration: 1800 / 2000 [ 90%]  (Sampling)  #> Chain 2 Iteration: 1900 / 2000 [ 95%]  (Sampling)  #> Chain 2 Iteration: 2000 / 2000 [100%]  (Sampling)  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.1 seconds. #>   # Use 'posterior' package for summaries fit_mcmc$summary() #> # A tibble: 2 × 10 #>   variable   mean median    sd   mad      q5    q95  rhat ess_bulk ess_tail #>   <chr>     <dbl>  <dbl> <dbl> <dbl>   <dbl>  <dbl> <dbl>    <dbl>    <dbl> #> 1 lp__     -7.32  -7.02  0.799 0.355 -8.89   -6.75   1.00     819.    1020. #> 2 theta     0.255  0.240 0.127 0.130  0.0773  0.491  1.00     557.     616.  # Check sampling diagnostics fit_mcmc$diagnostic_summary() #> $num_divergent #> [1] 0 0 #>  #> $num_max_treedepth #> [1] 0 0 #>  #> $ebfmi #> [1] 1.114870 1.030279 #>   # Get posterior draws draws <- fit_mcmc$draws() print(draws) #> # A draws_array: 1000 iterations, 2 chains, and 2 variables #> , , variable = lp__ #>  #>          chain #> iteration    1    2 #>         1 -7.0 -6.8 #>         2 -7.9 -6.9 #>         3 -7.4 -6.9 #>         4 -6.7 -6.8 #>         5 -6.9 -6.8 #>  #> , , variable = theta #>  #>          chain #> iteration    1    2 #>         1 0.17 0.28 #>         2 0.46 0.19 #>         3 0.41 0.19 #>         4 0.25 0.28 #>         5 0.18 0.23 #>  #> # ... with 995 more iterations  # Convert to data frame using posterior::as_draws_df as_draws_df(draws) #> # A draws_df: 1000 iterations, 2 chains, and 2 variables #>    lp__ theta #> 1  -7.0  0.17 #> 2  -7.9  0.46 #> 3  -7.4  0.41 #> 4  -6.7  0.25 #> 5  -6.9  0.18 #> 6  -6.9  0.33 #> 7  -7.2  0.15 #> 8  -6.8  0.29 #> 9  -6.8  0.24 #> 10 -6.8  0.24 #> # ... with 1990 more draws #> # ... hidden reserved variables {'.chain', '.iteration', '.draw'}  # Plot posterior using bayesplot (ggplot2) mcmc_hist(fit_mcmc$draws(\"theta\")) #> `stat_bin()` using `bins = 30`. Pick better value `binwidth`.   # Run 'optimize' method to get a point estimate (default is Stan's LBFGS algorithm) # and also demonstrate specifying data as a path to a file instead of a list my_data_file <- file.path(cmdstan_path(), \"examples/bernoulli/bernoulli.data.json\") fit_optim <- mod$optimize(data = my_data_file, seed = 123) #> Initial log joint probability = -16.144  #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes   #>        6      -5.00402   0.000246518   8.73164e-07           1           1        9     #> Optimization terminated normally:   #>   Convergence detected: relative gradient magnitude is below tolerance  #> Finished in  0.1 seconds. fit_optim$summary() #> # A tibble: 2 × 2 #>   variable estimate #>   <chr>       <dbl> #> 1 lp__       -5.00  #> 2 theta       0.200  # Run 'optimize' again with 'jacobian=TRUE' and then draw from Laplace approximation # to the posterior fit_optim <- mod$optimize(data = my_data_file, jacobian = TRUE) #> Initial log joint probability = -6.81845  #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes   #>        4      -6.74802   0.000428871   2.37349e-06           1           1        7     #> Optimization terminated normally:   #>   Convergence detected: relative gradient magnitude is below tolerance  #> Finished in  0.1 seconds. fit_laplace <- mod$laplace(data = my_data_file, mode = fit_optim, draws = 2000) #> Calculating Hessian  #> Calculating inverse of Cholesky factor  #> Generating draws  #> iteration: 0  #> iteration: 100  #> iteration: 200  #> iteration: 300  #> iteration: 400  #> iteration: 500  #> iteration: 600  #> iteration: 700  #> iteration: 800  #> iteration: 900  #> iteration: 1000  #> iteration: 1100  #> iteration: 1200  #> iteration: 1300  #> iteration: 1400  #> iteration: 1500  #> iteration: 1600  #> iteration: 1700  #> iteration: 1800  #> iteration: 1900  #> Finished in  0.1 seconds. fit_laplace$summary() #> # A tibble: 3 × 7 #>   variable      mean median    sd   mad     q5      q95 #>   <chr>        <dbl>  <dbl> <dbl> <dbl>  <dbl>    <dbl> #> 1 lp__        -7.24  -6.98  0.696 0.309 -8.55  -6.75    #> 2 lp_approx__ -0.501 -0.230 0.697 0.313 -1.92  -0.00252 #> 3 theta        0.268  0.251 0.123 0.123  0.100  0.490    # Run 'variational' method to use ADVI to approximate posterior fit_vb <- mod$variational(data = stan_data, seed = 123) #> ------------------------------------------------------------  #> EXPERIMENTAL ALGORITHM:  #>   This procedure has not been thoroughly tested and may be unstable  #>   or buggy. The interface is subject to change.  #> ------------------------------------------------------------  #> Gradient evaluation took 2e-06 seconds  #> 1000 transitions using 10 leapfrog steps per transition would take 0.02 seconds.  #> Adjust your expectations accordingly!  #> Begin eta adaptation.  #> Iteration:   1 / 250 [  0%]  (Adaptation)  #> Iteration:  50 / 250 [ 20%]  (Adaptation)  #> Iteration: 100 / 250 [ 40%]  (Adaptation)  #> Iteration: 150 / 250 [ 60%]  (Adaptation)  #> Iteration: 200 / 250 [ 80%]  (Adaptation)  #> Success! Found best value [eta = 1] earlier than expected.  #> Begin stochastic gradient ascent.  #>   iter             ELBO   delta_ELBO_mean   delta_ELBO_med   notes   #>    100           -6.164             1.000            1.000  #>    200           -6.225             0.505            1.000  #>    300           -6.186             0.339            0.010   MEDIAN ELBO CONVERGED  #> Drawing a sample of size 1000 from the approximate posterior...   #> COMPLETED.  #> Finished in  0.1 seconds. fit_vb$summary() #> # A tibble: 3 × 7 #>   variable      mean median    sd   mad     q5      q95 #>   <chr>        <dbl>  <dbl> <dbl> <dbl>  <dbl>    <dbl> #> 1 lp__        -7.14  -6.93  0.528 0.247 -8.21  -6.75    #> 2 lp_approx__ -0.520 -0.244 0.740 0.326 -1.90  -0.00227 #> 3 theta        0.251  0.236 0.107 0.108  0.100  0.446   mcmc_hist(fit_vb$draws(\"theta\")) #> `stat_bin()` using `bins = 30`. Pick better value `binwidth`.   # Run 'pathfinder' method, a new alternative to the variational method fit_pf <- mod$pathfinder(data = stan_data, seed = 123) #> Path [1] :Initial log joint density = -18.273334  #> Path [1] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      7.082e-04   1.432e-05    1.000e+00  1.000e+00       156 -6.216e+00 -6.145e+00                    #> Path [1] :Best Iter: [5] ELBO (-6.145070) evaluations: (156)  #> Path [2] :Initial log joint density = -19.192715  #> Path [2] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.015e-04   2.228e-06    1.000e+00  1.000e+00       156 -6.170e+00 -6.223e+00                    #> Path [2] :Best Iter: [2] ELBO (-6.170358) evaluations: (156)  #> Path [3] :Initial log joint density = -6.774820  #> Path [3] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               4      -6.748e+00      1.137e-04   2.596e-07    1.000e+00  1.000e+00       123 -6.243e+00 -6.178e+00                    #> Path [3] :Best Iter: [4] ELBO (-6.177909) evaluations: (123)  #> Path [4] :Initial log joint density = -7.949193  #> Path [4] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.145e-04   1.301e-06    1.000e+00  1.000e+00       156 -6.235e+00 -6.197e+00                    #> Path [4] :Best Iter: [5] ELBO (-6.197118) evaluations: (156)  #> Finished in  0.1 seconds. fit_pf$summary() #> # A tibble: 4 × 7 #>   variable      mean median    sd   mad      q5    q95 #>   <chr>        <dbl>  <dbl> <dbl> <dbl>   <dbl>  <dbl> #> 1 lp_approx__ -1.07  -0.724 0.871 0.306 -2.82   -0.451 #> 2 path__       2.46   2     1.12  1.48   1       4     #> 3 lp__        -7.26  -6.97  0.720 0.304 -8.77   -6.75  #> 4 theta        0.258  0.241 0.121 0.119  0.0840  0.475 mcmc_hist(fit_pf$draws(\"theta\")) #> `stat_bin()` using `bins = 30`. Pick better value `binwidth`.   # Run 'pathfinder' again with more paths, fewer draws per path, # better covariance approximation, and fewer LBFGSs iterations fit_pf <- mod$pathfinder(data = stan_data, num_paths=10, single_path_draws=40,                          history_size=50, max_lbfgs_iters=100) #> Warning: Number of PSIS draws is larger than the total number of draws returned by the single Pathfinders. This is likely unintentional and leads to re-sampling from the same draws.  #> Path [1] :Initial log joint density = -7.215147  #> Path [1] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               4      -6.748e+00      4.391e-03   1.143e-04    1.000e+00  1.000e+00       123 -6.249e+00 -6.325e+00                    #> Path [1] :Best Iter: [2] ELBO (-6.248547) evaluations: (123)  #> Path [2] :Initial log joint density = -10.596881  #> Path [2] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      8.206e-04   1.129e-05    1.000e+00  1.000e+00       156 -6.169e+00 -6.206e+00                    #> Path [2] :Best Iter: [4] ELBO (-6.168693) evaluations: (156)  #> Path [3] :Initial log joint density = -11.609318  #> Path [3] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      1.085e-03   1.743e-05    1.000e+00  1.000e+00       156 -6.159e+00 -6.158e+00                    #> Path [3] :Best Iter: [5] ELBO (-6.158401) evaluations: (156)  #> Path [4] :Initial log joint density = -19.503153  #> Path [4] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      8.354e-05   5.988e-07    1.000e+00  1.000e+00       156 -6.225e+00 -6.231e+00                    #> Path [4] :Best Iter: [2] ELBO (-6.225034) evaluations: (156)  #> Path [5] :Initial log joint density = -8.222121  #> Path [5] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.676e-04   1.872e-06    1.000e+00  1.000e+00       156 -6.210e+00 -6.218e+00                    #> Path [5] :Best Iter: [4] ELBO (-6.209606) evaluations: (156)  #> Path [6] :Initial log joint density = -6.987056  #> Path [6] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               4      -6.748e+00      4.486e-04   1.025e-04    9.113e-01  9.113e-01       123 -6.198e+00 -6.215e+00                    #> Path [6] :Best Iter: [3] ELBO (-6.198284) evaluations: (123)  #> Path [7] :Initial log joint density = -8.127620  #> Path [7] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.505e-04   1.677e-06    1.000e+00  1.000e+00       156 -6.209e+00 -6.234e+00                    #> Path [7] :Best Iter: [4] ELBO (-6.209087) evaluations: (156)  #> Path [8] :Initial log joint density = -11.445455  #> Path [8] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      1.048e-03   1.653e-05    1.000e+00  1.000e+00       156 -6.218e+00 -6.283e+00                    #> Path [8] :Best Iter: [3] ELBO (-6.217963) evaluations: (156)  #> Path [9] :Initial log joint density = -9.279249  #> Path [9] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      4.027e-04   3.720e-06    1.000e+00  1.000e+00       156 -6.235e+00 -6.252e+00                    #> Path [9] :Best Iter: [4] ELBO (-6.235449) evaluations: (156)  #> Path [10] :Initial log joint density = -6.912355  #> Path [10] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               4      -6.748e+00      1.291e-03   1.490e-05    1.000e+00  1.000e+00       123 -6.210e+00 -6.234e+00                    #> Path [10] :Best Iter: [3] ELBO (-6.210428) evaluations: (123)  #> Pareto k value (0.71) is greater than 0.7. Importance resampling was not able to improve the approximation, which may indicate that the approximation itself is poor.  #> Finished in  0.1 seconds.  # Specifying initial values as a function fit_mcmc_w_init_fun <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   refresh = 0,   init = function() list(theta = runif(1)) ) #> Running MCMC with 2 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.2 seconds. #>  fit_mcmc_w_init_fun_2 <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   refresh = 0,   init = function(chain_id) {     # silly but demonstrates optional use of chain_id     list(theta = 1 / (chain_id + 1))   } ) #> Running MCMC with 2 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.2 seconds. #>  fit_mcmc_w_init_fun_2$init() #> [[1]] #> [[1]]$theta #> [1] 0.5 #>  #>  #> [[2]] #> [[2]]$theta #> [1] 0.3333333 #>  #>   # Specifying initial values as a list of lists fit_mcmc_w_init_list <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   refresh = 0,   init = list(     list(theta = 0.75), # chain 1     list(theta = 0.25)  # chain 2   ) ) #> Running MCMC with 2 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.2 seconds. #>  fit_optim_w_init_list <- mod$optimize(   data = stan_data,   seed = 123,   init = list(     list(theta = 0.75)   ) ) #> Initial log joint probability = -11.6657  #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes   #>        6      -5.00402   0.000237915   9.55309e-07           1           1        9     #> Optimization terminated normally:   #>   Convergence detected: relative gradient magnitude is below tolerance  #> Finished in  0.1 seconds. fit_optim_w_init_list$init() #> [[1]] #> [[1]]$theta #> [1] 0.75 #>  #>  # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-sample_mpi.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Stan's MCMC algorithms with MPI — model-method-sample_mpi","title":"Run Stan's MCMC algorithms with MPI — model-method-sample_mpi","text":"$sample_mpi() method CmdStanModel object identical $sample() method support MPI (message passing interface). target audience MPI large computer clusters. users, $sample() method provides parallelization chains threading support within-chain parallelization. order use MPI Stan, MPI implementation must installed. Unix systems commonly used implementations MPICH OpenMPI. implementations provide MPI C++ compiler wrapper (example mpicxx), required compile model. example compiling MPI:   C++ options must supplied compile call : STAN_MPI: Enables use MPI Stan TRUE. CXX: name MPI C++ compiler wrapper. Typically \"mpicxx\". TBB_CXX_TYPE: C++ compiler MPI wrapper wraps. Typically \"gcc\" Linux \"clang\" macOS. call $sample_mpi() method also possible provide name MPI launcher (mpi_cmd, defaulting \"mpiexec\") MPI launch arguments (mpi_args). cases, enough define number processes. use n_procs processes specify mpi_args = list(\"n\" = n_procs).","code":"mpi_options = list(STAN_MPI=TRUE, CXX=\"mpicxx\", TBB_CXX_TYPE=\"gcc\") mod = cmdstan_model(\"model.stan\", cpp_options = mpi_options)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-sample_mpi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Stan's MCMC algorithms with MPI — model-method-sample_mpi","text":"","code":"sample_mpi(   data = NULL,   mpi_cmd = \"mpiexec\",   mpi_args = NULL,   seed = NULL,   refresh = NULL,   init = NULL,   save_latent_dynamics = FALSE,   output_dir = getOption(\"cmdstanr_output_dir\"),   output_basename = NULL,   chains = 1,   chain_ids = seq_len(chains),   iter_warmup = NULL,   iter_sampling = NULL,   save_warmup = FALSE,   thin = NULL,   max_treedepth = NULL,   adapt_engaged = TRUE,   adapt_delta = NULL,   step_size = NULL,   metric = NULL,   metric_file = NULL,   inv_metric = NULL,   init_buffer = NULL,   term_buffer = NULL,   window = NULL,   fixed_param = FALSE,   sig_figs = NULL,   show_messages = TRUE,   show_exceptions = TRUE,   diagnostics = c(\"divergences\", \"treedepth\", \"ebfmi\"),   save_cmdstan_config = NULL,   validate_csv = TRUE )"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-sample_mpi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Stan's MCMC algorithms with MPI — model-method-sample_mpi","text":"data (multiple options) data use variables specified data block Stan program. One following: named list R objects names corresponding variables declared data block Stan program. Internally list written JSON CmdStan using write_stan_json(). See write_stan_json() details conversions performed R objects passed Stan. path data file compatible CmdStan (JSON R dump). See appendices CmdStan guide details using formats. NULL empty list Stan program data block. mpi_cmd (string) MPI launcher used launching MPI processes. default launcher \"mpiexec\". mpi_args (list) list arguments use launching MPI processes. example, mpi_args = list(\"n\" = 4) launches executable mpiexec -n 4 model_executable, followed CmdStan arguments model executable. seed (positive integer(s)) seed (P)RNG pass CmdStan. case multi-chain sampling single seed automatically augmented run (chain) ID chain uses different seed. exception transformed data block, defaults using seed chains data generated chains RNG functions used. time seed specified vector (one element per chain) RNG functions used transformed data goal generate different data chain. refresh (non-negative integer) number iterations printed screen updates. refresh = 0, error messages printed. init (multiple options) initialization method use variables declared parameters block Stan program. One following: real number x>0. initializes parameters randomly [-x,x] unconstrained parameter space.; number 0. initializes parameters 0; character vector paths (one per chain) JSON Rdump files containing initial values parameters. See write_stan_json() write R objects JSON files compatible CmdStan. list lists containing initial values parameters. MCMC list contain sublist chain. model fitting methods just one sublist. sublists named elements corresponding parameters specifying initial values. See Examples. function returns single list names corresponding parameters specifying initial values. function can take arguments single argument chain_id. MCMC, function argument chain_id supplied chain id (1 number chains) called generate initial values. See Examples. CmdStanMCMC, CmdStanMLE, CmdStanVB, CmdStanPathfinder, CmdStanLaplace fit object. fit object's parameters subset model parameters parameters drawn Stan's default initialization. fit object must least parameters name dimensions current Stan model. sample pathfinder method, fit object fewer draws requested number chains/paths inits drawn using sampling replacement. Otherwise sampling without replacement used. CmdStanPathfinder fit object used init, . psis_resample set FALSE calculate_lp set TRUE (default), resampling without replacement Pareto smoothed weights used. psis_resample set TRUE calculate_lp set FALSE sampling without replacement uniform weights used select draws. PSIS resampling used select draws  CmdStanVB, CmdStanLaplace fit objects. type inheriting posterior::draws. draws object less samples number requested chains/paths inits drawn using sampling replacement. Otherwise sampling without replacement used. draws object's parameters subset model parameters parameters drawn Stan's default initialization. fit object must least parameters name dimensions current Stan model. save_latent_dynamics (logical) auxiliary diagnostic information latent dynamics written temporary diagnostic CSV files? argument replaces CmdStan's diagnostic_file argument content written CSV controlled user's CmdStan installation CmdStanR (algorithms content may written). default FALSE, appropriate almost every use case. save temporary files created save_latent_dynamics=TRUE see $save_latent_dynamics_files() method. output_dir (string) path directory CmdStan write output CSV files. MCMC one file per chain; methods single file. interactive use can typically left NULL (temporary directory) since CmdStanR makes CmdStan output (posterior draws diagnostics) available R via methods fitted model objects. can set entire R session using options(cmdstanr_output_dir). behavior output_dir follows: NULL (default), CSV files written temporary directory saved permanently user calls one $save_* methods fitted model object (e.g., $save_output_files()). temporary files removed fitted model object garbage collected (manually automatically). path, files created output_dir names corresponding defaults used $save_output_files(). output_basename (string) string use prefix names output CSV files CmdStan. NULL (default), basename output CSV files comprised model name, timestamp, 5 random characters. chains (positive integer) number Markov chains run. default 4. chain_ids (integer vector) vector chain IDs. Must contain many unique positive integers number chains. set, default chain IDs used (integers starting 1). iter_warmup (positive integer) number warmup iterations run per chain. Note: CmdStan User's Guide referred num_warmup. iter_sampling (positive integer) number post-warmup iterations run per chain. Note: CmdStan User's Guide referred num_samples. save_warmup (logical) warmup iterations saved? default FALSE. thin (positive integer) period saved samples. typically left default (thinning) unless memory problem. max_treedepth (positive integer) maximum allowed tree depth NUTS engine. See Tree Depth section CmdStan User's Guide details. adapt_engaged (logical) warmup adaptation? default TRUE. precomputed inverse metric specified via inv_metric argument (metric_file) , adapt_engaged=TRUE, Stan use provided inverse metric just initial guess adaptation. turn adaptation using precomputed inverse metric set adapt_engaged=FALSE. adapt_delta (real (0,1)) adaptation target acceptance statistic. step_size (positive real) initial step size discrete approximation continuous Hamiltonian dynamics. tuned warmup. metric (string) One \"diag_e\", \"dense_e\", \"unit_e\", specifying geometry base manifold. See Euclidean Metric section CmdStan User's Guide details. specify precomputed (inverse) metric, see inv_metric argument . metric_file (character vector) paths JSON Rdump files (one per chain) compatible CmdStan contain precomputed inverse metrics. metric_file argument inherited CmdStan confusing entry JSON Rdump file(s) must named inv_metric, referring inverse metric. recommend instead using CmdStanR's inv_metric argument (see ) specify inverse metric directly using vector matrix R session. inv_metric (vector, matrix) vector (metric='diag_e') matrix (metric='dense_e') initializing inverse metric. can used alternative metric_file argument. vector interpreted diagonal metric. inverse metric usually set estimate posterior covariance. See adapt_engaged argument details (control ) specifying precomputed inverse metric interacts adaptation. init_buffer (nonnegative integer) Width initial fast timestep adaptation interval warmup. term_buffer (nonnegative integer) Width final fast timestep adaptation interval warmup. window (nonnegative integer) Initial width slow timestep/metric adaptation interval. fixed_param (logical) TRUE, call CmdStan argument \"algorithm=fixed_param\". default FALSE. fixed parameter sampler generates new sample without changing current state Markov chain; generated quantities may change. can useful , example, trying generate pseudo-data using generated quantities block. parameters block empty using fixed_param=TRUE mandatory. fixed_param=TRUE chains parallel_chains arguments set 1. sig_figs (positive integer) number significant figures used storing output values. default, CmdStan represent output values 6 significant figures. upper limit sig_figs 18. Increasing value result larger output CSV files thus increased usage disk space. show_messages (logical) TRUE (default), prints output execution process, iteration numbers elapsed times. output silenced $output() method resulting fit object can used display silenced messages. show_exceptions (logical) TRUE (default), prints informational messages, example rejection current proposal. Disable wish silence messages, usually recommended unless confident model correct numerical error. messages silenced $output() method resulting fit object can used display silenced messages. diagnostics (character vector) diagnostics automatically check warn sampling. Setting empty string \"\" NULL can used prevent CmdStanR automatically reading sampler diagnostics CSV wish manually read results validate , example using read_cmdstan_csv(). currently available diagnostics \"divergences\", \"treedepth\", \"ebfmi\" (default check ). diagnostics also available fitting. $sampler_diagnostics() method provides access diagnostic values iteration $diagnostic_summary() method provides summaries diagnostics can regenerate warning messages. Diagnostics like R-hat effective sample size currently available via diagnostics argument can checked fitting using $summary() method. save_cmdstan_config (logical) TRUE (default), call CmdStan argument \"output save_config=1\" save json file contains argument tree extra information (equivalent output CSV file header). option available CmdStan 2.34.0 later. validate_csv Deprecated. Use diagnostics instead.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-sample_mpi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run Stan's MCMC algorithms with MPI — model-method-sample_mpi","text":"CmdStanMCMC object.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-sample_mpi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run Stan's MCMC algorithms with MPI — model-method-sample_mpi","text":"","code":"# \\dontrun{ # mpi_options <- list(STAN_MPI=TRUE, CXX=\"mpicxx\", TBB_CXX_TYPE=\"gcc\") # mod <- cmdstan_model(\"model.stan\", cpp_options = mpi_options) # fit <- mod$sample_mpi(..., mpi_args = list(\"n\" = 4)) # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-variables.html","id":null,"dir":"Reference","previous_headings":"","what":"Input and output variables of a Stan program — model-method-variables","title":"Input and output variables of a Stan program — model-method-variables","text":"$variables() method CmdStanModel object returns list, element representing Stan model block: data, parameters, transformed_parameters generated_quantities. element contains list variables, variables represented list infromation scalar type (real int) number dimensions. transformed data included, variables block part model's input output.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-variables.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Input and output variables of a Stan program — model-method-variables","text":"","code":"variables()"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-variables.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Input and output variables of a Stan program — model-method-variables","text":"$variables() returns list information input output variables Stan model blocks.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-variables.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Input and output variables of a Stan program — model-method-variables","text":"","code":"# \\dontrun{ file <- file.path(cmdstan_path(), \"examples/bernoulli/bernoulli.stan\")  # create a `CmdStanModel` object, compiling the model is not required mod <- cmdstan_model(file, compile = FALSE)  mod$variables() #> $parameters #> $parameters$theta #> $parameters$theta$type #> [1] \"real\" #>  #> $parameters$theta$dimensions #> [1] 0 #>  #>  #>  #> $included_files #> list() #>  #> $data #> $data$N #> $data$N$type #> [1] \"int\" #>  #> $data$N$dimensions #> [1] 0 #>  #>  #> $data$y #> $data$y$type #> [1] \"int\" #>  #> $data$y$dimensions #> [1] 1 #>  #>  #>  #> $transformed_parameters #> named list() #>  #> $generated_quantities #> named list() #>   # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-variational.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Stan's variational approximation algorithms — model-method-variational","title":"Run Stan's variational approximation algorithms — model-method-variational","text":"$variational() method CmdStanModel object runs Stan's Automatic Differentiation Variational Inference (ADVI) algorithms. approximation Gaussian unconstrained variable space. Stan implements two ADVI algorithms: algorithm=\"meanfield\" option uses fully factorized Gaussian approximation; algorithm=\"fullrank\" option uses Gaussian full-rank covariance matrix approximation. See CmdStan User’s Guide details. argument left NULL default default value used installed version CmdStan.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-variational.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Stan's variational approximation algorithms — model-method-variational","text":"","code":"variational(   data = NULL,   seed = NULL,   refresh = NULL,   init = NULL,   save_latent_dynamics = FALSE,   output_dir = getOption(\"cmdstanr_output_dir\"),   output_basename = NULL,   sig_figs = NULL,   threads = NULL,   opencl_ids = NULL,   algorithm = NULL,   iter = NULL,   grad_samples = NULL,   elbo_samples = NULL,   eta = NULL,   adapt_engaged = NULL,   adapt_iter = NULL,   tol_rel_obj = NULL,   eval_elbo = NULL,   output_samples = NULL,   draws = NULL,   show_messages = TRUE,   show_exceptions = TRUE,   save_cmdstan_config = NULL )"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-variational.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Stan's variational approximation algorithms — model-method-variational","text":"data (multiple options) data use variables specified data block Stan program. One following: named list R objects names corresponding variables declared data block Stan program. Internally list written JSON CmdStan using write_stan_json(). See write_stan_json() details conversions performed R objects passed Stan. path data file compatible CmdStan (JSON R dump). See appendices CmdStan guide details using formats. NULL empty list Stan program data block. seed (positive integer(s)) seed (P)RNG pass CmdStan. case multi-chain sampling single seed automatically augmented run (chain) ID chain uses different seed. exception transformed data block, defaults using seed chains data generated chains RNG functions used. time seed specified vector (one element per chain) RNG functions used transformed data goal generate different data chain. refresh (non-negative integer) number iterations printed screen updates. refresh = 0, error messages printed. init (multiple options) initialization method use variables declared parameters block Stan program. One following: real number x>0. initializes parameters randomly [-x,x] unconstrained parameter space.; number 0. initializes parameters 0; character vector paths (one per chain) JSON Rdump files containing initial values parameters. See write_stan_json() write R objects JSON files compatible CmdStan. list lists containing initial values parameters. MCMC list contain sublist chain. model fitting methods just one sublist. sublists named elements corresponding parameters specifying initial values. See Examples. function returns single list names corresponding parameters specifying initial values. function can take arguments single argument chain_id. MCMC, function argument chain_id supplied chain id (1 number chains) called generate initial values. See Examples. CmdStanMCMC, CmdStanMLE, CmdStanVB, CmdStanPathfinder, CmdStanLaplace fit object. fit object's parameters subset model parameters parameters drawn Stan's default initialization. fit object must least parameters name dimensions current Stan model. sample pathfinder method, fit object fewer draws requested number chains/paths inits drawn using sampling replacement. Otherwise sampling without replacement used. CmdStanPathfinder fit object used init, . psis_resample set FALSE calculate_lp set TRUE (default), resampling without replacement Pareto smoothed weights used. psis_resample set TRUE calculate_lp set FALSE sampling without replacement uniform weights used select draws. PSIS resampling used select draws  CmdStanVB, CmdStanLaplace fit objects. type inheriting posterior::draws. draws object less samples number requested chains/paths inits drawn using sampling replacement. Otherwise sampling without replacement used. draws object's parameters subset model parameters parameters drawn Stan's default initialization. fit object must least parameters name dimensions current Stan model. save_latent_dynamics (logical) auxiliary diagnostic information latent dynamics written temporary diagnostic CSV files? argument replaces CmdStan's diagnostic_file argument content written CSV controlled user's CmdStan installation CmdStanR (algorithms content may written). default FALSE, appropriate almost every use case. save temporary files created save_latent_dynamics=TRUE see $save_latent_dynamics_files() method. output_dir (string) path directory CmdStan write output CSV files. MCMC one file per chain; methods single file. interactive use can typically left NULL (temporary directory) since CmdStanR makes CmdStan output (posterior draws diagnostics) available R via methods fitted model objects. can set entire R session using options(cmdstanr_output_dir). behavior output_dir follows: NULL (default), CSV files written temporary directory saved permanently user calls one $save_* methods fitted model object (e.g., $save_output_files()). temporary files removed fitted model object garbage collected (manually automatically). path, files created output_dir names corresponding defaults used $save_output_files(). output_basename (string) string use prefix names output CSV files CmdStan. NULL (default), basename output CSV files comprised model name, timestamp, 5 random characters. sig_figs (positive integer) number significant figures used storing output values. default, CmdStan represent output values 6 significant figures. upper limit sig_figs 18. Increasing value result larger output CSV files thus increased usage disk space. threads (positive integer) model compiled threading support, number threads use parallelized sections (e.g., using Stan functions reduce_sum() map_rect()). opencl_ids (integer vector length 2) platform device IDs OpenCL device use fitting. model must compiled cpp_options = list(stan_opencl = TRUE) argument effect. algorithm (string) algorithm. Either \"meanfield\" \"fullrank\". iter (positive integer) maximum number iterations. grad_samples (positive integer) number samples Monte Carlo estimate gradients. elbo_samples (positive integer) number samples Monte Carlo estimate ELBO (objective function). eta (positive real) step size weighting parameter adaptive step size sequence. adapt_engaged (logical) warmup adaptation? adapt_iter (positive integer) maximum number adaptation iterations. tol_rel_obj (positive real) Convergence tolerance relative norm objective. eval_elbo (positive integer) Evaluate ELBO every Nth iteration. output_samples (positive integer) Use draws argument instead. output_samples deprecated future. draws (positive integer) Number approximate posterior samples draw save. show_messages (logical) TRUE (default), prints output execution process, iteration numbers elapsed times. output silenced $output() method resulting fit object can used display silenced messages. show_exceptions (logical) TRUE (default), prints informational messages, example rejection current proposal. Disable wish silence messages, usually recommended unless confident model correct numerical error. messages silenced $output() method resulting fit object can used display silenced messages. save_cmdstan_config (logical) TRUE (default), call CmdStan argument \"output save_config=1\" save json file contains argument tree extra information (equivalent output CSV file header). option available CmdStan 2.34.0 later.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-variational.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run Stan's variational approximation algorithms — model-method-variational","text":"CmdStanVB object.","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/reference/model-method-variational.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run Stan's variational approximation algorithms — model-method-variational","text":"","code":"# \\dontrun{ library(cmdstanr) library(posterior) library(bayesplot) color_scheme_set(\"brightblue\")  # Set path to CmdStan # (Note: if you installed CmdStan via install_cmdstan() with default settings # then setting the path is unnecessary but the default below should still work. # Otherwise use the `path` argument to specify the location of your # CmdStan installation.) set_cmdstan_path(path = NULL) #> CmdStan path set to: /home/runner/.cmdstan/cmdstan-2.37.0  # Create a CmdStanModel object from a Stan program, # here using the example model that comes with CmdStan file <- file.path(cmdstan_path(), \"examples/bernoulli/bernoulli.stan\") mod <- cmdstan_model(file) mod$print() #> data { #>   int<lower=0> N; #>   array[N] int<lower=0, upper=1> y; #> } #> parameters { #>   real<lower=0, upper=1> theta; #> } #> model { #>   theta ~ beta(1, 1); // uniform prior on interval 0,1 #>   y ~ bernoulli(theta); #> } # Print with line numbers. This can be set globally using the # `cmdstanr_print_line_numbers` option. mod$print(line_numbers = TRUE) #>  1: data { #>  2:   int<lower=0> N; #>  3:   array[N] int<lower=0, upper=1> y; #>  4: } #>  5: parameters { #>  6:   real<lower=0, upper=1> theta; #>  7: } #>  8: model { #>  9:   theta ~ beta(1, 1); // uniform prior on interval 0,1 #> 10:   y ~ bernoulli(theta); #> 11: }  # Data as a named list (like RStan) stan_data <- list(N = 10, y = c(0,1,0,0,0,0,0,0,0,1))  # Run MCMC using the 'sample' method fit_mcmc <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   parallel_chains = 2 ) #> Running MCMC with 2 parallel chains... #>  #> Chain 1 Iteration:    1 / 2000 [  0%]  (Warmup)  #> Chain 1 Iteration:  100 / 2000 [  5%]  (Warmup)  #> Chain 1 Iteration:  200 / 2000 [ 10%]  (Warmup)  #> Chain 1 Iteration:  300 / 2000 [ 15%]  (Warmup)  #> Chain 1 Iteration:  400 / 2000 [ 20%]  (Warmup)  #> Chain 1 Iteration:  500 / 2000 [ 25%]  (Warmup)  #> Chain 1 Iteration:  600 / 2000 [ 30%]  (Warmup)  #> Chain 1 Iteration:  700 / 2000 [ 35%]  (Warmup)  #> Chain 1 Iteration:  800 / 2000 [ 40%]  (Warmup)  #> Chain 1 Iteration:  900 / 2000 [ 45%]  (Warmup)  #> Chain 1 Iteration: 1000 / 2000 [ 50%]  (Warmup)  #> Chain 1 Iteration: 1001 / 2000 [ 50%]  (Sampling)  #> Chain 1 Iteration: 1100 / 2000 [ 55%]  (Sampling)  #> Chain 1 Iteration: 1200 / 2000 [ 60%]  (Sampling)  #> Chain 1 Iteration: 1300 / 2000 [ 65%]  (Sampling)  #> Chain 1 Iteration: 1400 / 2000 [ 70%]  (Sampling)  #> Chain 1 Iteration: 1500 / 2000 [ 75%]  (Sampling)  #> Chain 1 Iteration: 1600 / 2000 [ 80%]  (Sampling)  #> Chain 1 Iteration: 1700 / 2000 [ 85%]  (Sampling)  #> Chain 1 Iteration: 1800 / 2000 [ 90%]  (Sampling)  #> Chain 1 Iteration: 1900 / 2000 [ 95%]  (Sampling)  #> Chain 1 Iteration: 2000 / 2000 [100%]  (Sampling)  #> Chain 2 Iteration:    1 / 2000 [  0%]  (Warmup)  #> Chain 2 Iteration:  100 / 2000 [  5%]  (Warmup)  #> Chain 2 Iteration:  200 / 2000 [ 10%]  (Warmup)  #> Chain 2 Iteration:  300 / 2000 [ 15%]  (Warmup)  #> Chain 2 Iteration:  400 / 2000 [ 20%]  (Warmup)  #> Chain 2 Iteration:  500 / 2000 [ 25%]  (Warmup)  #> Chain 2 Iteration:  600 / 2000 [ 30%]  (Warmup)  #> Chain 2 Iteration:  700 / 2000 [ 35%]  (Warmup)  #> Chain 2 Iteration:  800 / 2000 [ 40%]  (Warmup)  #> Chain 2 Iteration:  900 / 2000 [ 45%]  (Warmup)  #> Chain 2 Iteration: 1000 / 2000 [ 50%]  (Warmup)  #> Chain 2 Iteration: 1001 / 2000 [ 50%]  (Sampling)  #> Chain 2 Iteration: 1100 / 2000 [ 55%]  (Sampling)  #> Chain 2 Iteration: 1200 / 2000 [ 60%]  (Sampling)  #> Chain 2 Iteration: 1300 / 2000 [ 65%]  (Sampling)  #> Chain 2 Iteration: 1400 / 2000 [ 70%]  (Sampling)  #> Chain 2 Iteration: 1500 / 2000 [ 75%]  (Sampling)  #> Chain 2 Iteration: 1600 / 2000 [ 80%]  (Sampling)  #> Chain 2 Iteration: 1700 / 2000 [ 85%]  (Sampling)  #> Chain 2 Iteration: 1800 / 2000 [ 90%]  (Sampling)  #> Chain 2 Iteration: 1900 / 2000 [ 95%]  (Sampling)  #> Chain 2 Iteration: 2000 / 2000 [100%]  (Sampling)  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.1 seconds. #>   # Use 'posterior' package for summaries fit_mcmc$summary() #> # A tibble: 2 × 10 #>   variable   mean median    sd   mad      q5    q95  rhat ess_bulk ess_tail #>   <chr>     <dbl>  <dbl> <dbl> <dbl>   <dbl>  <dbl> <dbl>    <dbl>    <dbl> #> 1 lp__     -7.32  -7.02  0.799 0.355 -8.89   -6.75   1.00     819.    1020. #> 2 theta     0.255  0.240 0.127 0.130  0.0773  0.491  1.00     557.     616.  # Check sampling diagnostics fit_mcmc$diagnostic_summary() #> $num_divergent #> [1] 0 0 #>  #> $num_max_treedepth #> [1] 0 0 #>  #> $ebfmi #> [1] 1.114870 1.030279 #>   # Get posterior draws draws <- fit_mcmc$draws() print(draws) #> # A draws_array: 1000 iterations, 2 chains, and 2 variables #> , , variable = lp__ #>  #>          chain #> iteration    1    2 #>         1 -7.0 -6.8 #>         2 -7.9 -6.9 #>         3 -7.4 -6.9 #>         4 -6.7 -6.8 #>         5 -6.9 -6.8 #>  #> , , variable = theta #>  #>          chain #> iteration    1    2 #>         1 0.17 0.28 #>         2 0.46 0.19 #>         3 0.41 0.19 #>         4 0.25 0.28 #>         5 0.18 0.23 #>  #> # ... with 995 more iterations  # Convert to data frame using posterior::as_draws_df as_draws_df(draws) #> # A draws_df: 1000 iterations, 2 chains, and 2 variables #>    lp__ theta #> 1  -7.0  0.17 #> 2  -7.9  0.46 #> 3  -7.4  0.41 #> 4  -6.7  0.25 #> 5  -6.9  0.18 #> 6  -6.9  0.33 #> 7  -7.2  0.15 #> 8  -6.8  0.29 #> 9  -6.8  0.24 #> 10 -6.8  0.24 #> # ... with 1990 more draws #> # ... hidden reserved variables {'.chain', '.iteration', '.draw'}  # Plot posterior using bayesplot (ggplot2) mcmc_hist(fit_mcmc$draws(\"theta\")) #> `stat_bin()` using `bins = 30`. Pick better value `binwidth`.   # Run 'optimize' method to get a point estimate (default is Stan's LBFGS algorithm) # and also demonstrate specifying data as a path to a file instead of a list my_data_file <- file.path(cmdstan_path(), \"examples/bernoulli/bernoulli.data.json\") fit_optim <- mod$optimize(data = my_data_file, seed = 123) #> Initial log joint probability = -16.144  #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes   #>        6      -5.00402   0.000246518   8.73164e-07           1           1        9     #> Optimization terminated normally:   #>   Convergence detected: relative gradient magnitude is below tolerance  #> Finished in  0.1 seconds. fit_optim$summary() #> # A tibble: 2 × 2 #>   variable estimate #>   <chr>       <dbl> #> 1 lp__       -5.00  #> 2 theta       0.200  # Run 'optimize' again with 'jacobian=TRUE' and then draw from Laplace approximation # to the posterior fit_optim <- mod$optimize(data = my_data_file, jacobian = TRUE) #> Initial log joint probability = -10.4384  #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes   #>        5      -6.74802   0.000772428   1.02784e-05           1           1        8     #> Optimization terminated normally:   #>   Convergence detected: relative gradient magnitude is below tolerance  #> Finished in  0.1 seconds. fit_laplace <- mod$laplace(data = my_data_file, mode = fit_optim, draws = 2000) #> Calculating Hessian  #> Calculating inverse of Cholesky factor  #> Generating draws  #> iteration: 0  #> iteration: 100  #> iteration: 200  #> iteration: 300  #> iteration: 400  #> iteration: 500  #> iteration: 600  #> iteration: 700  #> iteration: 800  #> iteration: 900  #> iteration: 1000  #> iteration: 1100  #> iteration: 1200  #> iteration: 1300  #> iteration: 1400  #> iteration: 1500  #> iteration: 1600  #> iteration: 1700  #> iteration: 1800  #> iteration: 1900  #> Finished in  0.1 seconds. fit_laplace$summary() #> # A tibble: 3 × 7 #>   variable      mean median    sd   mad     q5      q95 #>   <chr>        <dbl>  <dbl> <dbl> <dbl>  <dbl>    <dbl> #> 1 lp__        -7.26  -6.97  0.788 0.302 -8.72  -6.75    #> 2 lp_approx__ -0.519 -0.221 0.765 0.303 -1.97  -0.00237 #> 3 theta        0.269  0.247 0.127 0.119  0.103  0.510    # Run 'variational' method to use ADVI to approximate posterior fit_vb <- mod$variational(data = stan_data, seed = 123) #> ------------------------------------------------------------  #> EXPERIMENTAL ALGORITHM:  #>   This procedure has not been thoroughly tested and may be unstable  #>   or buggy. The interface is subject to change.  #> ------------------------------------------------------------  #> Gradient evaluation took 2e-06 seconds  #> 1000 transitions using 10 leapfrog steps per transition would take 0.02 seconds.  #> Adjust your expectations accordingly!  #> Begin eta adaptation.  #> Iteration:   1 / 250 [  0%]  (Adaptation)  #> Iteration:  50 / 250 [ 20%]  (Adaptation)  #> Iteration: 100 / 250 [ 40%]  (Adaptation)  #> Iteration: 150 / 250 [ 60%]  (Adaptation)  #> Iteration: 200 / 250 [ 80%]  (Adaptation)  #> Success! Found best value [eta = 1] earlier than expected.  #> Begin stochastic gradient ascent.  #>   iter             ELBO   delta_ELBO_mean   delta_ELBO_med   notes   #>    100           -6.164             1.000            1.000  #>    200           -6.225             0.505            1.000  #>    300           -6.186             0.339            0.010   MEDIAN ELBO CONVERGED  #> Drawing a sample of size 1000 from the approximate posterior...   #> COMPLETED.  #> Finished in  0.1 seconds. fit_vb$summary() #> # A tibble: 3 × 7 #>   variable      mean median    sd   mad     q5      q95 #>   <chr>        <dbl>  <dbl> <dbl> <dbl>  <dbl>    <dbl> #> 1 lp__        -7.14  -6.93  0.528 0.247 -8.21  -6.75    #> 2 lp_approx__ -0.520 -0.244 0.740 0.326 -1.90  -0.00227 #> 3 theta        0.251  0.236 0.107 0.108  0.100  0.446   mcmc_hist(fit_vb$draws(\"theta\")) #> `stat_bin()` using `bins = 30`. Pick better value `binwidth`.   # Run 'pathfinder' method, a new alternative to the variational method fit_pf <- mod$pathfinder(data = stan_data, seed = 123) #> Path [1] :Initial log joint density = -18.273334  #> Path [1] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      7.082e-04   1.432e-05    1.000e+00  1.000e+00       156 -6.216e+00 -6.145e+00                    #> Path [1] :Best Iter: [5] ELBO (-6.145070) evaluations: (156)  #> Path [2] :Initial log joint density = -19.192715  #> Path [2] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.015e-04   2.228e-06    1.000e+00  1.000e+00       156 -6.170e+00 -6.223e+00                    #> Path [2] :Best Iter: [2] ELBO (-6.170358) evaluations: (156)  #> Path [3] :Initial log joint density = -6.774820  #> Path [3] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               4      -6.748e+00      1.137e-04   2.596e-07    1.000e+00  1.000e+00       123 -6.243e+00 -6.178e+00                    #> Path [3] :Best Iter: [4] ELBO (-6.177909) evaluations: (123)  #> Path [4] :Initial log joint density = -7.949193  #> Path [4] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.145e-04   1.301e-06    1.000e+00  1.000e+00       156 -6.235e+00 -6.197e+00                    #> Path [4] :Best Iter: [5] ELBO (-6.197118) evaluations: (156)  #> Finished in  0.1 seconds. fit_pf$summary() #> # A tibble: 4 × 7 #>   variable      mean median    sd   mad      q5    q95 #>   <chr>        <dbl>  <dbl> <dbl> <dbl>   <dbl>  <dbl> #> 1 lp_approx__ -1.07  -0.724 0.871 0.306 -2.82   -0.451 #> 2 path__       2.46   2     1.12  1.48   1       4     #> 3 lp__        -7.26  -6.97  0.720 0.304 -8.77   -6.75  #> 4 theta        0.258  0.241 0.121 0.119  0.0840  0.475 mcmc_hist(fit_pf$draws(\"theta\")) #> `stat_bin()` using `bins = 30`. Pick better value `binwidth`.   # Run 'pathfinder' again with more paths, fewer draws per path, # better covariance approximation, and fewer LBFGSs iterations fit_pf <- mod$pathfinder(data = stan_data, num_paths=10, single_path_draws=40,                          history_size=50, max_lbfgs_iters=100) #> Warning: Number of PSIS draws is larger than the total number of draws returned by the single Pathfinders. This is likely unintentional and leads to re-sampling from the same draws.  #> Path [1] :Initial log joint density = -8.306656  #> Path [1] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.817e-04   2.038e-06    1.000e+00  1.000e+00       156 -6.246e+00 -6.174e+00                    #> Path [1] :Best Iter: [5] ELBO (-6.174474) evaluations: (156)  #> Path [2] :Initial log joint density = -7.442977  #> Path [2] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      7.302e-04   1.699e-06    1.000e+00  1.000e+00       156 -6.173e+00 -6.218e+00                    #> Path [2] :Best Iter: [4] ELBO (-6.172840) evaluations: (156)  #> Path [3] :Initial log joint density = -10.490095  #> Path [3] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      7.883e-04   1.061e-05    1.000e+00  1.000e+00       156 -6.215e+00 -6.250e+00                    #> Path [3] :Best Iter: [3] ELBO (-6.215384) evaluations: (156)  #> Path [4] :Initial log joint density = -6.764145  #> Path [4] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               3      -6.748e+00      2.458e-03   1.248e-04    1.000e+00  1.000e+00        91 -6.244e+00 -6.233e+00                    #> Path [4] :Best Iter: [3] ELBO (-6.232893) evaluations: (91)  #> Path [5] :Initial log joint density = -7.918112  #> Path [5] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      2.079e-04   1.236e-06    1.000e+00  1.000e+00       156 -6.190e+00 -6.149e+00                    #> Path [5] :Best Iter: [5] ELBO (-6.149017) evaluations: (156)  #> Path [6] :Initial log joint density = -12.436076  #> Path [6] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      1.446e-03   2.937e-05    1.000e+00  1.000e+00       156 -6.214e+00 -6.219e+00                    #> Path [6] :Best Iter: [4] ELBO (-6.213979) evaluations: (156)  #> Path [7] :Initial log joint density = -17.375130  #> Path [7] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      1.252e-03   3.269e-05    1.000e+00  1.000e+00       156 -6.223e+00 -6.185e+00                    #> Path [7] :Best Iter: [5] ELBO (-6.185291) evaluations: (156)  #> Path [8] :Initial log joint density = -17.242387  #> Path [8] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      1.327e-03   3.547e-05    1.000e+00  1.000e+00       156 -6.198e+00 -6.202e+00                    #> Path [8] :Best Iter: [4] ELBO (-6.198172) evaluations: (156)  #> Path [9] :Initial log joint density = -7.872874  #> Path [9] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      1.980e-04   1.142e-06    1.000e+00  1.000e+00       156 -6.233e+00 -6.171e+00                    #> Path [9] :Best Iter: [5] ELBO (-6.170748) evaluations: (156)  #> Path [10] :Initial log joint density = -7.118235  #> Path [10] : Iter      log prob        ||dx||      ||grad||     alpha      alpha0      # evals       ELBO    Best ELBO        Notes   #>               5      -6.748e+00      1.385e-04   8.963e-08    1.000e+00  1.000e+00       156 -6.183e+00 -6.265e+00                    #> Path [10] :Best Iter: [2] ELBO (-6.183106) evaluations: (156)  #> Pareto k value (1.4) is greater than 0.7. Importance resampling was not able to improve the approximation, which may indicate that the approximation itself is poor.  #> Finished in  0.1 seconds.  # Specifying initial values as a function fit_mcmc_w_init_fun <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   refresh = 0,   init = function() list(theta = runif(1)) ) #> Running MCMC with 2 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.2 seconds. #>  fit_mcmc_w_init_fun_2 <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   refresh = 0,   init = function(chain_id) {     # silly but demonstrates optional use of chain_id     list(theta = 1 / (chain_id + 1))   } ) #> Running MCMC with 2 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.2 seconds. #>  fit_mcmc_w_init_fun_2$init() #> [[1]] #> [[1]]$theta #> [1] 0.5 #>  #>  #> [[2]] #> [[2]]$theta #> [1] 0.3333333 #>  #>   # Specifying initial values as a list of lists fit_mcmc_w_init_list <- mod$sample(   data = stan_data,   seed = 123,   chains = 2,   refresh = 0,   init = list(     list(theta = 0.75), # chain 1     list(theta = 0.25)  # chain 2   ) ) #> Running MCMC with 2 sequential chains... #>  #> Chain 1 finished in 0.0 seconds. #> Chain 2 finished in 0.0 seconds. #>  #> Both chains finished successfully. #> Mean chain execution time: 0.0 seconds. #> Total execution time: 0.3 seconds. #>  fit_optim_w_init_list <- mod$optimize(   data = stan_data,   seed = 123,   init = list(     list(theta = 0.75)   ) ) #> Initial log joint probability = -11.6657  #>     Iter      log prob        ||dx||      ||grad||       alpha      alpha0  # evals  Notes   #>        6      -5.00402   0.000237915   9.55309e-07           1           1        9     #> Optimization terminated normally:   #>   Convergence detected: relative gradient magnitude is below tolerance  #> Finished in  0.1 seconds. fit_optim_w_init_list$init() #> [[1]] #> [[1]]$theta #> [1] 0.75 #>  #>  # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/read_cmdstan_csv.html","id":null,"dir":"Reference","previous_headings":"","what":"Read CmdStan CSV files into R — read_cmdstan_csv","title":"Read CmdStan CSV files into R — read_cmdstan_csv","text":"read_cmdstan_csv() used internally CmdStanR read CmdStan's output CSV files R. can also used CmdStan users flexible efficient alternative rstan::read_stan_csv(). See Value section details structure returned list. also possible create CmdStanR's fitted model objects directly CmdStan CSV files using as_cmdstan_fit() function.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/read_cmdstan_csv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read CmdStan CSV files into R — read_cmdstan_csv","text":"","code":"read_cmdstan_csv(   files,   variables = NULL,   sampler_diagnostics = NULL,   format = getOption(\"cmdstanr_draws_format\", NULL) )  as_cmdstan_fit(   files,   check_diagnostics = TRUE,   format = getOption(\"cmdstanr_draws_format\") )"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/read_cmdstan_csv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read CmdStan CSV files into R — read_cmdstan_csv","text":"files (character vector) paths CmdStan CSV files. can files generated running CmdStanR running CmdStan directly. variables (character vector) Optionally, names variables (parameters, transformed parameters, generated quantities) read . NULL (default) variables included. empty string (variables=\"\") none included. non-scalar variables elements specific elements can selected: variables = \"theta\" selects elements theta; variables = c(\"theta[1]\", \"theta[3]\") selects 1st 3rd elements. sampler_diagnostics (character vector) Works way variables sampler diagnostic variables (e.g., \"treedepth__\", \"accept_stat__\", etc.). Ignored model fit using MCMC. format (string) format storing draws point estimates. default depends method used fit model. See draws details, particular note speed memory models many parameters. check_diagnostics (logical) models fit using MCMC, diagnostic checks performed reading files? default TRUE set FALSE avoid checking problems divergences treedepth.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/read_cmdstan_csv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read CmdStan CSV files into R — read_cmdstan_csv","text":"as_cmdstan_fit() returns CmdStanMCMC, CmdStanMLE, CmdStanLaplace CmdStanVB object. methods typically defined objects work (e.g. save_data_file()) important methods like $summary(), $draws(), $sampler_diagnostics() others work fine. read_cmdstan_csv() returns named list following components: metadata: list meta information run produced CSV file(s). See Examples . components returned list depend method produced CSV file(s). sampling returned list also includes following components: time: Run time information individual chains. returned object $time() method except total run time inferred CSV files (chains may run parallel) therefore NA. inv_metric: list (one element per chain) inverse mass matrices diagonals, depending type metric used. step_size: list (one element per chain) step sizes used. warmup_draws:  save_warmup TRUE fitting model draws_array (different format format specified) warmup draws. post_warmup_draws: draws_array (different format format specified) post-warmup draws. warmup_sampler_diagnostics:  save_warmup TRUE fitting model draws_array (different format format specified) warmup draws sampler diagnostic variables. post_warmup_sampler_diagnostics: draws_array (different format format specified) post-warmup draws sampler diagnostic variables. optimization returned list also includes following components: point_estimates: Point estimates model parameters. laplace variational inference returned list also includes following components: draws: draws_matrix (different format format specified) draws approximate posterior distribution. standalone generated quantities returned list also includes following components: generated_quantities: draws_array generated quantities.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/read_cmdstan_csv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read CmdStan CSV files into R — read_cmdstan_csv","text":"","code":"# \\dontrun{ # Generate some CSV files to use for demonstration fit1 <- cmdstanr_example(\"logistic\", method = \"sample\", save_warmup = TRUE) csv_files <- fit1$output_files() print(csv_files) #> [1] \"/tmp/Rtmpaxzs2V/logistic-202512311805-1-3f054a.csv\" #> [2] \"/tmp/Rtmpaxzs2V/logistic-202512311805-2-3f054a.csv\" #> [3] \"/tmp/Rtmpaxzs2V/logistic-202512311805-3-3f054a.csv\" #> [4] \"/tmp/Rtmpaxzs2V/logistic-202512311805-4-3f054a.csv\"  # Creating fitting model objects  # Create a CmdStanMCMC object from the CSV files fit2 <- as_cmdstan_fit(csv_files) fit2$print(\"beta\") #>  variable  mean median   sd  mad    q5   q95 rhat ess_bulk ess_tail #>   beta[1] -0.67  -0.66 0.25 0.25 -1.08 -0.26 1.00     4956     2938 #>   beta[2] -0.26  -0.26 0.22 0.22 -0.63  0.10 1.00     4261     3012 #>   beta[3]  0.68   0.67 0.27 0.28  0.23  1.12 1.00     4392     3108  # Using read_cmdstan_csv # # Read in everything x <- read_cmdstan_csv(csv_files) str(x) #> List of 8 #>  $ metadata                       :List of 42 #>   ..$ stan_version_major  : num 2 #>   ..$ stan_version_minor  : num 37 #>   ..$ stan_version_patch  : num 0 #>   ..$ start_datetime      : chr \"2025-12-31 18:05:22 UTC\" #>   ..$ method              : chr \"sample\" #>   ..$ save_warmup         : int 1 #>   ..$ thin                : num 1 #>   ..$ gamma               : num 0.05 #>   ..$ kappa               : num 0.75 #>   ..$ t0                  : num 10 #>   ..$ init_buffer         : num 75 #>   ..$ term_buffer         : num 50 #>   ..$ window              : num 25 #>   ..$ save_metric         : int 0 #>   ..$ algorithm           : chr \"hmc\" #>   ..$ engine              : chr \"nuts\" #>   ..$ metric              : chr \"diag_e\" #>   ..$ stepsize_jitter     : num 0 #>   ..$ num_chains          : num 1 #>   ..$ id                  : num [1:4] 1 2 3 4 #>   ..$ init                : num [1:4] 2 2 2 2 #>   ..$ seed                : num 1.85e+09 #>   ..$ refresh             : num 100 #>   ..$ sig_figs            : num 8 #>   ..$ profile_file        : chr \"/tmp/Rtmpaxzs2V/logistic-profile-202512311805-1-542b96.csv\" #>   ..$ save_cmdstan_config : int 0 #>   ..$ stanc_version       : chr \"stanc3 v2.37.0\" #>   ..$ sampler_diagnostics : chr [1:6] \"accept_stat__\" \"stepsize__\" \"treedepth__\" \"n_leapfrog__\" ... #>   ..$ variables           : chr [1:105] \"lp__\" \"alpha\" \"beta[1]\" \"beta[2]\" ... #>   ..$ step_size_adaptation: num [1:4] 0.713 0.558 0.784 0.788 #>   ..$ model_name          : chr \"logistic_model\" #>   ..$ adapt_engaged       : int 1 #>   ..$ adapt_delta         : num 0.8 #>   ..$ max_treedepth       : num 10 #>   ..$ step_size           : num [1:4] 1 1 1 1 #>   ..$ iter_warmup         : num 1000 #>   ..$ iter_sampling       : num 1000 #>   ..$ threads_per_chain   : num 1 #>   ..$ time                :'data.frame':\t4 obs. of  4 variables: #>   .. ..$ chain_id: num [1:4] 1 2 3 4 #>   .. ..$ warmup  : num [1:4] 0.056 0.055 0.055 0.055 #>   .. ..$ sampling: num [1:4] 0.058 0.059 0.054 0.054 #>   .. ..$ total   : num [1:4] 0.114 0.114 0.109 0.109 #>   ..$ stan_variable_sizes :List of 4 #>   .. ..$ lp__   : num 1 #>   .. ..$ alpha  : num 1 #>   .. ..$ beta   : num 3 #>   .. ..$ log_lik: num 100 #>   ..$ stan_variables      : chr [1:4] \"lp__\" \"alpha\" \"beta\" \"log_lik\" #>   ..$ model_params        : chr [1:105] \"lp__\" \"alpha\" \"beta[1]\" \"beta[2]\" ... #>  $ time                           :List of 2 #>   ..$ total : int NA #>   ..$ chains:'data.frame':\t4 obs. of  4 variables: #>   .. ..$ chain_id: num [1:4] 1 2 3 4 #>   .. ..$ warmup  : num [1:4] 0.056 0.055 0.055 0.055 #>   .. ..$ sampling: num [1:4] 0.058 0.059 0.054 0.054 #>   .. ..$ total   : num [1:4] 0.114 0.114 0.109 0.109 #>  $ inv_metric                     :List of 4 #>   ..$ 1: num [1:4] 0.057 0.0721 0.0526 0.0743 #>   ..$ 2: num [1:4] 0.0454 0.0647 0.0502 0.0851 #>   ..$ 3: num [1:4] 0.0474 0.0604 0.0543 0.0754 #>   ..$ 4: num [1:4] 0.0511 0.0625 0.0536 0.0821 #>  $ step_size                      :List of 4 #>   ..$ 1: num 0.713 #>   ..$ 2: num 0.558 #>   ..$ 3: num 0.784 #>   ..$ 4: num 0.788 #>  $ warmup_draws                   : 'draws_array' num [1:1000, 1:4, 1:105] -118.2 -118.2 -118.2 -78 -74.1 ... #>   ..- attr(*, \"dimnames\")=List of 3 #>   .. ..$ iteration: chr [1:1000] \"1\" \"2\" \"3\" \"4\" ... #>   .. ..$ chain    : chr [1:4] \"1\" \"2\" \"3\" \"4\" #>   .. ..$ variable : chr [1:105] \"lp__\" \"alpha\" \"beta[1]\" \"beta[2]\" ... #>  $ post_warmup_draws              : 'draws_array' num [1:1000, 1:4, 1:105] -64.5 -64.7 -64.9 -66.3 -66.9 ... #>   ..- attr(*, \"dimnames\")=List of 3 #>   .. ..$ iteration: chr [1:1000] \"1\" \"2\" \"3\" \"4\" ... #>   .. ..$ chain    : chr [1:4] \"1\" \"2\" \"3\" \"4\" #>   .. ..$ variable : chr [1:105] \"lp__\" \"alpha\" \"beta[1]\" \"beta[2]\" ... #>  $ warmup_sampler_diagnostics     : 'draws_array' num [1:1000, 1:4, 1:6] 4.15e-01 0.00 1.10e-30 1.00 1.00 ... #>   ..- attr(*, \"dimnames\")=List of 3 #>   .. ..$ iteration: chr [1:1000] \"1\" \"2\" \"3\" \"4\" ... #>   .. ..$ chain    : chr [1:4] \"1\" \"2\" \"3\" \"4\" #>   .. ..$ variable : chr [1:6] \"accept_stat__\" \"stepsize__\" \"treedepth__\" \"n_leapfrog__\" ... #>  $ post_warmup_sampler_diagnostics: 'draws_array' num [1:1000, 1:4, 1:6] 0.983 0.984 0.951 0.843 0.633 ... #>   ..- attr(*, \"dimnames\")=List of 3 #>   .. ..$ iteration: chr [1:1000] \"1\" \"2\" \"3\" \"4\" ... #>   .. ..$ chain    : chr [1:4] \"1\" \"2\" \"3\" \"4\" #>   .. ..$ variable : chr [1:6] \"accept_stat__\" \"stepsize__\" \"treedepth__\" \"n_leapfrog__\" ...  # Don't read in any of the sampler diagnostic variables x <- read_cmdstan_csv(csv_files, sampler_diagnostics = \"\")  # Don't read in any of the parameters or generated quantities x <- read_cmdstan_csv(csv_files, variables = \"\")  # Read in only specific parameters and sampler diagnostics x <- read_cmdstan_csv(   csv_files,   variables = c(\"alpha\", \"beta[2]\"),   sampler_diagnostics = c(\"n_leapfrog__\", \"accept_stat__\") )  # For non-scalar parameters all elements can be selected or only some elements, # e.g. all of the vector \"beta\" but only one element of the vector \"log_lik\" x <- read_cmdstan_csv(   csv_files,   variables = c(\"beta\", \"log_lik[3]\") ) # }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/read_sample_csv.html","id":null,"dir":"Reference","previous_headings":"","what":"Read CmdStan CSV files from sampling into R — read_sample_csv","title":"Read CmdStan CSV files from sampling into R — read_sample_csv","text":"Deprecated. Use read_cmdstan_csv() instead.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/read_sample_csv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read CmdStan CSV files from sampling into R — read_sample_csv","text":"","code":"read_sample_csv(files, variables = NULL, sampler_diagnostics = NULL)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/read_sample_csv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read CmdStan CSV files from sampling into R — read_sample_csv","text":"files, variables, sampler_diagnostics Deprecated. Use read_cmdstan_csv() instead.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/register_knitr_engine.html","id":null,"dir":"Reference","previous_headings":"","what":"Register CmdStanR's knitr engine for Stan — register_knitr_engine","title":"Register CmdStanR's knitr engine for Stan — register_knitr_engine","text":"Registers CmdStanR's knitr engine eng_cmdstan() processing Stan chunks. Refer vignette R Markdown CmdStan Engine demonstration.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/register_knitr_engine.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Register CmdStanR's knitr engine for Stan — register_knitr_engine","text":"","code":"register_knitr_engine(override = TRUE)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/register_knitr_engine.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Register CmdStanR's knitr engine for Stan — register_knitr_engine","text":"override (logical) Override knitr's built-, RStan-based engine Stan? default TRUE. See Details.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/register_knitr_engine.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Register CmdStanR's knitr engine for Stan — register_knitr_engine","text":"override = TRUE (default), registers CmdStanR's knitr engine engine stan chunks, replacing knitr's built-, RStan-based engine. override = FALSE, registers cmdstan engine engines may used R Markdown document. template supports syntax highlighting Stan language, cmdstan chunks stan syntax highlighting applied . See vignette R Markdown CmdStan Engine example. Note: running chunks interactively RStudio (e.g. using R Notebooks), observed built-, RStan-based engine used stan chunks even CmdStanR's engine registered session. R Markdown document knit/rendered, correct engine used. workaround, running chunks interactively, recommended use override = FALSE option change stan chunks cmdstan chunks. like keep stan chunks stan chunks, possible specify engine = \"cmdstan\" chunk options registering cmdstan engine override = FALSE.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/register_knitr_engine.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Register CmdStanR's knitr engine for Stan — register_knitr_engine","text":"Register custom language engine knitr knitr's built-Stan language engine","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/set_cmdstan_path.html","id":null,"dir":"Reference","previous_headings":"","what":"Get or set the file path to the CmdStan installation — set_cmdstan_path","title":"Get or set the file path to the CmdStan installation — set_cmdstan_path","text":"Use set_cmdstan_path() function tell CmdStanR CmdStan installation located. path set, cmdstan_path() return full path CmdStan installation cmdstan_version() return CmdStan version number. See Details avoid manually setting path R session.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/set_cmdstan_path.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get or set the file path to the CmdStan installation — set_cmdstan_path","text":"","code":"set_cmdstan_path(path = NULL)  cmdstan_path()  cmdstan_version(error_on_NA = TRUE)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/set_cmdstan_path.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get or set the file path to the CmdStan installation — set_cmdstan_path","text":"path (string) full file path CmdStan installation. NULL (default) path set default path used install_cmdstan() exists. error_on_NA (logical) error thrown CmdStan found. default TRUE. FALSE, cmdstan_version() returns NULL.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/set_cmdstan_path.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get or set the file path to the CmdStan installation — set_cmdstan_path","text":"string. Either file path CmdStan installation CmdStan version number. CmdStan version string available. CmdStan found error_on_NA FALSE, cmdstan_version() returns NULL.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/set_cmdstan_path.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get or set the file path to the CmdStan installation — set_cmdstan_path","text":"package can used needs know CmdStan installation located. package loaded tries help automate avoid manually set path every session: environment variable \"CMDSTAN\" exists load time value automatically set default path CmdStan R session. environment variable \"CMDSTAN\" set, valid CmdStan found supplied path, path treated top folder contains CmdStan installations. case, CmdStan installation largest version number set path CmdStan R session. environment variable found loaded directory form \".cmdstan/cmdstan-[version]\" (e.g., \".cmdstan/cmdstan-2.23.0\"), exists user's home directory (Sys.getenv(\"HOME\"), current working directory) path cmdstan largest version number set path CmdStan R session. default directory install_cmdstan() use install latest version CmdStan. always possible change path loading package using set_cmdstan_path(path).","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/stan_threads.html","id":null,"dir":"Reference","previous_headings":"","what":"Set or get the number of threads used to execute Stan models — stan_threads","title":"Set or get the number of threads used to execute Stan models — stan_threads","text":"DEPRECATED. Please use threads_per_chain argument fitting model.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/stan_threads.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set or get the number of threads used to execute Stan models — stan_threads","text":"","code":"num_threads()  set_num_threads(num_threads)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/stan_threads.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set or get the number of threads used to execute Stan models — stan_threads","text":"num_threads (positive integer) number threads set.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/stan_threads.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set or get the number of threads used to execute Stan models — stan_threads","text":"value environment variable STAN_NUM_THREADS.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/write_stan_file.html","id":null,"dir":"Reference","previous_headings":"","what":"Write Stan code to a file — write_stan_file","title":"Write Stan code to a file — write_stan_file","text":"Convenience function writing Stan code (possibly temporary) file .stan extension. default, file name chosen deterministically based hash Stan code, file overwritten already correct contents. means calling function multiple times Stan code reuse compiled model. also however means function potentially thread-safe. Using hash_salt = Sys.getpid() ensure thread-safety rare cases needed.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/write_stan_file.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write Stan code to a file — write_stan_file","text":"","code":"write_stan_file(   code,   dir = getOption(\"cmdstanr_write_stan_file_dir\", tempdir()),   basename = NULL,   force_overwrite = FALSE,   hash_salt = \"\" )"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/write_stan_file.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write Stan code to a file — write_stan_file","text":"code (character vector) Stan code write file. can character vector length one (string) containing entire Stan program character vector element containing one line Stan program. dir (string) optional path directory file written. omitted, global option cmdstanr_write_stan_file_dir used. global options set, temporary directory used. basename (string) dir specified, optionally basename use file created. specified file name generated hashing code. force_overwrite (logical) set TRUE file always overwritten thus resulting model always recompiled. hash_salt (string) Text add model code prior hashing determine file name basename set.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/write_stan_file.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write Stan code to a file — write_stan_file","text":"path file.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/write_stan_file.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write Stan code to a file — write_stan_file","text":"","code":"# stan program as a single string stan_program <- \" data {   int<lower=0> N;   array[N] int<lower=0,upper=1> y; } parameters {   real<lower=0,upper=1> theta; } model {   y ~ bernoulli(theta); } \"  f <- write_stan_file(stan_program) print(f) #> [1] \"/tmp/Rtmpaxzs2V/model_7f12fc190dd23b0e462f7d73040dd97e.stan\"  lines <- readLines(f) print(lines) #>  [1] \"\"                                   \"data {\"                             #>  [3] \"  int<lower=0> N;\"                  \"  array[N] int<lower=0,upper=1> y;\" #>  [5] \"}\"                                  \"parameters {\"                       #>  [7] \"  real<lower=0,upper=1> theta;\"     \"}\"                                  #>  [9] \"model {\"                            \"  y ~ bernoulli(theta);\"            #> [11] \"}\"                                  \"\"                                   cat(lines, sep = \"\\n\") #>  #> data { #>   int<lower=0> N; #>   array[N] int<lower=0,upper=1> y; #> } #> parameters { #>   real<lower=0,upper=1> theta; #> } #> model { #>   y ~ bernoulli(theta); #> } #>   # stan program as character vector of lines f2 <- write_stan_file(lines) identical(readLines(f), readLines(f2)) #> [1] TRUE"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/write_stan_json.html","id":null,"dir":"Reference","previous_headings":"","what":"Write data to a JSON file readable by CmdStan — write_stan_json","title":"Write data to a JSON file readable by CmdStan — write_stan_json","text":"Write data JSON file readable CmdStan","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/write_stan_json.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write data to a JSON file readable by CmdStan — write_stan_json","text":"","code":"write_stan_json(data, file, always_decimal = FALSE)"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/write_stan_json.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write data to a JSON file readable by CmdStan — write_stan_json","text":"data (list) named list R objects. file (string) path data file written. always_decimal (logical) Force generate non-integers decimal points better distinguish integers floating point values. TRUE R objects data intended integers must integer type.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/write_stan_json.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Write data to a JSON file readable by CmdStan — write_stan_json","text":"write_stan_json() performs several conversions writing JSON file: logical -> integer (TRUE -> 1, FALSE -> 0) data.frame -> matrix (via data.matrix()) list -> array table -> vector, matrix, array (depending dimensions table) list array conversion intended make easier prepare data certain Stan declarations involving arrays: vector[J] v[K] (equivalently array[K] vector[J] v  Stan 2.27) can constructed R list K elements element vector length J matrix[,J] v[K] (equivalently array[K] matrix[,J] m  Stan 2.27 ) can constructed R list K elements element IxJ matrix can also passed R arrays instead lists list option provided convenience. Unfortunately arrays one dimension, e.g., vector[J] v[K,L] (equivalently array[K,L] vector[J] v  Stan 2.27) possible use R list array must used instead. example array R dimensions KxLxJ.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/write_stan_json.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write data to a JSON file readable by CmdStan — write_stan_json","text":"","code":"x <- matrix(rnorm(10), 5, 2) y <- rpois(nrow(x), lambda = 10) z <- c(TRUE, FALSE) data <- list(N = nrow(x), K = ncol(x), x = x, y = y, z = z)  # write data to json file file <- tempfile(fileext = \".json\") write_stan_json(data, file)  # check the contents of the file cat(readLines(file), sep = \"\\n\") #> { #>   \"N\": 5, #>   \"K\": 2, #>   \"x\": [ #>     [1.60440732826108, 2.11227728781614], #>     [-1.51502452882071, -0.356124415722617], #>     [-1.41602391449351, -1.06446420865157], #>     [0.876777326556075, 1.07711653845397], #>     [0.624132412621394, 1.18157556654405] #>   ], #>   \"y\": [10, 8, 11, 16, 15], #>   \"z\": [1, 0] #> }   # demonstrating list to array conversion # suppose x is declared as `vector[3] x[2]` (or equivalently `array[2] vector[3] x`) # we can use a list of length 2 where each element is a vector of length 3 data <- list(x = list(1:3, 4:6)) file <- tempfile(fileext = \".json\") write_stan_json(data, file) cat(readLines(file), sep = \"\\n\") #> { #>   \"x\": [ #>     [1, 2, 3], #>     [4, 5, 6] #>   ] #> }"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/write_stan_tempfile.html","id":null,"dir":"Reference","previous_headings":"","what":"Write Stan code to a temporary file — write_stan_tempfile","title":"Write Stan code to a temporary file — write_stan_tempfile","text":"function deprecated. Please use write_stan_file() instead.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/reference/write_stan_tempfile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write Stan code to a temporary file — write_stan_tempfile","text":"","code":"write_stan_tempfile(code, dir = tempdir())"},{"path":"https://mc-stan.org/cmdstanr/dev/reference/write_stan_tempfile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write Stan code to a temporary file — write_stan_tempfile","text":"code (character vector) Stan code write file. can character vector length one (string) containing entire Stan program character vector element containing one line Stan program. dir (string) optional path directory file written. omitted, global option cmdstanr_write_stan_file_dir used. global options set, temporary directory used.","code":""},{"path":[]},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"general-improvementschanges-0-9-0","dir":"Changelog","previous_headings":"","what":"General Improvements/Changes","title":"cmdstanr 0.9.0","text":"Added compatibility RTools45 (#1066) cmdstanr now use RTools additional toolchain updates needed Windows (CmdStan 2.35+ ; #1065, #1054) Improve error messages calling sampler_diagnostics() fixed_param=TRUE Improve numerical stability calculation effective sample size loo method (#1057) Improve numerical stablity small log-ratios calculation effective sample size loo method (#1015) Add warning input data/inits coerced ints (#994)","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"bugfixes-0-9-0","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"cmdstanr 0.9.0","text":"Don’t require fixed_param models zero parameters (GQs) CmdStan >= 2.36 (#1046) Improve detection/handling make (#1036) Fix saving model objects network drive (#1038, thanks @bschneidr) Update usage untar fix installation errors (#1034) Respect compilation flags make/local exposing functions model methods (#1003) Fix passing include paths CmdStan (#1000) Fix passing factor data CmdStan (#999) Fix extraction passing array data/parameters model inits (#993)","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"documentation-updates-0-9-0","dir":"Changelog","previous_headings":"","what":"Documentation Updates","title":"cmdstanr 0.9.0","text":"Clarifications usage optimize loo methods (#1060) Add documentation faster model saving large models (#1042) Remove mentions rstan::read_stan_csv due incompatibility newer CmdStan outputs (#1018) Document global option cmdstanr_print_line_numbers printing line numbers (#1017) Change usage ‘chapter’ ‘section’ documentation (#1014) Remove examples updating removed array syntax functionality longer supported CmdStan (#1008) Change usages ‘sampling statement’ -> ‘distribution statement’ (#987)","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"minor-changes-0-8-1","dir":"Changelog","previous_headings":"","what":"Minor changes","title":"cmdstanr 0.8.1","text":"Added CMDSTANR_USE_RTOOLS environment variable force stock RTools Windows @andrjohns #980 Added support Windows ARM64 @andrjohns #990 Automatically initialise model methods called, add inc_warmup argument $unconstrain_draws() @andrjohns #985","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"bugfixes-0-8-1","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"cmdstanr 0.8.1","text":"Fix errors using pathfinder object initial values @avehtari #984 Fix error $unconstrain_draws() returning incorrect assumptions cases @andrjohns #983 Fix spurious errors missing CmdStan config files @andrjohns #981 Fix linking error exposing SUNDIALS/KINSOL functions model methods @andrjohns #977 Fix long-standing error OneDrive paths Windows @andrjohns #990","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"major-new-features-0-8-0","dir":"Changelog","previous_headings":"","what":"Major new features","title":"cmdstanr 0.8.0","text":"Add functionality passing CmdStanFit objects initial values @SteveBronder #937","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"other-improvements-0-8-0","dir":"Changelog","previous_headings":"","what":"Other improvements","title":"cmdstanr 0.8.0","text":"Add compatibility CmdStan 2.35 @andrjohns #972 Add show_messages show_exceptions arguments methods controlling output @andrjohns #897 Drop RcppEigen dependency, implement basic Eigen -> C++ interop @andrjohns #899 Add compatibility CmdStan 2.34 @andrjohns #905 #910 Add format argument unconstrain_draws() method specify draws format return @andrjohns #886 Align cmdstanr EBFMI diagnostic threshold CmdStan @andrjohns #892 Add global option cmdstanr_print_line_numbers add line number model printing @sbfnk #967 Add new CmdStan arguments save_metric save_cmdstan_config @venpopov #932 Add documentation CmdStanR global options @jgabry #951 Add documentation obtain structured output similar rstan::extract() using combination cmdstanr posterior @jgabry #955 Added coercion generics CmdStanFit objects @gowerc #943 psis_resample calculate_lp arguments added Pathfinder method @SteveBronder #903 Documentation tests LOO method updated @jgabry #923 Global option cmdstanr_warn_inits added disable warnings partially specified initial values @jgabry #913 Updates MCMC output_dir documentation @jgabry #929","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"bugfixes-0-8-0","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"cmdstanr 0.8.0","text":"Fix broken link OpenCL documentation @eipi10 #908 Fix minor typo README @jgabry #911 Make exported RNG functions respect changes R’s seed @andrjohns #973 Optimisations model methods functions @andrjohns #960 Bugfix passing function initial values Pathfinder method default num_paths @andrjohns #964 Continue compilation compile_stanalone=TRUE functions found @jgabry #956 Update tests CI compatibility MacOS ARM64 @andrjohns #958 Fix handling inv_metric argument 1 parameter @venpopov #935 Fixes compatibility RTools44 @andrjohns #952 #959","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"major-new-features-0-7-0","dir":"Changelog","previous_headings":"","what":"Major new features","title":"cmdstanr 0.7.0","text":"New laplace method @jgabry #800 New pathfinder method @SteveBronder #848","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"other-improvements-and-bug-fixes-0-7-0","dir":"Changelog","previous_headings":"","what":"Other improvements and bug fixes","title":"cmdstanr 0.7.0","text":"Add missing link diagnose method CmdStanModel doc @jgabry #833 Improvements compile tests @martinmodrak #836 Changed delay behavior wsl_installed @martinmodrak #839 Update array syntax website vignette @andrjohns #841 Compatibility fixes cmdstan 2.33+ @jgabry #843 Suggest format method error due old syntax @jgabry #852 Clarifications R-markdown vignette @jgcolman #854 Update linux/wsl detection install arch @andrjohns #856 Fix handling single-length inits containers @andrjohns #857 Add support/tests exposing functions tuples @andrjohns #860 Add support/tests exporting functions complex types @andrjohns #861 Add option installing release archive @andrjohns #866 Improve Pathfinder doc @avehtari #875 Rename jacobian_adjustment argument jacobian @jgabry #879 Fix get_cmdstan_flags(‘STANCFLAGS’) recursive make @pearsonca #881","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"cmdstanr-061","dir":"Changelog","previous_headings":"","what":"cmdstanr 0.6.1","title":"cmdstanr 0.6.1","text":"Store return codes instead always querying exit status @jgabry #798 enable jacobian argument optimization @jgabry #799 Fix init_model_methods models data @andrjohns #801 Document CmdStan-focused way pre-compile Stan models R packages @wlandau #809 Describe efficiently save model fit objects @wlandau #816 fix errors doc new methods @jgabry #823 Give informative error exposing stan functions precompiled model @andrjohns #831 Bugfixes .stanfunctions, hessian model method, exposing RNG functions @andrjohns #811 Fix variable_skeleton() containers @andrjohns #832 Improve handling user header @martinmodrak #818 change duplicate stdout_file stderr_file @jgabry #834","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"major-new-features-0-6-0","dir":"Changelog","previous_headings":"","what":"Major new features","title":"cmdstanr 0.6.0","text":"New expose_functions() method expose Stan functions R @andrjohns #702. See ?expose_functions. New methods accessing log_prob, grad_log_prob, hessian, un/constrain variables @andrjohns #701. See ?init_model_methods.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"other-changes-0-6-0","dir":"Changelog","previous_headings":"","what":"Other changes","title":"cmdstanr 0.6.0","text":"mod$variables works w includes precompile state (fix #680) @MKyhos #682 Update broken link Stan OpenCL support page @erictleung #686 Add newline check syntax output @rok-cesnovar #689 Allow exposing functions without sampling @andrjohns #705 Expose skeleton @andrjohns #706 WSL - Run cmdstan models WSL filesystem @andrjohns #696 Bugfix - Deep copy method/function environments @andrjohns #709 Add option including jacobian adjustments hessian method @andrjohns #710 WSL Optimisations Bugfixes CI @andrjohns #711 add stancflags make/local @rok-cesnovar #690 Update co-authors @andrjohns #715 Update model methods parameter naming extract skeleton function @andrjohns #724 Add method unconstraining parameter draws @andrjohns #729 Improve efficiency variable matching @sbfnk #736 Add verbosity download output errors @andrjohns #745 Update handling show_messages, add show_exceptions @andrjohns #746 Rtools43 support @andrjohns #755 Add stanc M1 make patch, suppress boost warnings @andrjohns #756 examples summary method @gravesti #751 Fix model\\(format model\\)check_syntax compiled models include-paths @adrian-lison #775 Generalise RTools config/support @andrjohns #777 New posterior vignette @gravesti #719 Add moment-matching support $loo() method @andrjohns #778 replace  function @jsocolar #789","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"new-features-0-5-3","dir":"Changelog","previous_headings":"","what":"New features","title":"cmdstanr 0.5.3","text":"Windows, users can now install use CmdStan WSL (Windows Subsystem Linux). Set wsl=TRUE install_cmdstan() install CmdStan use WSL. can offer significant speedups compared native Windows execution. (#677, @andrjohns)","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"bug-fixes-0-5-3","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"cmdstanr 0.5.3","text":"cmdstan_default_path() now ignore directories inside .cmdstan don’t start \"cmdstan-\". (#651) Fixed Windows issue related locating grep.exe located path spaces. (@weshinsley, #661, #663) Fixed bug diagnostic checks ebfmi NaN. Fixed bug caused issues using ~ . paths supplied cmdstanr_write_stan_file_dir global option. Fixed bug caused time() method fail chains failed finish succesfully.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"cmdstanr-052","dir":"Changelog","previous_headings":"","what":"cmdstanr 0.5.2","title":"cmdstanr 0.5.2","text":"Refactored toolchain installation checks R 4.x Windows added support Rtools42. (#645) Expanded use CMDSTAN environment variable point CmdStan installation directory containing CmdStan installations. (#643) New vignette handle deprecations using $format() method. (#644)","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"cmdstanr-051","dir":"Changelog","previous_headings":"","what":"cmdstanr 0.5.1","title":"cmdstanr 0.5.1","text":"Temporarily disable format=\"draws_rvars\" $draws() method due bug. fixed users can make use posterior::as_draws_rvars() convert draws CmdStanR draws_rvars format. (#640)","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"bug-fixes-0-5-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"cmdstanr 0.5.0","text":"Fixed bug caused stdour/stderr read end optimization. (#522) Fixed issue handling NA reported external process status. (#544, @myshkin) Fixed issue handling models parameters CmdStan 2.27+.","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"new-features-0-5-0","dir":"Changelog","previous_headings":"","what":"New features","title":"cmdstanr 0.5.0","text":"Default directory changed .cmdstan instead .cmdstanr CmdStanPy CmdStanR can use CmdStan installations. Using .cmdstanr continue supported version 1.0 install_cmdstan() now default .cmdstan CmdStanR first look .cmdstan falling back .cmdstanr. (#454) New method diagnose() CmdstanModel objects exposes CmdStan’s diagnose method comparing Stan’s gradient computations gradients computed via finite differences. (#485) New method $variables() CmdstanModel objects returns list variables Stan model, types number dimensions. require model compiled. (#519) New method $format() auto-formatting canonicalizing Stan models. (#625) Added option create CmdStanModel executable exe_file argument. (#564) Added convenience argument user_header $compile() cmdstan_model() simplifies use external .hpp file compile model. Added cmdstanr_force_recompile global option used forcing recompilation Stan models. (#580) New method $code() fitted model objects returns Stan code associated fitted model. (#575) New method $diagnostic_summary() CmdStanMCMC objects summarizes sampler diagnostics (divergences, treedepth, ebfmi) can regenerate related warning messages. (#205) New diagnostics argument $sample() method specify diagnostics checked sampling. Replaces validate_csv argument. (#205) Added E-BFMI checks run automatically post sampling. (#500, @jsocolar) New methods posterior::as_draws() CmdStanR fitted model objects. just wrappers around $draws() method provided convenience. (#532) write_stan_file() now choose file names deterministically based code models get unnecessarily recompiled calling function multiple times code. (#495, @martinmodrak) dir argument write_stan_file() can now set global option. (#537) write_stan_json() now handles data class \"table\". Tables converted vector, matrix, array depending dimensions table. (#528) Improved processing named lists supplied data argument JSON data files: checking whether list includes required elements/Stan variables; improved differentiating arrays/vectors length 1 scalars generating JSON data files; generating floating point numbers decimal points fix issue parsing large numbers. (#538) install_cmdstan() now automatically installs Linux ARM CmdStan Linux distributions running ARM CPUs detected. (#531) New function as_mcmc.list() converting CmdStanMCMC objects mcmc.list objects coda package. (#584, @MatsuuraKentaro)","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"bug-fixes-0-4-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"cmdstanr 0.4.0","text":"Fixed issue retrieving draws models spaces names. (#453) Fixed bug spaces path temporary folder Windows. (#460) Fixed issue reporting model executable name clashing folder name. (#461)","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"new-features-0-4-0","dir":"Changelog","previous_headings":"","what":"New features","title":"cmdstanr 0.4.0","text":"New function as_cmdstan_fit() creates CmdStanMCMC/MLE/VB objects directly CmdStan CSV files. (#412) read_cmdstan_csv() now also returns chain run times MCMC sampling CSV files. (#414) Faster CSV reading multiple chains. (#419) New $profiles() method fitted model objects accesses profiling information R profiling used Stan program. Support profiling Stan programs requires CmdStan >= 2.26. (#434) New vignette profiling Stan programs. (#435) New vignette running Stan GPU OpenCL. OpenCL device ids can now also specified runtime. (#439) New check invalid parameter names supplying init values. (#452, @mike-lawrence) Suppressing compilation messages interactive mode. (#462, @wlandau) New error_on_NA argument cmdstan_version() optionally return NULL (instead erroring) CmdStan path found (#467, @wlandau). Global option cmdstanr_max_rows can set alternative specifying max_rows argument $print() method. (#470) New output_basename argument model fitting methods. Can used conjunction output_dir get completely predictable output CSV file paths. (#471) New format argument $draws(), $sampler_diagnostics(), read_cmdstan_csv(), as_cmdstan_fit(). controls format draws returned stored object. Changing format can improve speed memory usage large models. (#482)","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"bug-fixes-0-3-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"cmdstanr 0.3.0","text":"Fixed reading inverse mass matrix values written scientific format CSV. (#394) Fixed error caused empty data list. Previously model didn’t require data data either NULL non-empty list, now list() allowed. (#403)","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"new-features-0-3-0","dir":"Changelog","previous_headings":"","what":"New features","title":"cmdstanr 0.3.0","text":"Added $sample_mpi() MCMC sampling MPI. (#350) Added informative messages compile errors caused precompiled headers (PCH). (#384) Added cmdstanr_verbose option verbose mode. Intended troubleshooting, debugging development. See end CmdStanR work? vignette details. (#392) New $loo() method CmdStanMCMC objects. Requires computing pointwise log-likelihood Stan program. (#366) fitted_params argument $generate_quantities() method now also accepts CmdStanVB, posterior::draws_array, posterior::draws_matrix objects. (#390) $optimize() method now supports CmdStan’s tolerance-related arguments (L)BFGS. (#398) documentation R6 methods now uses @param, allows package developers import CmdStanR documentation using roxygen2’s @inheritParams. (#408)","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"bug-fixes-0-2-2","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"cmdstanr 0.2.2","text":"Fixed bug reading Stan CSV grep used coloring default (#364,#371) Depend posterior v0.1.3 avoid potential error $summary(). (#383)","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"new-features-0-2-2","dir":"Changelog","previous_headings":"","what":"New features","title":"cmdstanr 0.2.2","text":"Added support native execution macOS M1 ARM-based CPU. (#375) Added threading support via threads argument $optimize() $variational() (already available via threads_per_chain $sample()). (#369)","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"bug-fixes-0-2-1","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"cmdstanr 0.2.1","text":"Fixed bug processing stanc_options check_syntax(). (#345) Fixed bug access one variable via draws(). (#348)","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"new-features-0-2-1","dir":"Changelog","previous_headings":"","what":"New features","title":"cmdstanr 0.2.1","text":"compile() check_syntax() methods gain argument pedantic turning pedantic mode, warns issues model beyond syntax errors. (#361)","code":""},{"path":[]},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"bug-fixes-0-2-0","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"cmdstanr 0.2.0","text":"Fix potential indexing error using read_cmdstan_csv() CSV files created CmdStan without CmdStanR. (#291, #292, @johnlees) Fix error returning draws sampler diagnostics fit warmup samples. (#288, #293) Fix trailing slashes issue dir cmdstan_model() output_dir fitting methods. (#281, #294) Fix dimensions error processing list matrices passed data. (#296, #302) Fix reporting time using fixed_param method. (#303, #307) refresh = 0, output error messages printed $optimize() $variational(). (#324) Fix issue names generated files clash. (#326, #328) Fix missing include_paths $syntax_check(). (#335, @mike-lawrence)","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"new-features-0-2-0","dir":"Changelog","previous_headings":"","what":"New features","title":"cmdstanr 0.2.0","text":"CSV reading now faster using data.table::fread(). (#318) install_cmdstan() gains argument version specifying version CmdStan install. (#300, #308) New function check_cmdstan_toolchain() checks appropriate toolchains available. (#289) $sample() method CmdStanModel objects gains argument chain_ids specifying custom chain IDs. (#319) Added support sig_figs argument CmdStan versions 2.25 . (#327) Added checks user necessary permissions RTools temporary folders. (#343)","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"cmdstanr-013","dir":"Changelog","previous_headings":"","what":"cmdstanr 0.1.3","title":"cmdstanr 0.1.3","text":"New $check_syntax() method CmdStanModel objects. (#276, #277)","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"cmdstanr-012","dir":"Changelog","previous_headings":"","what":"cmdstanr 0.1.2","title":"cmdstanr 0.1.2","text":"User notified message load time new release CmdStan available. (#265, #273) write_stan_file() replaces write_stan_tempfile(), now deprecated. addition dir argument, file written necessarily temporary. (#267, #272)","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"cmdstanr-011","dir":"Changelog","previous_headings":"","what":"cmdstanr 0.1.1","title":"cmdstanr 0.1.1","text":"New knitr engine eng_cmdstan() function register_knitr_engine() allow Stan chunks R markdown documents processed using CmdStanR instead RStan. new vignette R Markdown CmdStan Engine provides demonstration. (#261, #264, @bearloga)","code":""},{"path":"https://mc-stan.org/cmdstanr/dev/news/index.html","id":"cmdstanr-010","dir":"Changelog","previous_headings":"","what":"cmdstanr 0.1.0","title":"cmdstanr 0.1.0","text":"Beta release","code":""}]
